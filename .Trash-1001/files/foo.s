;;; All the macros and the scheme-object printing procedure
;;; are defined in compiler.s
%include "compiler.s"

section .bss
;;; This pointer is used to manage allocations on our heap.
malloc_pointer:
    resq 1

;;; here we REServe enough Quad-words (64-bit "cells") for the free variables
;;; each free variable has 8 bytes reserved for a 64-bit pointer to its value
fvar_tbl:
    resq 47

section .data
const_tbl:
db T_VOID
db T_NIL
db T_BOOL ,0
db T_BOOL ,1
MAKE_LITERAL_RATIONAL(6, 1)

;;; These macro definitions are required for the primitive
;;; definitions in the epilogue to work properly
%define SOB_VOID_ADDRESS const_tbl+0
%define SOB_NIL_ADDRESS const_tbl+1
%define SOB_FALSE_ADDRESS const_tbl+2
%define SOB_TRUE_ADDRESS const_tbl+4

global main
section .text
main:
    ;; set up the heap
    mov rdi, GB(2)
    call malloc
    mov [malloc_pointer], rax

    ;; Set up the dummy activation frame
    ;; The dummy return address is T_UNDEFINED
    ;; (which a is a macro for 0) so that returning
    ;; from the top level (which SHOULD NOT HAPPEN
    ;; AND IS A BUG) will cause a segfault.
    push 0                ; argument count
    push SOB_NIL_ADDRESS  ; lexical environment address
    push T_UNDEFINED      ; return address
    push rbp                    
    mov rbp, rsp                ; anchor the dummy frame

    ;; Set up the primitive stdlib fvars:
    ;; Since the primtive procedures are defined in assembly,
    ;; they are not generated by scheme (define ...) expressions.
    ;; This is where we simulate the missing (define ...) expressions
    ;; for all the primitive procedures.
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, boolean?)
mov [fvar_tbl+ (0*8)], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, flonum?)
mov [fvar_tbl+ (1*8)], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, rational?)
mov [fvar_tbl+ (2*8)], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, pair?)
mov [fvar_tbl+ (3*8)], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, null?)
mov [fvar_tbl+ (4*8)], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, char?)
mov [fvar_tbl+ (5*8)], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, string?)
mov [fvar_tbl+ (6*8)], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, procedure?)
mov [fvar_tbl+ (7*8)], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, symbol?)
mov [fvar_tbl+ (8*8)], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, string_length)
mov [fvar_tbl+ (9*8)], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, string_ref)
mov [fvar_tbl+ (10*8)], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, string_set)
mov [fvar_tbl+ (11*8)], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, make_string)
mov [fvar_tbl+ (12*8)], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, symbol_to_string)
mov [fvar_tbl+ (13*8)], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, char_to_integer)
mov [fvar_tbl+ (14*8)], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, integer_to_char)
mov [fvar_tbl+ (15*8)], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, exact_to_inexact)
mov [fvar_tbl+ (16*8)], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, eq?)
mov [fvar_tbl+ (17*8)], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, add)
mov [fvar_tbl+ (18*8)], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, mul)
mov [fvar_tbl+ (19*8)], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, div)
mov [fvar_tbl+ (20*8)], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, eq)
mov [fvar_tbl+ (21*8)], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, lt)
mov [fvar_tbl+ (22*8)], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, numerator)
mov [fvar_tbl+ (23*8)], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, denominator)
mov [fvar_tbl+ (24*8)], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, gcd)
mov [fvar_tbl+ (25*8)], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, apply)
mov [fvar_tbl+ (27*8)], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, car)
mov [fvar_tbl+ (28*8)], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, cdr)
mov [fvar_tbl+ (29*8)], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, set_car)
mov [fvar_tbl+ (42*8)], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, set_cdr)
mov [fvar_tbl+ (43*8)], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, cons)
mov [fvar_tbl+ (30*8)], rax

user_code_fragment:
;;; The code you compiled will be added here.
;;; It will be executed immediately after the closures for 
;;; the primitive procedures are set up.
;we know that env = [rbp + 8*2]
; we know that depth is env.length
; now we SHOULD allocate extenv with size env.length+1= depth+1
MALLOC rax, 8*(1+0) ; rax->extEnv
mov rbx, 0 ;i
mov rcx, 1 ;j
;following loop is to shift the env in extended env
loop_1:
    cmp rbx, 0
    jge end_loop_1
    mov rdx, [rbp + 8*2] ; rdx = env
    shl rbx, 3
    add rdx, rbx ; env[i] =-->[var, var,...var] 
    shr rbx, 3
    mov r8, [rdx] 
    mov [rax + 8*rcx], r8 ; extEnv[j]=env[i]
    inc rcx
    inc rbx
    jmp loop_1
end_loop_1:
 ;  rax holds ->extEnv
;n= [rbp+8*3]
mov rbx, rax ;rbx holds extEnv
; Allocate ExtEnv[0] to point to a vector where to store the parameters
mov r8, [rbp+8*3] ; r8= n
inc r8; +magic
shl r8, 3
MALLOC r9, r8 ; r9 holds the vector for the params with size 8*n +1 for magic
shr r8, 3
dec r8; - magic
mov rcx, 0 ;i=0
;following loop is to Copy the parameters off of the stack to the extended env:
loop_2:
    cmp rcx ,r8 ; i<n
    jge end_loop_2
    mov rdx, [rbp+8*(4+rcx)] ;  rdx= param_i
    mov [r9+8*rcx], rdx ; ExtEnv [0][i]= param_i
    inc rcx
    jmp loop_2
end_loop_2:
mov qword [r9+8*rcx], SOB_NIL_ADDRESS; add magic to the end
mov [rbx], r9 ; updte the extEnv[0]-> vector that we created for the params

MAKE_CLOSURE(rax, rbx, Lcode_1)
 jmp Lcont_1
Lcode_1:
mov rdx, rsp ; rdx hold cur stack ptr ==> [rdx]= ret_adr etc... (i chose rdx because cons does'nt overide it)
mov r8, [rdx+8*2] ; r8= arg_count 
cmp r8, 1 ; compare arg_count to the amount we've expected
jl .no_fix_necessery
; else: we need to collect all exses args to a list
mov r9, SOB_NIL_ADDRESS ; r9 holds curr list
mov r10, r8
sub r10, 0 ; r10= lst size= num of opt args
mov r11, r8
dec r11 ; r11 =idx= n-1
.loop_create_lst:
  cmp r11, 0 
  jl .end_loop_create_lst ; end loop if idx<params.lst, which is when we get to the args that arent optional
  mov r13, rsp; r13=sp
  push SOB_NIL_ADDRESS; push magic
  push r9 ; push cdr
  push qword [rdx+8*(3+r11)] ; push arg_idx = car
  push qword 2; argcount= car, cdr
  push qword [rdx+8*1]; env
  call cons
  mov rsp, r13
  mov r9, rax ; r9 hold new lst
  mov r13, [r9+1]; r13=car
  mov r13, [r9+1+8]; r13=cdr
  dec r11 ; idx--
  jmp .loop_create_lst
.end_loop_create_lst:

; now r9 holds list of optional args
mov r13, [rdx+8*(3+r8-1)]; should be last opt arg=3
mov qword [rdx+8*(3+r8-1)], r9 ; set arg_n-1 to be optional
mov qword [rdx+8*2], 1
mov r9, r8  ; r9= n
inc r9  ;r9 = n+1 =3+n-2
shl r9, 3 ;r9= 8*(3+n-2)= idx of last place in stack
mov r11, 0
add r11, 2 
shl r11, 3 ; r11 = 8*(3+ params_len -1) = idx of last mandatory arg = the first element from stack that should be moved up
mov r13, [rdx+r11]; should be 1
; both r11, r9 will be decresed each time by 8
.loop_shift_stack:
  cmp r11, 0
  jl .end_loop_shift_stack
  mov rax, [rdx+r11] ; rax = cur element to move
  mov [rdx+r9], rax ; move to the top of the stack the cur element top down
  sub r9, 8
  sub r11, 8
  jmp .loop_shift_stack
.end_loop_shift_stack:
; now, rdx+r9 holds the last place on stack
add r9, 8
add r9, rdx
mov rsp, r9
.no_fix_necessery:

push rbp
mov rbp , rsp
;applic tp:
         push SOB_NIL_ADDRESS ; push magic
mov r15, rsp; r15 holds the stack adress of firsy thing to copy
push 0 ; push argcount
;next is proc:
;we know that env = [rbp + 8*2]
; we know that depth is env.length
; now we SHOULD allocate extenv with size env.length+1= depth+1
MALLOC rax, 8*(1+1) ; rax->extEnv
mov rbx, 0 ;i
mov rcx, 1 ;j
;following loop is to shift the env in extended env
loop_3:
    cmp rbx, 1
    jge end_loop_3
    mov rdx, [rbp + 8*2] ; rdx = env
    shl rbx, 3
    add rdx, rbx ; env[i] =-->[var, var,...var] 
    shr rbx, 3
    mov r8, [rdx] 
    mov [rax + 8*rcx], r8 ; extEnv[j]=env[i]
    inc rcx
    inc rbx
    jmp loop_3
end_loop_3:
 ;  rax holds ->extEnv
;n= [rbp+8*3]
mov rbx, rax ;rbx holds extEnv
; Allocate ExtEnv[0] to point to a vector where to store the parameters
mov r8, [rbp+8*3] ; r8= n
inc r8; +magic
shl r8, 3
MALLOC r9, r8 ; r9 holds the vector for the params with size 8*n +1 for magic
shr r8, 3
dec r8; - magic
mov rcx, 0 ;i=0
;following loop is to Copy the parameters off of the stack to the extended env:
loop_4:
    cmp rcx ,r8 ; i<n
    jge end_loop_4
    mov rdx, [rbp+8*(4+rcx)] ;  rdx= param_i
    mov [r9+8*rcx], rdx ; ExtEnv [0][i]= param_i
    inc rcx
    jmp loop_4
end_loop_4:
mov qword [r9+8*rcx], SOB_NIL_ADDRESS; add magic to the end
mov [rbx], r9 ; updte the extEnv[0]-> vector that we created for the params

MAKE_CLOSURE(rax, rbx, Lcode_2)
 jmp Lcont_2
Lcode_2:
push rbp
mov rbp , rsp
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * (0)]
mov rax, qword [rax + 8 * (0)]

leave
ret
Lcont_2:
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
push qword [rbp + 8 * 1] ; old ret addr
SHIFT_FRAME_1:
; r15= adress in stack of first to move up
mov r8, [r15]
mov qword r14, [rbp + 8*3] ; r14=n
add r14, 4
shl r14, 3
add r14, rbp ; r14 = rbp+ 8*(4+n) , which is the adress we should overide first
mov r8, [r14]
; we are moving top down:
;cur_frame_size = argcount(m)+ 1(magic)+4(old rbp, ret adr, env, argcount)
mov qword r13, [rsp+ 8*2] ;r13= argcount(m)
add r13, 5; r13 = cur_frame_size = num of element to push up 
.loop_of_shifts:
  cmp r13, 1
  jle .end_loop_of_shifts ; we finished
  mov qword r12, [r15]; r12 = element to move
  mov qword r8, [r14]; what we overide
  mov qword [r14], r12 ; move elemnt to top of stack
  sub r14, 8
  sub r15, 8
  dec r13
  jmp .loop_of_shifts
.end_loop_of_shifts:
  add r14, 8
  mov rsp, r14
  mov rbp, r12
  jmp qword [rax+9] ; jump to code ptr
 
leave
ret
Lcont_1:
mov [fvar_tbl+(8*46)], rax
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void

;applic:
         push SOB_NIL_ADDRESS ; push magic
push 0 ; push argcount
;next is proc:
mov rax, [fvar_tbl+ (8* 46)]
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
call qword [rax+9] ; call to code ptr
 mov r12, qword [rbp]
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8*rbx]; pop args
add rsp , 8 ; pop magic, which is sob_nil

	call write_sob_if_not_void

;applic:
         push SOB_NIL_ADDRESS ; push magic
;applic:
         push SOB_NIL_ADDRESS ; push magic
push 0 ; push argcount
;next is proc:
;we know that env = [rbp + 8*2]
; we know that depth is env.length
; now we SHOULD allocate extenv with size env.length+1= depth+1
MALLOC rax, 8*(1+0) ; rax->extEnv
mov rbx, 0 ;i
mov rcx, 1 ;j
;following loop is to shift the env in extended env
loop_5:
    cmp rbx, 0
    jge end_loop_5
    mov rdx, [rbp + 8*2] ; rdx = env
    shl rbx, 3
    add rdx, rbx ; env[i] =-->[var, var,...var] 
    shr rbx, 3
    mov r8, [rdx] 
    mov [rax + 8*rcx], r8 ; extEnv[j]=env[i]
    inc rcx
    inc rbx
    jmp loop_5
end_loop_5:
 ;  rax holds ->extEnv
;n= [rbp+8*3]
mov rbx, rax ;rbx holds extEnv
; Allocate ExtEnv[0] to point to a vector where to store the parameters
mov r8, [rbp+8*3] ; r8= n
inc r8; +magic
shl r8, 3
MALLOC r9, r8 ; r9 holds the vector for the params with size 8*n +1 for magic
shr r8, 3
dec r8; - magic
mov rcx, 0 ;i=0
;following loop is to Copy the parameters off of the stack to the extended env:
loop_6:
    cmp rcx ,r8 ; i<n
    jge end_loop_6
    mov rdx, [rbp+8*(4+rcx)] ;  rdx= param_i
    mov [r9+8*rcx], rdx ; ExtEnv [0][i]= param_i
    inc rcx
    jmp loop_6
end_loop_6:
mov qword [r9+8*rcx], SOB_NIL_ADDRESS; add magic to the end
mov [rbx], r9 ; updte the extEnv[0]-> vector that we created for the params

MAKE_CLOSURE(rax, rbx, Lcode_3)
 jmp Lcont_3
Lcode_3:
push rbp
mov rbp , rsp
mov rax, const_tbl+6

leave
ret
Lcont_3:
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
call qword [rax+9] ; call to code ptr
 mov r12, qword [rbp]
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8*rbx]; pop args
add rsp , 8 ; pop magic, which is sob_nil
push rax ; calculate arg, rax holds arg, and push it
push 1 ; push argcount
;next is proc:
mov rax, [fvar_tbl+ (8* 46)]
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
call qword [rax+9] ; call to code ptr
 mov r12, qword [rbp]
add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8*rbx]; pop args
add rsp , 8 ; pop magic, which is sob_nil

	call write_sob_if_not_void;;; Clean up the dummy frame, set the exit status to 0 ("success"), 
   ;;; and return from main
  pop rbp
  add rsp, 3*8
  mov rax, 0

  ret
  appError:
    pop rbp
    add rsp, 3*8
    mov rax, 1
  ret
boolean?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_BOOL
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

flonum?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_FLOAT
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

rational?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_RATIONAL
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

pair?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_PAIR
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

null?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_NIL
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

char?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_CHAR
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

string?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_STRING
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

symbol?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_SYMBOL
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

procedure?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_CLOSURE
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

div:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	mov dl, byte [rsi]
             cmp dl, T_FLOAT
	     jne .div_rat
             FLOAT_VAL rsi, rsi 
          movq xmm0, rsi
          FLOAT_VAL rdi, rdi 
          movq xmm1, rdi
	  divsd xmm0, xmm1
          movq rsi, xmm0
          MAKE_FLOAT(rax, rsi)
             jmp .op_return
          .div_rat:
             DENOMINATOR rcx, rsi
	  DENOMINATOR rdx, rdi
	  NUMERATOR rsi, rsi
	  NUMERATOR rdi, rdi
          MAKE_RATIONAL(rax, rdx, rdi)
         mov PVAR(1), rax
         pop rbp
         jmp mul
	  mov rax, rcx
	  mov rdi, rsi
          .gcd_loop:
     and rdi, rdi
     jz .end_gcd_loop
     cqo
     idiv rdi
     mov rax, rdi
     mov rdi, rdx
     jmp .gcd_loop	
     .end_gcd_loop:
	  mov rdi, rax
	  mov rax, rsi
	  cqo
	  idiv rdi
	  mov rsi, rax
	  mov rax, rcx
	  cqo
	  idiv rdi
	  mov rcx, rax
          cmp rcx, 0
          jge .make_rat
          imul rsi, -1
          imul rcx, -1
          .make_rat:
          MAKE_RATIONAL(rax, rsi, rcx)
          .op_return:
         pop rbp
         ret

mul:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	mov dl, byte [rsi]
             cmp dl, T_FLOAT
	     jne .mul_rat
             FLOAT_VAL rsi, rsi 
          movq xmm0, rsi
          FLOAT_VAL rdi, rdi 
          movq xmm1, rdi
	  mulsd xmm0, xmm1
          movq rsi, xmm0
          MAKE_FLOAT(rax, rsi)
             jmp .op_return
          .mul_rat:
             DENOMINATOR rcx, rsi
	  DENOMINATOR rdx, rdi
	  NUMERATOR rsi, rsi
	  NUMERATOR rdi, rdi
          imul rsi, rdi
	 imul rcx, rdx
	  mov rax, rcx
	  mov rdi, rsi
          .gcd_loop:
     and rdi, rdi
     jz .end_gcd_loop
     cqo
     idiv rdi
     mov rax, rdi
     mov rdi, rdx
     jmp .gcd_loop	
     .end_gcd_loop:
	  mov rdi, rax
	  mov rax, rsi
	  cqo
	  idiv rdi
	  mov rsi, rax
	  mov rax, rcx
	  cqo
	  idiv rdi
	  mov rcx, rax
          cmp rcx, 0
          jge .make_rat
          imul rsi, -1
          imul rcx, -1
          .make_rat:
          MAKE_RATIONAL(rax, rsi, rcx)
          .op_return:
         pop rbp
         ret

add:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	mov dl, byte [rsi]
             cmp dl, T_FLOAT
	     jne .add_rat
             FLOAT_VAL rsi, rsi 
          movq xmm0, rsi
          FLOAT_VAL rdi, rdi 
          movq xmm1, rdi
	  addsd xmm0, xmm1
          movq rsi, xmm0
          MAKE_FLOAT(rax, rsi)
             jmp .op_return
          .add_rat:
             DENOMINATOR rcx, rsi
	  DENOMINATOR rdx, rdi
	  NUMERATOR rsi, rsi
	  NUMERATOR rdi, rdi
          imul rsi, rdx
	 imul rdi, rcx
	 add rsi, rdi
	 imul rcx, rdx
	  mov rax, rcx
	  mov rdi, rsi
          .gcd_loop:
     and rdi, rdi
     jz .end_gcd_loop
     cqo
     idiv rdi
     mov rax, rdi
     mov rdi, rdx
     jmp .gcd_loop	
     .end_gcd_loop:
	  mov rdi, rax
	  mov rax, rsi
	  cqo
	  idiv rdi
	  mov rsi, rax
	  mov rax, rcx
	  cqo
	  idiv rdi
	  mov rcx, rax
          cmp rcx, 0
          jge .make_rat
          imul rsi, -1
          imul rcx, -1
          .make_rat:
          MAKE_RATIONAL(rax, rsi, rcx)
          .op_return:
         pop rbp
         ret

eq:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	mov dl, byte [rsi]
             cmp dl, T_FLOAT
	     jne .eq_rat
             FLOAT_VAL rsi, rsi
	 FLOAT_VAL rdi, rdi
	 cmp rsi, rdi
             jmp .op_return
          .eq_rat:
             NUMERATOR rcx, rsi
	 NUMERATOR rdx, rdi
	 cmp rcx, rdx
	 jne .false
	 DENOMINATOR rcx, rsi
	 DENOMINATOR rdx, rdi
	 cmp rcx, rdx
         .false:
          .op_return:
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

lt:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	mov dl, byte [rsi]
             cmp dl, T_FLOAT
	     jne .lt_rat
             FLOAT_VAL rsi, rsi
	 movq xmm0, rsi
	 FLOAT_VAL rdi, rdi
	 movq xmm1, rdi
	 cmpltpd xmm0, xmm1
         movq rsi, xmm0
         cmp rsi, 0
             jmp .op_return
          .lt_rat:
             DENOMINATOR rcx, rsi
	 DENOMINATOR rdx, rdi
	 NUMERATOR rsi, rsi
	 NUMERATOR rdi, rdi
	 imul rsi, rdx
	 imul rdi, rcx
	 cmp rsi, rdi
          .op_return:
      jl .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

string_length:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	STRING_LENGTH rsi, rsi
         MAKE_RATIONAL(rax, rsi, 1)
         pop rbp
         ret

string_ref:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	STRING_ELEMENTS rsi, rsi
         NUMERATOR rdi, rdi
         add rsi, rdi
         mov sil, byte [rsi]
         MAKE_CHAR(rax, sil)
         pop rbp
         ret

string_set:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	mov rdx, PVAR(2)
	STRING_ELEMENTS rsi, rsi
         NUMERATOR rdi, rdi
         add rsi, rdi
         CHAR_VAL rax, rdx
         mov byte [rsi], al
         mov rax, SOB_VOID_ADDRESS
         pop rbp
         ret

make_string:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	NUMERATOR rsi, rsi
         CHAR_VAL rdi, rdi
         and rdi, 255
         MAKE_STRING rax, rsi, dil
         pop rbp
         ret

symbol_to_string:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	SYMBOL_VAL rsi, rsi
	 STRING_LENGTH rcx, rsi
	 STRING_ELEMENTS rdi, rsi
	 push rcx
	 push rdi
	 mov dil, byte [rdi]
	 MAKE_CHAR(rax, dil)
	 push rax
	 MAKE_RATIONAL(rax, rcx, 1)
	 push rax
	 push 2
	 push SOB_NIL_ADDRESS
	 call make_string
	 add rsp, 4*8
	 STRING_ELEMENTS rsi, rax   
	 pop rdi
	 pop rcx
	 cmp rcx, 0
	 je .end
         .loop:
	 lea r8, [rdi+rcx]
	 lea r9, [rsi+rcx]
	 mov bl, byte [r8]
	 mov byte [r9], bl
	 loop .loop
         .end:
         pop rbp
         ret

eq?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	cmp rsi, rdi
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

char_to_integer:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	CHAR_VAL rsi, rsi
	 and rsi, 255
	 MAKE_RATIONAL(rax, rsi, 1)
         pop rbp
         ret

integer_to_char:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	NUMERATOR rsi, rsi
	 and rsi, 255
	 MAKE_CHAR(rax, sil)
         pop rbp
         ret

exact_to_inexact:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	DENOMINATOR rdi, rsi
	 NUMERATOR rsi, rsi 
	 cvtsi2sd xmm0, rsi
	 cvtsi2sd xmm1, rdi
	 divsd xmm0, xmm1
	 movq rsi, xmm0
	 MAKE_FLOAT(rax, rsi)
         pop rbp
         ret

numerator:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	NUMERATOR rsi, rsi
	 mov rdi, 1
	 MAKE_RATIONAL(rax, rsi, rdi)
         pop rbp
         ret

denominator:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	DENOMINATOR rsi, rsi
	 mov rdi, 1
	 MAKE_RATIONAL(rax, rsi, rdi)
         pop rbp
         ret

gcd:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	xor rdx, rdx
	 NUMERATOR rax, rsi
         NUMERATOR rdi, rdi
         .gcd_loop:
     and rdi, rdi
     jz .end_gcd_loop
     cqo
     idiv rdi
     mov rax, rdi
     mov rdi, rdx
     jmp .gcd_loop	
     .end_gcd_loop:
	 mov rdx, rax
         cmp rdx, 0
         jge .make_result
         neg rdx
         .make_result:
         MAKE_RATIONAL(rax, rdx, 1)
         pop rbp
         ret

cons:
  push rbp
  mov rbp , rsp
  mov qword rbx, [rbp+8*4]  ;rax->arg_0 = obj1
  mov qword rcx, [rbp+8*5]  ;rbx->arg_1 = obj2
  MALLOC rax, 17  ;rax->empty list= [1byte type_tag , 8bytes car ptr , 8bytes cdr ptr]
  mov byte [rax], T_PAIR  ; set TypeTag = T_PAIR
  mov qword [rax+1], rbx  ; set car-> obj1
  mov qword [rax+9], rcx  ; set cdr-> obj2
  leave
  ret

apply:
  push rbp
  mov rbp , rsp
  
  ;anyway-> push magic
  push SOB_NIL_ADDRESS ; push magic

  mov rbx, [rbp+8*4] ; rbx holds the func we wanna apply
  mov rcx,  [rbp+8*3] ;rcx holds argCount(n)
  cmp rcx, 1 ; 
  je .no_arg
  
  ;else-> we have at least the list at the end
  ;push list args
  mov r10, [rbp+8*(4+rcx-1)] ; r10->lst
  mov qword r11, 0; r11= size of list
  cmp r10, SOB_NIL_ADDRESS; if list is empty
  je .end_loop_of_pushes
  ; else-> lst !=nill -> so we need to reverse it and than push each var in it
  ;reverse:
  ;first push by order each var in lst to stack:
  mov qword r12, [r10+1] ;r12->car
  mov qword r13, [r10+1+8] ;r13->cdr
  .loop_of_pushes:
    inc r11
    push qword r12
    cmp r13, SOB_NIL_ADDRESS; if cdr is empty
    je .end_loop_of_pushes
    mov qword r12, [r13+1] ;r12->car
    mov qword r13, [r13+1+8] ;r13->cdr
    jmp .loop_of_pushes
  .end_loop_of_pushes:
  ;now: r11= lst size , stack contains all vars.

  shl r11, 3 ; r11 = 8* lst_size
  MALLOC rax, r11 ; allocate size for lst in heap
  shr r11, 3 ; reset r11 =lst_size
  mov r12, 0 ; idx
  .loop_copy_lst_in_reverse:
    cmp r12, r11 
    jge .end_loop_copy_lst_in_reverse ;jump to end if idx >= lst size
    pop qword [rax +8*r12] ; pop arg from stack and put it in lst[i]
    inc r12
    jmp .loop_copy_lst_in_reverse
  .end_loop_copy_lst_in_reverse:
  ; now rax->reversed lst

  ; now push vars of reversed lst:
  mov r12, 0 ; idx
  .loop_push_reveres_lst:
    cmp r12, r11 
    jge .end_loop_push_reveres_lst ;jump to end if idx >= lst size
    push qword [rax +8*r12] ; pop arg from stack and put it in lst[i]
    inc r12
    jmp .loop_push_reveres_lst
  .end_loop_push_reveres_lst:


  cmp rcx, 2
  je .list_only
  ;else-> we have opt args
  .opt_args:
    mov r12, 1 ; idx
    mov r13, rcx
    sub r13, 2    ; r13= idx of arg_n-2
    .loop_push_opts:
      cmp r12, r13 
      jg .end_loop_push_opts ;jump to end if idx > num of opt args
      push qword [rbp+8*(4+r13)] ; push arg from the end
      dec r13
      jmp .loop_push_opts
    .end_loop_push_opts:

    ;all arg on heap:

    sub rcx, 2
    add rcx, r11  ;rcx = argCount(n) -2 + lstSize
    push rcx  ;push n
    jmp .end_apply

  .list_only:
    push r11 ;push n
    jmp .end_apply
  .no_arg:
    push 0

  .end_apply:
    push qword [rbp+8*2] ; push env
    call [rbx+9]
    add rsp , 8*1 ; pop env
    pop rbx ; pop arg count
    lea rsp , [rsp + 8*rbx]; pop args
    add rsp , 8 ; pop magic, which is sob_nil

  leave
  ret


car:
  push rbp
  mov rbp , rsp
  ;arg_0= ptr to a list
  ;list is : 1byte type_tag , 8bytes car ptr , 8bytes cdr ptr
  mov qword rax, [rbp+8*4]; rax->lst
  mov qword rax, [rax+1]
  leave
  ret

cdr:
  push rbp
  mov rbp , rsp
  ;arg_0= ptr to a list
  ;list is : 1byte type_tag , 8bytes car ptr , 8bytes cdr ptr
  mov qword rax, [rbp+8*4]; rax->lst
  mov qword rax, [rax+1+8]; rax->cdr
  leave
  ret

set_car:
  push rbp
  mov rbp , rsp
  mov qword rax, [rbp+8*4]  ;rax->arg_0 = ->list= [1byte type_tag , 8bytes car ptr , 8bytes cdr ptr]
  mov qword rbx, [rbp+8*5]  ;rbx->arg_1 = obj
  mov qword [rax+1], rbx; car->obj
  mov qword rax, SOB_VOID_ADDRESS ; set is void
  leave
  ret

set_cdr:
  push rbp
  mov rbp , rsp
  mov qword rax, [rbp+8*4]  ;rax->arg_0 = ->list= [1byte type_tag , 8bytes car ptr , 8bytes cdr ptr]
  mov qword rbx, [rbp+8*5]  ;rbx->arg_1 = obj
  mov qword [rax+1+8], rbx; car->obj
  mov qword rax, SOB_VOID_ADDRESS ; set is void
  leave
  ret