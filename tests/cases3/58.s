;;; All the macros and the scheme-object printing procedure
;;; are defined in compiler.s
%include "compiler.s"
section .bss
;;; This pointer is used to manage allocations on our heap.
malloc_pointer:
    resq 1
;;; here we REServe enough Quad-words (64-bit "cells") for the free variables
;;; each free variable has 8 bytes reserved for a 64-bit pointer to its value
fvar_tbl:
    resq 48
section .data
const_tbl:
db T_VOID
db T_NIL
db T_BOOL ,0
db T_BOOL ,1
MAKE_LITERAL_STRING "whatever"
MAKE_LITERAL_SYMBOL(const_tbl+6)
MAKE_LITERAL_CHAR(0)
MAKE_LITERAL_RATIONAL(1, 1)
MAKE_LITERAL_RATIONAL(0, 1)
MAKE_LITERAL_RATIONAL(-1, 1)
MAKE_LITERAL_RATIONAL(88, 1)
;;; These macro definitions are required for the primitive
;;; definitions in the epilogue to work properly
%define SOB_VOID_ADDRESS const_tbl+0
%define SOB_NIL_ADDRESS const_tbl+1
%define SOB_FALSE_ADDRESS const_tbl+2
%define SOB_TRUE_ADDRESS const_tbl+4
global main
section .text
main:
    ;; set up the heap
    mov rdi, GB(2)
    call malloc
    mov [malloc_pointer], rax
    ;; Set up the dummy activation frame
    ;; The dummy return address is T_UNDEFINED
    ;; (which a is a macro for 0) so that returning
    ;; from the top level (which SHOULD NOT HAPPEN
    ;; AND IS A BUG) will cause a segfault.
    push 0                ; argument count
    push SOB_NIL_ADDRESS  ; lexical environment address
    push T_UNDEFINED      ; return address
    push rbp                    
    mov rbp, rsp                ; anchor the dummy frame
    ;; Set up the primitive stdlib fvars:
    ;; Since the primtive procedures are defined in assembly,
    ;; they are not generated by scheme (define ...) expressions.
    ;; This is where we simulate the missing (define ...) expressions
    ;; for all the primitive procedures.
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, boolean?)
mov [fvar_tbl+ (0*8)], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, flonum?)
mov [fvar_tbl+ (1*8)], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, rational?)
mov [fvar_tbl+ (2*8)], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, pair?)
mov [fvar_tbl+ (3*8)], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, null?)
mov [fvar_tbl+ (4*8)], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, char?)
mov [fvar_tbl+ (5*8)], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, string?)
mov [fvar_tbl+ (6*8)], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, procedure?)
mov [fvar_tbl+ (7*8)], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, symbol?)
mov [fvar_tbl+ (8*8)], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, string_length)
mov [fvar_tbl+ (9*8)], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, string_ref)
mov [fvar_tbl+ (10*8)], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, string_set)
mov [fvar_tbl+ (11*8)], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, make_string)
mov [fvar_tbl+ (12*8)], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, symbol_to_string)
mov [fvar_tbl+ (13*8)], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, char_to_integer)
mov [fvar_tbl+ (14*8)], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, integer_to_char)
mov [fvar_tbl+ (15*8)], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, exact_to_inexact)
mov [fvar_tbl+ (16*8)], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, eq?)
mov [fvar_tbl+ (17*8)], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, add)
mov [fvar_tbl+ (18*8)], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, mul)
mov [fvar_tbl+ (19*8)], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, div)
mov [fvar_tbl+ (20*8)], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, eq)
mov [fvar_tbl+ (21*8)], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, lt)
mov [fvar_tbl+ (22*8)], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, numerator)
mov [fvar_tbl+ (23*8)], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, denominator)
mov [fvar_tbl+ (24*8)], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, gcd)
mov [fvar_tbl+ (25*8)], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, apply)
mov [fvar_tbl+ (27*8)], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, car)
mov [fvar_tbl+ (28*8)], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, cdr)
mov [fvar_tbl+ (29*8)], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, set_car)
mov [fvar_tbl+ (42*8)], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, set_cdr)
mov [fvar_tbl+ (43*8)], rax
MAKE_CLOSURE(rax, SOB_NIL_ADDRESS, cons)
mov [fvar_tbl+ (30*8)], rax
user_code_fragment:
;;; The code you compiled will be added here.
;;; It will be executed immediately after the closures for 
;;; the primitive procedures are set up.
;applic:
         push SOB_NIL_ADDRESS ; push magic
mov rax, [fvar_tbl+ (8* 27)]
push rax ; calculate arg, rax holds arg, and push it
mov rax, [fvar_tbl+ (8* 30)]
push rax ; calculate arg, rax holds arg, and push it
mov rax, [fvar_tbl+ (8* 29)]
push rax ; calculate arg, rax holds arg, and push it
mov rax, [fvar_tbl+ (8* 28)]
push rax ; calculate arg, rax holds arg, and push it
mov rax, [fvar_tbl+ (8* 4)]
push rax ; calculate arg, rax holds arg, and push it
push 5 ; push argcount
;next is proc:
;we know that env = [rbp + 8*2]
; we know that depth is env.length
; now we SHOULD allocate extenv with size env.length+1= depth+1
MALLOC rax, 8*(1+0) ; rax->extEnv
mov rbx, 0 ;i
mov rcx, 1 ;j
;following loop is to shift the env in extended env
loop_1:
    cmp rbx, 0
    jge end_loop_1
    mov rdx, [rbp + 8*2] ; rdx = env
    shl rbx, 3
    add rdx, rbx ; env[i] =-->[var, var,...var] 
    shr rbx, 3
    mov r8, [rdx] 
    mov [rax + 8*rcx], r8 ; extEnv[j]=env[i]
    inc rcx
    inc rbx
    jmp loop_1
end_loop_1:
 ;  rax holds ->extEnv
;n= [rbp+8*3]
mov rbx, rax ;rbx holds extEnv
; Allocate ExtEnv[0] to point to a vector where to store the parameters
mov r8, [rbp+8*3] ; r8= n
inc r8; +magic
shl r8, 3
MALLOC r9, r8 ; r9 holds the vector for the params with size 8*n +1 for magic
shr r8, 3
dec r8; - magic
mov rcx, 0 ;i=0
;following loop is to Copy the parameters off of the stack to the extended env:
loop_2:
    cmp rcx ,r8 ; i<n
    jge end_loop_2
    mov rdx, [rbp+8*(4+rcx)] ;  rdx= param_i
    mov [r9+8*rcx], rdx ; ExtEnv [0][i]= param_i
    inc rcx
    jmp loop_2
end_loop_2:
mov qword [r9+8*rcx], SOB_NIL_ADDRESS; add magic to the end
mov [rbx], r9 ; updte the extEnv[0]-> vector that we created for the params

MAKE_CLOSURE(rax, rbx, Lcode_1)
 jmp Lcont_1
Lcode_1:
push rbp
mov rbp , rsp
;applic tp:
push SOB_NIL_ADDRESS ; push magic
mov rax, const_tbl+23
push rax ; calculate arg, rax holds arg, and push it
mov rax, const_tbl+23
push rax ; calculate arg, rax holds arg, and push it
push 2 ; push argcount
;next is proc:
;we know that env = [rbp + 8*2]
; we know that depth is env.length
; now we SHOULD allocate extenv with size env.length+1= depth+1
MALLOC rax, 8*(1+1) ; rax->extEnv
mov rbx, 0 ;i
mov rcx, 1 ;j
;following loop is to shift the env in extended env
loop_3:
    cmp rbx, 1
    jge end_loop_3
    mov rdx, [rbp + 8*2] ; rdx = env
    shl rbx, 3
    add rdx, rbx ; env[i] =-->[var, var,...var] 
    shr rbx, 3
    mov r8, [rdx] 
    mov [rax + 8*rcx], r8 ; extEnv[j]=env[i]
    inc rcx
    inc rbx
    jmp loop_3
end_loop_3:
 ;  rax holds ->extEnv
;n= [rbp+8*3]
mov rbx, rax ;rbx holds extEnv
; Allocate ExtEnv[0] to point to a vector where to store the parameters
mov r8, [rbp+8*3] ; r8= n
inc r8; +magic
shl r8, 3
MALLOC r9, r8 ; r9 holds the vector for the params with size 8*n +1 for magic
shr r8, 3
dec r8; - magic
mov rcx, 0 ;i=0
;following loop is to Copy the parameters off of the stack to the extended env:
loop_4:
    cmp rcx ,r8 ; i<n
    jge end_loop_4
    mov rdx, [rbp+8*(4+rcx)] ;  rdx= param_i
    mov [r9+8*rcx], rdx ; ExtEnv [0][i]= param_i
    inc rcx
    jmp loop_4
end_loop_4:
mov qword [r9+8*rcx], SOB_NIL_ADDRESS; add magic to the end
mov [rbx], r9 ; updte the extEnv[0]-> vector that we created for the params

MAKE_CLOSURE(rax, rbx, Lcode_2)
 jmp Lcont_2
Lcode_2:
push rbp
mov rbp , rsp
MALLOC rax, 8
mov rbx, qword[rbp+ 8*(4+0)]
mov [rax], rbx
mov qword [rbp + 8 * (4 + (0))],rax
mov rax, SOB_VOID_ADDRESS
MALLOC rax, 8
mov rbx, qword[rbp+ 8*(4+1)]
mov [rax], rbx
mov qword [rbp + 8 * (4 + (1))],rax
mov rax, SOB_VOID_ADDRESS
;we know that env = [rbp + 8*2]
; we know that depth is env.length
; now we SHOULD allocate extenv with size env.length+1= depth+1
MALLOC rax, 8*(1+2) ; rax->extEnv
mov rbx, 0 ;i
mov rcx, 1 ;j
;following loop is to shift the env in extended env
loop_5:
    cmp rbx, 2
    jge end_loop_5
    mov rdx, [rbp + 8*2] ; rdx = env
    shl rbx, 3
    add rdx, rbx ; env[i] =-->[var, var,...var] 
    shr rbx, 3
    mov r8, [rdx] 
    mov [rax + 8*rcx], r8 ; extEnv[j]=env[i]
    inc rcx
    inc rbx
    jmp loop_5
end_loop_5:
 ;  rax holds ->extEnv
;n= [rbp+8*3]
mov rbx, rax ;rbx holds extEnv
; Allocate ExtEnv[0] to point to a vector where to store the parameters
mov r8, [rbp+8*3] ; r8= n
inc r8; +magic
shl r8, 3
MALLOC r9, r8 ; r9 holds the vector for the params with size 8*n +1 for magic
shr r8, 3
dec r8; - magic
mov rcx, 0 ;i=0
;following loop is to Copy the parameters off of the stack to the extended env:
loop_6:
    cmp rcx ,r8 ; i<n
    jge end_loop_6
    mov rdx, [rbp+8*(4+rcx)] ;  rdx= param_i
    mov [r9+8*rcx], rdx ; ExtEnv [0][i]= param_i
    inc rcx
    jmp loop_6
end_loop_6:
mov qword [r9+8*rcx], SOB_NIL_ADDRESS; add magic to the end
mov [rbx], r9 ; updte the extEnv[0]-> vector that we created for the params

MAKE_CLOSURE(rax, rbx, Lcode_3)
 jmp Lcont_3
Lcode_3:
push rbp
mov rbp , rsp
;applic:
         push SOB_NIL_ADDRESS ; push magic
;applic:
         push SOB_NIL_ADDRESS ; push magic
mov rax, qword [rbp + 8 *(4 + 1)]
push rax ; calculate arg, rax holds arg, and push it
push 1 ; push argcount
;next is proc:
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * (1)]
mov rax, qword [rax + 8 * (1)]
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
call qword [rax+9] ; call to code ptr
 add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8*rbx]; pop args
add rsp , 8 ; pop magic, which is sob_nil
push rax ; calculate arg, rax holds arg, and push it
push 1 ; push argcount
;next is proc:
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * (1)]
mov rax, qword [rax + 8 * (0)]
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
call qword [rax+9] ; call to code ptr
 add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8*rbx]; pop args
add rsp , 8 ; pop magic, which is sob_nil
cmp rax, SOB_FALSE_ADDRESS
je Lelse_1
mov rax, const_tbl+1
jmp Lexit_1
Lelse_1:
;applic tp:
push SOB_NIL_ADDRESS ; push magic
;applic:
         push SOB_NIL_ADDRESS ; push magic
;applic:
         push SOB_NIL_ADDRESS ; push magic
mov rax, qword [rbp + 8 *(4 + 1)]
push rax ; calculate arg, rax holds arg, and push it
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * (1)]
mov rax, qword [rax + 8 * (2)]
push rax ; calculate arg, rax holds arg, and push it
push 2 ; push argcount
;next is proc:
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * (0)]
mov rax, qword [rax + 8 * (1)]
mov rax, qword [rax]
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
call qword [rax+9] ; call to code ptr
 add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8*rbx]; pop args
add rsp , 8 ; pop magic, which is sob_nil
push rax ; calculate arg, rax holds arg, and push it
mov rax, qword [rbp + 8 *(4 + 0)]
push rax ; calculate arg, rax holds arg, and push it
push 2 ; push argcount
;next is proc:
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * (0)]
mov rax, qword [rax + 8 * (0)]
mov rax, qword [rax]
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
call qword [rax+9] ; call to code ptr
 add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8*rbx]; pop args
add rsp , 8 ; pop magic, which is sob_nil
push rax ; calculate arg, rax holds arg, and push it
;applic:
         push SOB_NIL_ADDRESS ; push magic
;applic:
         push SOB_NIL_ADDRESS ; push magic
mov rax, qword [rbp + 8 *(4 + 1)]
push rax ; calculate arg, rax holds arg, and push it
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * (1)]
mov rax, qword [rax + 8 * (1)]
push rax ; calculate arg, rax holds arg, and push it
push 2 ; push argcount
;next is proc:
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * (0)]
mov rax, qword [rax + 8 * (1)]
mov rax, qword [rax]
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
call qword [rax+9] ; call to code ptr
 add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8*rbx]; pop args
add rsp , 8 ; pop magic, which is sob_nil
push rax ; calculate arg, rax holds arg, and push it
mov rax, qword [rbp + 8 *(4 + 0)]
push rax ; calculate arg, rax holds arg, and push it
push 2 ; push argcount
;next is proc:
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * (1)]
mov rax, qword [rax + 8 * (4)]
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
call qword [rax+9] ; call to code ptr
 add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8*rbx]; pop args
add rsp , 8 ; pop magic, which is sob_nil
push rax ; calculate arg, rax holds arg, and push it
push 2 ; push argcount
;next is proc:
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * (1)]
mov rax, qword [rax + 8 * (3)]
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
push qword [rbp + 8 * 1] ; old ret addr
mov r11, qword [rbp]
SHIFT_FRAME_2:
mov r15, rbp
sub r15, 8 ; r15= adress in stack of first to move up
mov qword r14, [rbp + 8*3] ; r14=n
add r14, 4
shl r14, 3
add r14, rbp ; r14 = rbp+ 8*(4+n) , which is the adress we should overide first
; we are moving top down:
.loop_of_shifts:
  cmp r15, rsp
  jl .end_loop_of_shifts ; we finished
  mov qword r12, [r15]; r12 = element to move
  mov qword [r14], r12 ; move elemnt to top of stack
  sub r14, 8
  sub r15, 8
  jmp .loop_of_shifts
.end_loop_of_shifts:
  add r14, 8
  mov rsp, r14
  mov rbp, r11
  jmp qword [rax+9] ; jump to code ptr
 Lexit_1:

leave
ret
Lcont_3:
push rax
mov rax, qword [rbp + 8 *(4 + 0)]
pop qword [rax]
mov rax, SOB_VOID_ADDRESS
;we know that env = [rbp + 8*2]
; we know that depth is env.length
; now we SHOULD allocate extenv with size env.length+1= depth+1
MALLOC rax, 8*(1+2) ; rax->extEnv
mov rbx, 0 ;i
mov rcx, 1 ;j
;following loop is to shift the env in extended env
loop_7:
    cmp rbx, 2
    jge end_loop_7
    mov rdx, [rbp + 8*2] ; rdx = env
    shl rbx, 3
    add rdx, rbx ; env[i] =-->[var, var,...var] 
    shr rbx, 3
    mov r8, [rdx] 
    mov [rax + 8*rcx], r8 ; extEnv[j]=env[i]
    inc rcx
    inc rbx
    jmp loop_7
end_loop_7:
 ;  rax holds ->extEnv
;n= [rbp+8*3]
mov rbx, rax ;rbx holds extEnv
; Allocate ExtEnv[0] to point to a vector where to store the parameters
mov r8, [rbp+8*3] ; r8= n
inc r8; +magic
shl r8, 3
MALLOC r9, r8 ; r9 holds the vector for the params with size 8*n +1 for magic
shr r8, 3
dec r8; - magic
mov rcx, 0 ;i=0
;following loop is to Copy the parameters off of the stack to the extended env:
loop_8:
    cmp rcx ,r8 ; i<n
    jge end_loop_8
    mov rdx, [rbp+8*(4+rcx)] ;  rdx= param_i
    mov [r9+8*rcx], rdx ; ExtEnv [0][i]= param_i
    inc rcx
    jmp loop_8
end_loop_8:
mov qword [r9+8*rcx], SOB_NIL_ADDRESS; add magic to the end
mov [rbx], r9 ; updte the extEnv[0]-> vector that we created for the params

MAKE_CLOSURE(rax, rbx, Lcode_4)
 jmp Lcont_4
Lcode_4:
push rbp
mov rbp , rsp
;applic:
         push SOB_NIL_ADDRESS ; push magic
mov rax, qword [rbp + 8 *(4 + 1)]
push rax ; calculate arg, rax holds arg, and push it
push 1 ; push argcount
;next is proc:
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * (1)]
mov rax, qword [rax + 8 * (0)]
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
call qword [rax+9] ; call to code ptr
 add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8*rbx]; pop args
add rsp , 8 ; pop magic, which is sob_nil
cmp rax, SOB_FALSE_ADDRESS
je Lelse_2
mov rax, const_tbl+1
jmp Lexit_2
Lelse_2:
;applic tp:
push SOB_NIL_ADDRESS ; push magic
;applic:
         push SOB_NIL_ADDRESS ; push magic
;applic:
         push SOB_NIL_ADDRESS ; push magic
mov rax, qword [rbp + 8 *(4 + 1)]
push rax ; calculate arg, rax holds arg, and push it
push 1 ; push argcount
;next is proc:
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * (1)]
mov rax, qword [rax + 8 * (2)]
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
call qword [rax+9] ; call to code ptr
 add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8*rbx]; pop args
add rsp , 8 ; pop magic, which is sob_nil
push rax ; calculate arg, rax holds arg, and push it
mov rax, qword [rbp + 8 *(4 + 0)]
push rax ; calculate arg, rax holds arg, and push it
push 2 ; push argcount
;next is proc:
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * (0)]
mov rax, qword [rax + 8 * (1)]
mov rax, qword [rax]
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
call qword [rax+9] ; call to code ptr
 add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8*rbx]; pop args
add rsp , 8 ; pop magic, which is sob_nil
push rax ; calculate arg, rax holds arg, and push it
;applic:
         push SOB_NIL_ADDRESS ; push magic
;applic:
         push SOB_NIL_ADDRESS ; push magic
mov rax, qword [rbp + 8 *(4 + 1)]
push rax ; calculate arg, rax holds arg, and push it
push 1 ; push argcount
;next is proc:
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * (1)]
mov rax, qword [rax + 8 * (1)]
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
call qword [rax+9] ; call to code ptr
 add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8*rbx]; pop args
add rsp , 8 ; pop magic, which is sob_nil
push rax ; calculate arg, rax holds arg, and push it
push 1 ; push argcount
;next is proc:
mov rax, qword [rbp + 8 *(4 + 0)]
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
call qword [rax+9] ; call to code ptr
 add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8*rbx]; pop args
add rsp , 8 ; pop magic, which is sob_nil
push rax ; calculate arg, rax holds arg, and push it
push 2 ; push argcount
;next is proc:
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * (1)]
mov rax, qword [rax + 8 * (3)]
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
push qword [rbp + 8 * 1] ; old ret addr
mov r11, qword [rbp]
SHIFT_FRAME_3:
mov r15, rbp
sub r15, 8 ; r15= adress in stack of first to move up
mov qword r14, [rbp + 8*3] ; r14=n
add r14, 4
shl r14, 3
add r14, rbp ; r14 = rbp+ 8*(4+n) , which is the adress we should overide first
; we are moving top down:
.loop_of_shifts:
  cmp r15, rsp
  jl .end_loop_of_shifts ; we finished
  mov qword r12, [r15]; r12 = element to move
  mov qword [r14], r12 ; move elemnt to top of stack
  sub r14, 8
  sub r15, 8
  jmp .loop_of_shifts
.end_loop_of_shifts:
  add r14, 8
  mov rsp, r14
  mov rbp, r11
  jmp qword [rax+9] ; jump to code ptr
 Lexit_2:

leave
ret
Lcont_4:
push rax
mov rax, qword [rbp + 8 *(4 + 1)]
pop qword [rax]
mov rax, SOB_VOID_ADDRESS
;we know that env = [rbp + 8*2]
; we know that depth is env.length
; now we SHOULD allocate extenv with size env.length+1= depth+1
MALLOC rax, 8*(1+2) ; rax->extEnv
mov rbx, 0 ;i
mov rcx, 1 ;j
;following loop is to shift the env in extended env
loop_9:
    cmp rbx, 2
    jge end_loop_9
    mov rdx, [rbp + 8*2] ; rdx = env
    shl rbx, 3
    add rdx, rbx ; env[i] =-->[var, var,...var] 
    shr rbx, 3
    mov r8, [rdx] 
    mov [rax + 8*rcx], r8 ; extEnv[j]=env[i]
    inc rcx
    inc rbx
    jmp loop_9
end_loop_9:
 ;  rax holds ->extEnv
;n= [rbp+8*3]
mov rbx, rax ;rbx holds extEnv
; Allocate ExtEnv[0] to point to a vector where to store the parameters
mov r8, [rbp+8*3] ; r8= n
inc r8; +magic
shl r8, 3
MALLOC r9, r8 ; r9 holds the vector for the params with size 8*n +1 for magic
shr r8, 3
dec r8; - magic
mov rcx, 0 ;i=0
;following loop is to Copy the parameters off of the stack to the extended env:
loop_10:
    cmp rcx ,r8 ; i<n
    jge end_loop_10
    mov rdx, [rbp+8*(4+rcx)] ;  rdx= param_i
    mov [r9+8*rcx], rdx ; ExtEnv [0][i]= param_i
    inc rcx
    jmp loop_10
end_loop_10:
mov qword [r9+8*rcx], SOB_NIL_ADDRESS; add magic to the end
mov [rbx], r9 ; updte the extEnv[0]-> vector that we created for the params

MAKE_CLOSURE(rax, rbx, Lcode_5)
 jmp Lcont_5
Lcode_5:
mov rdx, rsp ; rdx hold cur stack ptr ==> [rdx]= ret_adr etc... (i chose rdx because cons does'nt overide it)
mov r8, [rdx+8*2] ; r8= arg_count 
cmp r8, 2 ; compare arg_count to the amount we've expected
jl .no_fix_necessery
; else: we need to collect all exses args to a list
mov r9, SOB_NIL_ADDRESS ; r9 holds curr list
mov r10, r8
sub r10, 1 ; r10= lst size= num of opt args
mov r11, r8
dec r11 ; r11 =idx= n-1
.loop_create_lst:
  cmp r11, 1 
  jl .end_loop_create_lst ; end loop if idx<params.lst, which is when we get to the args that arent optional
  mov r13, rsp; r13=sp
  push SOB_NIL_ADDRESS; push magic
  push r9 ; push cdr
  push qword [rdx+8*(3+r11)] ; push arg_idx = car
  push qword 2; argcount= car, cdr
  push qword [rdx+8*1]; env
  call cons
  mov rsp, r13
  mov r9, rax ; r9 hold new lst
  mov r13, [r9+1]; r13=car
  mov r13, [r9+1+8]; r13=cdr
  dec r11 ; idx--
  jmp .loop_create_lst
.end_loop_create_lst:

; now r9 holds list of optional args
mov r13, [rdx+8*(3+r8-1)]; should be last opt arg=3
mov qword [rdx+8*(3+r8-1)], r9 ; set arg_n-1 to be optional
mov qword [rdx+8*2], 2
mov r9, r8  ; r9= n
inc r9  ;r9 = n+1 =3+n-2
shl r9, 3 ;r9= 8*(3+n-2)= idx of last place in stack
mov r11, 1
add r11, 2 
shl r11, 3 ; r11 = 8*(3+ params_len -1) = idx of last mandatory arg = the first element from stack that should be moved up
mov r13, [rdx+r11]; should be 1
; both r11, r9 will be decresed each time by 8
.loop_shift_stack:
  cmp r11, 0
  jl .end_loop_shift_stack
  mov rax, [rdx+r11] ; rax = cur element to move
  mov [rdx+r9], rax ; move to the top of the stack the cur element top down
  sub r9, 8
  sub r11, 8
  jmp .loop_shift_stack
.end_loop_shift_stack:
; now, rdx+r9 holds the last place on stack
add r9, 8
add r9, rdx
mov rsp, r9
.no_fix_necessery:

push rbp
mov rbp , rsp
;applic tp:
push SOB_NIL_ADDRESS ; push magic
mov rax, qword [rbp + 8 *(4 + 1)]
push rax ; calculate arg, rax holds arg, and push it
mov rax, qword [rbp + 8 *(4 + 0)]
push rax ; calculate arg, rax holds arg, and push it
push 2 ; push argcount
;next is proc:
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * (0)]
mov rax, qword [rax + 8 * (0)]
mov rax, qword [rax]
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
push qword [rbp + 8 * 1] ; old ret addr
mov r11, qword [rbp]
SHIFT_FRAME_4:
mov r15, rbp
sub r15, 8 ; r15= adress in stack of first to move up
mov qword r14, [rbp + 8*3] ; r14=n
add r14, 4
shl r14, 3
add r14, rbp ; r14 = rbp+ 8*(4+n) , which is the adress we should overide first
; we are moving top down:
.loop_of_shifts:
  cmp r15, rsp
  jl .end_loop_of_shifts ; we finished
  mov qword r12, [r15]; r12 = element to move
  mov qword [r14], r12 ; move elemnt to top of stack
  sub r14, 8
  sub r15, 8
  jmp .loop_of_shifts
.end_loop_of_shifts:
  add r14, 8
  mov rsp, r14
  mov rbp, r11
  jmp qword [rax+9] ; jump to code ptr
 
leave
ret
Lcont_5:

leave
ret
Lcont_2:
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
push qword [rbp + 8 * 1] ; old ret addr
mov r11, qword [rbp]
SHIFT_FRAME_1:
mov r15, rbp
sub r15, 8 ; r15= adress in stack of first to move up
mov qword r14, [rbp + 8*3] ; r14=n
add r14, 4
shl r14, 3
add r14, rbp ; r14 = rbp+ 8*(4+n) , which is the adress we should overide first
; we are moving top down:
.loop_of_shifts:
  cmp r15, rsp
  jl .end_loop_of_shifts ; we finished
  mov qword r12, [r15]; r12 = element to move
  mov qword [r14], r12 ; move elemnt to top of stack
  sub r14, 8
  sub r15, 8
  jmp .loop_of_shifts
.end_loop_of_shifts:
  add r14, 8
  mov rsp, r14
  mov rbp, r11
  jmp qword [rax+9] ; jump to code ptr
 
leave
ret
Lcont_1:
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
call qword [rax+9] ; call to code ptr
 add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8*rbx]; pop args
add rsp , 8 ; pop magic, which is sob_nil
mov [fvar_tbl+(8*39)], rax
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void

;applic:
         push SOB_NIL_ADDRESS ; push magic
mov rax, [fvar_tbl+ (8* 30)]
push rax ; calculate arg, rax holds arg, and push it
mov rax, [fvar_tbl+ (8* 29)]
push rax ; calculate arg, rax holds arg, and push it
mov rax, [fvar_tbl+ (8* 28)]
push rax ; calculate arg, rax holds arg, and push it
mov rax, [fvar_tbl+ (8* 4)]
push rax ; calculate arg, rax holds arg, and push it
push 4 ; push argcount
;next is proc:
;we know that env = [rbp + 8*2]
; we know that depth is env.length
; now we SHOULD allocate extenv with size env.length+1= depth+1
MALLOC rax, 8*(1+0) ; rax->extEnv
mov rbx, 0 ;i
mov rcx, 1 ;j
;following loop is to shift the env in extended env
loop_11:
    cmp rbx, 0
    jge end_loop_11
    mov rdx, [rbp + 8*2] ; rdx = env
    shl rbx, 3
    add rdx, rbx ; env[i] =-->[var, var,...var] 
    shr rbx, 3
    mov r8, [rdx] 
    mov [rax + 8*rcx], r8 ; extEnv[j]=env[i]
    inc rcx
    inc rbx
    jmp loop_11
end_loop_11:
 ;  rax holds ->extEnv
;n= [rbp+8*3]
mov rbx, rax ;rbx holds extEnv
; Allocate ExtEnv[0] to point to a vector where to store the parameters
mov r8, [rbp+8*3] ; r8= n
inc r8; +magic
shl r8, 3
MALLOC r9, r8 ; r9 holds the vector for the params with size 8*n +1 for magic
shr r8, 3
dec r8; - magic
mov rcx, 0 ;i=0
;following loop is to Copy the parameters off of the stack to the extended env:
loop_12:
    cmp rcx ,r8 ; i<n
    jge end_loop_12
    mov rdx, [rbp+8*(4+rcx)] ;  rdx= param_i
    mov [r9+8*rcx], rdx ; ExtEnv [0][i]= param_i
    inc rcx
    jmp loop_12
end_loop_12:
mov qword [r9+8*rcx], SOB_NIL_ADDRESS; add magic to the end
mov [rbx], r9 ; updte the extEnv[0]-> vector that we created for the params

MAKE_CLOSURE(rax, rbx, Lcode_6)
 jmp Lcont_6
Lcode_6:
push rbp
mov rbp , rsp
;applic tp:
push SOB_NIL_ADDRESS ; push magic
mov rax, const_tbl+23
push rax ; calculate arg, rax holds arg, and push it
push 1 ; push argcount
;next is proc:
;we know that env = [rbp + 8*2]
; we know that depth is env.length
; now we SHOULD allocate extenv with size env.length+1= depth+1
MALLOC rax, 8*(1+1) ; rax->extEnv
mov rbx, 0 ;i
mov rcx, 1 ;j
;following loop is to shift the env in extended env
loop_13:
    cmp rbx, 1
    jge end_loop_13
    mov rdx, [rbp + 8*2] ; rdx = env
    shl rbx, 3
    add rdx, rbx ; env[i] =-->[var, var,...var] 
    shr rbx, 3
    mov r8, [rdx] 
    mov [rax + 8*rcx], r8 ; extEnv[j]=env[i]
    inc rcx
    inc rbx
    jmp loop_13
end_loop_13:
 ;  rax holds ->extEnv
;n= [rbp+8*3]
mov rbx, rax ;rbx holds extEnv
; Allocate ExtEnv[0] to point to a vector where to store the parameters
mov r8, [rbp+8*3] ; r8= n
inc r8; +magic
shl r8, 3
MALLOC r9, r8 ; r9 holds the vector for the params with size 8*n +1 for magic
shr r8, 3
dec r8; - magic
mov rcx, 0 ;i=0
;following loop is to Copy the parameters off of the stack to the extended env:
loop_14:
    cmp rcx ,r8 ; i<n
    jge end_loop_14
    mov rdx, [rbp+8*(4+rcx)] ;  rdx= param_i
    mov [r9+8*rcx], rdx ; ExtEnv [0][i]= param_i
    inc rcx
    jmp loop_14
end_loop_14:
mov qword [r9+8*rcx], SOB_NIL_ADDRESS; add magic to the end
mov [rbx], r9 ; updte the extEnv[0]-> vector that we created for the params

MAKE_CLOSURE(rax, rbx, Lcode_7)
 jmp Lcont_7
Lcode_7:
push rbp
mov rbp , rsp
MALLOC rax, 8
mov rbx, qword[rbp+ 8*(4+0)]
mov [rax], rbx
mov qword [rbp + 8 * (4 + (0))],rax
mov rax, SOB_VOID_ADDRESS
;we know that env = [rbp + 8*2]
; we know that depth is env.length
; now we SHOULD allocate extenv with size env.length+1= depth+1
MALLOC rax, 8*(1+2) ; rax->extEnv
mov rbx, 0 ;i
mov rcx, 1 ;j
;following loop is to shift the env in extended env
loop_15:
    cmp rbx, 2
    jge end_loop_15
    mov rdx, [rbp + 8*2] ; rdx = env
    shl rbx, 3
    add rdx, rbx ; env[i] =-->[var, var,...var] 
    shr rbx, 3
    mov r8, [rdx] 
    mov [rax + 8*rcx], r8 ; extEnv[j]=env[i]
    inc rcx
    inc rbx
    jmp loop_15
end_loop_15:
 ;  rax holds ->extEnv
;n= [rbp+8*3]
mov rbx, rax ;rbx holds extEnv
; Allocate ExtEnv[0] to point to a vector where to store the parameters
mov r8, [rbp+8*3] ; r8= n
inc r8; +magic
shl r8, 3
MALLOC r9, r8 ; r9 holds the vector for the params with size 8*n +1 for magic
shr r8, 3
dec r8; - magic
mov rcx, 0 ;i=0
;following loop is to Copy the parameters off of the stack to the extended env:
loop_16:
    cmp rcx ,r8 ; i<n
    jge end_loop_16
    mov rdx, [rbp+8*(4+rcx)] ;  rdx= param_i
    mov [r9+8*rcx], rdx ; ExtEnv [0][i]= param_i
    inc rcx
    jmp loop_16
end_loop_16:
mov qword [r9+8*rcx], SOB_NIL_ADDRESS; add magic to the end
mov [rbx], r9 ; updte the extEnv[0]-> vector that we created for the params

MAKE_CLOSURE(rax, rbx, Lcode_8)
 jmp Lcont_8
Lcode_8:
push rbp
mov rbp , rsp
;applic:
         push SOB_NIL_ADDRESS ; push magic
mov rax, qword [rbp + 8 *(4 + 2)]
push rax ; calculate arg, rax holds arg, and push it
push 1 ; push argcount
;next is proc:
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * (1)]
mov rax, qword [rax + 8 * (0)]
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
call qword [rax+9] ; call to code ptr
 add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8*rbx]; pop args
add rsp , 8 ; pop magic, which is sob_nil
cmp rax, SOB_FALSE_ADDRESS
je Lelse_3
mov rax, qword [rbp + 8 *(4 + 1)]
jmp Lexit_3
Lelse_3:
;applic tp:
push SOB_NIL_ADDRESS ; push magic
;applic:
         push SOB_NIL_ADDRESS ; push magic
mov rax, qword [rbp + 8 *(4 + 2)]
push rax ; calculate arg, rax holds arg, and push it
push 1 ; push argcount
;next is proc:
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * (1)]
mov rax, qword [rax + 8 * (2)]
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
call qword [rax+9] ; call to code ptr
 add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8*rbx]; pop args
add rsp , 8 ; pop magic, which is sob_nil
push rax ; calculate arg, rax holds arg, and push it
;applic:
         push SOB_NIL_ADDRESS ; push magic
;applic:
         push SOB_NIL_ADDRESS ; push magic
mov rax, qword [rbp + 8 *(4 + 2)]
push rax ; calculate arg, rax holds arg, and push it
push 1 ; push argcount
;next is proc:
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * (1)]
mov rax, qword [rax + 8 * (1)]
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
call qword [rax+9] ; call to code ptr
 add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8*rbx]; pop args
add rsp , 8 ; pop magic, which is sob_nil
push rax ; calculate arg, rax holds arg, and push it
mov rax, qword [rbp + 8 *(4 + 1)]
push rax ; calculate arg, rax holds arg, and push it
push 2 ; push argcount
;next is proc:
mov rax, qword [rbp + 8 *(4 + 0)]
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
call qword [rax+9] ; call to code ptr
 add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8*rbx]; pop args
add rsp , 8 ; pop magic, which is sob_nil
push rax ; calculate arg, rax holds arg, and push it
mov rax, qword [rbp + 8 *(4 + 0)]
push rax ; calculate arg, rax holds arg, and push it
push 3 ; push argcount
;next is proc:
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * (0)]
mov rax, qword [rax + 8 * (0)]
mov rax, qword [rax]
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
push qword [rbp + 8 * 1] ; old ret addr
mov r11, qword [rbp]
SHIFT_FRAME_6:
mov r15, rbp
sub r15, 8 ; r15= adress in stack of first to move up
mov qword r14, [rbp + 8*3] ; r14=n
add r14, 4
shl r14, 3
add r14, rbp ; r14 = rbp+ 8*(4+n) , which is the adress we should overide first
; we are moving top down:
.loop_of_shifts:
  cmp r15, rsp
  jl .end_loop_of_shifts ; we finished
  mov qword r12, [r15]; r12 = element to move
  mov qword [r14], r12 ; move elemnt to top of stack
  sub r14, 8
  sub r15, 8
  jmp .loop_of_shifts
.end_loop_of_shifts:
  add r14, 8
  mov rsp, r14
  mov rbp, r11
  jmp qword [rax+9] ; jump to code ptr
 Lexit_3:

leave
ret
Lcont_8:
push rax
mov rax, qword [rbp + 8 *(4 + 0)]
pop qword [rax]
mov rax, SOB_VOID_ADDRESS
;we know that env = [rbp + 8*2]
; we know that depth is env.length
; now we SHOULD allocate extenv with size env.length+1= depth+1
MALLOC rax, 8*(1+2) ; rax->extEnv
mov rbx, 0 ;i
mov rcx, 1 ;j
;following loop is to shift the env in extended env
loop_17:
    cmp rbx, 2
    jge end_loop_17
    mov rdx, [rbp + 8*2] ; rdx = env
    shl rbx, 3
    add rdx, rbx ; env[i] =-->[var, var,...var] 
    shr rbx, 3
    mov r8, [rdx] 
    mov [rax + 8*rcx], r8 ; extEnv[j]=env[i]
    inc rcx
    inc rbx
    jmp loop_17
end_loop_17:
 ;  rax holds ->extEnv
;n= [rbp+8*3]
mov rbx, rax ;rbx holds extEnv
; Allocate ExtEnv[0] to point to a vector where to store the parameters
mov r8, [rbp+8*3] ; r8= n
inc r8; +magic
shl r8, 3
MALLOC r9, r8 ; r9 holds the vector for the params with size 8*n +1 for magic
shr r8, 3
dec r8; - magic
mov rcx, 0 ;i=0
;following loop is to Copy the parameters off of the stack to the extended env:
loop_18:
    cmp rcx ,r8 ; i<n
    jge end_loop_18
    mov rdx, [rbp+8*(4+rcx)] ;  rdx= param_i
    mov [r9+8*rcx], rdx ; ExtEnv [0][i]= param_i
    inc rcx
    jmp loop_18
end_loop_18:
mov qword [r9+8*rcx], SOB_NIL_ADDRESS; add magic to the end
mov [rbx], r9 ; updte the extEnv[0]-> vector that we created for the params

MAKE_CLOSURE(rax, rbx, Lcode_9)
 jmp Lcont_9
Lcode_9:
push rbp
mov rbp , rsp
;applic tp:
push SOB_NIL_ADDRESS ; push magic
mov rax, qword [rbp + 8 *(4 + 2)]
push rax ; calculate arg, rax holds arg, and push it
mov rax, qword [rbp + 8 *(4 + 1)]
push rax ; calculate arg, rax holds arg, and push it
mov rax, qword [rbp + 8 *(4 + 0)]
push rax ; calculate arg, rax holds arg, and push it
push 3 ; push argcount
;next is proc:
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * (0)]
mov rax, qword [rax + 8 * (0)]
mov rax, qword [rax]
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
push qword [rbp + 8 * 1] ; old ret addr
mov r11, qword [rbp]
SHIFT_FRAME_7:
mov r15, rbp
sub r15, 8 ; r15= adress in stack of first to move up
mov qword r14, [rbp + 8*3] ; r14=n
add r14, 4
shl r14, 3
add r14, rbp ; r14 = rbp+ 8*(4+n) , which is the adress we should overide first
; we are moving top down:
.loop_of_shifts:
  cmp r15, rsp
  jl .end_loop_of_shifts ; we finished
  mov qword r12, [r15]; r12 = element to move
  mov qword [r14], r12 ; move elemnt to top of stack
  sub r14, 8
  sub r15, 8
  jmp .loop_of_shifts
.end_loop_of_shifts:
  add r14, 8
  mov rsp, r14
  mov rbp, r11
  jmp qword [rax+9] ; jump to code ptr
 
leave
ret
Lcont_9:

leave
ret
Lcont_7:
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
push qword [rbp + 8 * 1] ; old ret addr
mov r11, qword [rbp]
SHIFT_FRAME_5:
mov r15, rbp
sub r15, 8 ; r15= adress in stack of first to move up
mov qword r14, [rbp + 8*3] ; r14=n
add r14, 4
shl r14, 3
add r14, rbp ; r14 = rbp+ 8*(4+n) , which is the adress we should overide first
; we are moving top down:
.loop_of_shifts:
  cmp r15, rsp
  jl .end_loop_of_shifts ; we finished
  mov qword r12, [r15]; r12 = element to move
  mov qword [r14], r12 ; move elemnt to top of stack
  sub r14, 8
  sub r15, 8
  jmp .loop_of_shifts
.end_loop_of_shifts:
  add r14, 8
  mov rsp, r14
  mov rbp, r11
  jmp qword [rax+9] ; jump to code ptr
 
leave
ret
Lcont_6:
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
call qword [rax+9] ; call to code ptr
 add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8*rbx]; pop args
add rsp , 8 ; pop magic, which is sob_nil
mov [fvar_tbl+(8*33)], rax
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void

;applic:
         push SOB_NIL_ADDRESS ; push magic
mov rax, [fvar_tbl+ (8* 29)]
push rax ; calculate arg, rax holds arg, and push it
mov rax, [fvar_tbl+ (8* 28)]
push rax ; calculate arg, rax holds arg, and push it
mov rax, [fvar_tbl+ (8* 4)]
push rax ; calculate arg, rax holds arg, and push it
push 3 ; push argcount
;next is proc:
;we know that env = [rbp + 8*2]
; we know that depth is env.length
; now we SHOULD allocate extenv with size env.length+1= depth+1
MALLOC rax, 8*(1+0) ; rax->extEnv
mov rbx, 0 ;i
mov rcx, 1 ;j
;following loop is to shift the env in extended env
loop_19:
    cmp rbx, 0
    jge end_loop_19
    mov rdx, [rbp + 8*2] ; rdx = env
    shl rbx, 3
    add rdx, rbx ; env[i] =-->[var, var,...var] 
    shr rbx, 3
    mov r8, [rdx] 
    mov [rax + 8*rcx], r8 ; extEnv[j]=env[i]
    inc rcx
    inc rbx
    jmp loop_19
end_loop_19:
 ;  rax holds ->extEnv
;n= [rbp+8*3]
mov rbx, rax ;rbx holds extEnv
; Allocate ExtEnv[0] to point to a vector where to store the parameters
mov r8, [rbp+8*3] ; r8= n
inc r8; +magic
shl r8, 3
MALLOC r9, r8 ; r9 holds the vector for the params with size 8*n +1 for magic
shr r8, 3
dec r8; - magic
mov rcx, 0 ;i=0
;following loop is to Copy the parameters off of the stack to the extended env:
loop_20:
    cmp rcx ,r8 ; i<n
    jge end_loop_20
    mov rdx, [rbp+8*(4+rcx)] ;  rdx= param_i
    mov [r9+8*rcx], rdx ; ExtEnv [0][i]= param_i
    inc rcx
    jmp loop_20
end_loop_20:
mov qword [r9+8*rcx], SOB_NIL_ADDRESS; add magic to the end
mov [rbx], r9 ; updte the extEnv[0]-> vector that we created for the params

MAKE_CLOSURE(rax, rbx, Lcode_10)
 jmp Lcont_10
Lcode_10:
push rbp
mov rbp , rsp
;applic tp:
push SOB_NIL_ADDRESS ; push magic
mov rax, const_tbl+23
push rax ; calculate arg, rax holds arg, and push it
push 1 ; push argcount
;next is proc:
;we know that env = [rbp + 8*2]
; we know that depth is env.length
; now we SHOULD allocate extenv with size env.length+1= depth+1
MALLOC rax, 8*(1+1) ; rax->extEnv
mov rbx, 0 ;i
mov rcx, 1 ;j
;following loop is to shift the env in extended env
loop_21:
    cmp rbx, 1
    jge end_loop_21
    mov rdx, [rbp + 8*2] ; rdx = env
    shl rbx, 3
    add rdx, rbx ; env[i] =-->[var, var,...var] 
    shr rbx, 3
    mov r8, [rdx] 
    mov [rax + 8*rcx], r8 ; extEnv[j]=env[i]
    inc rcx
    inc rbx
    jmp loop_21
end_loop_21:
 ;  rax holds ->extEnv
;n= [rbp+8*3]
mov rbx, rax ;rbx holds extEnv
; Allocate ExtEnv[0] to point to a vector where to store the parameters
mov r8, [rbp+8*3] ; r8= n
inc r8; +magic
shl r8, 3
MALLOC r9, r8 ; r9 holds the vector for the params with size 8*n +1 for magic
shr r8, 3
dec r8; - magic
mov rcx, 0 ;i=0
;following loop is to Copy the parameters off of the stack to the extended env:
loop_22:
    cmp rcx ,r8 ; i<n
    jge end_loop_22
    mov rdx, [rbp+8*(4+rcx)] ;  rdx= param_i
    mov [r9+8*rcx], rdx ; ExtEnv [0][i]= param_i
    inc rcx
    jmp loop_22
end_loop_22:
mov qword [r9+8*rcx], SOB_NIL_ADDRESS; add magic to the end
mov [rbx], r9 ; updte the extEnv[0]-> vector that we created for the params

MAKE_CLOSURE(rax, rbx, Lcode_11)
 jmp Lcont_11
Lcode_11:
push rbp
mov rbp , rsp
MALLOC rax, 8
mov rbx, qword[rbp+ 8*(4+0)]
mov [rax], rbx
mov qword [rbp + 8 * (4 + (0))],rax
mov rax, SOB_VOID_ADDRESS
;we know that env = [rbp + 8*2]
; we know that depth is env.length
; now we SHOULD allocate extenv with size env.length+1= depth+1
MALLOC rax, 8*(1+2) ; rax->extEnv
mov rbx, 0 ;i
mov rcx, 1 ;j
;following loop is to shift the env in extended env
loop_23:
    cmp rbx, 2
    jge end_loop_23
    mov rdx, [rbp + 8*2] ; rdx = env
    shl rbx, 3
    add rdx, rbx ; env[i] =-->[var, var,...var] 
    shr rbx, 3
    mov r8, [rdx] 
    mov [rax + 8*rcx], r8 ; extEnv[j]=env[i]
    inc rcx
    inc rbx
    jmp loop_23
end_loop_23:
 ;  rax holds ->extEnv
;n= [rbp+8*3]
mov rbx, rax ;rbx holds extEnv
; Allocate ExtEnv[0] to point to a vector where to store the parameters
mov r8, [rbp+8*3] ; r8= n
inc r8; +magic
shl r8, 3
MALLOC r9, r8 ; r9 holds the vector for the params with size 8*n +1 for magic
shr r8, 3
dec r8; - magic
mov rcx, 0 ;i=0
;following loop is to Copy the parameters off of the stack to the extended env:
loop_24:
    cmp rcx ,r8 ; i<n
    jge end_loop_24
    mov rdx, [rbp+8*(4+rcx)] ;  rdx= param_i
    mov [r9+8*rcx], rdx ; ExtEnv [0][i]= param_i
    inc rcx
    jmp loop_24
end_loop_24:
mov qword [r9+8*rcx], SOB_NIL_ADDRESS; add magic to the end
mov [rbx], r9 ; updte the extEnv[0]-> vector that we created for the params

MAKE_CLOSURE(rax, rbx, Lcode_12)
 jmp Lcont_12
Lcode_12:
push rbp
mov rbp , rsp
;applic:
         push SOB_NIL_ADDRESS ; push magic
mov rax, qword [rbp + 8 *(4 + 2)]
push rax ; calculate arg, rax holds arg, and push it
push 1 ; push argcount
;next is proc:
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * (1)]
mov rax, qword [rax + 8 * (0)]
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
call qword [rax+9] ; call to code ptr
 add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8*rbx]; pop args
add rsp , 8 ; pop magic, which is sob_nil
cmp rax, SOB_FALSE_ADDRESS
je Lelse_4
mov rax, qword [rbp + 8 *(4 + 1)]
jmp Lexit_4
Lelse_4:
;applic tp:
push SOB_NIL_ADDRESS ; push magic
;applic:
         push SOB_NIL_ADDRESS ; push magic
;applic:
         push SOB_NIL_ADDRESS ; push magic
mov rax, qword [rbp + 8 *(4 + 2)]
push rax ; calculate arg, rax holds arg, and push it
push 1 ; push argcount
;next is proc:
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * (1)]
mov rax, qword [rax + 8 * (2)]
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
call qword [rax+9] ; call to code ptr
 add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8*rbx]; pop args
add rsp , 8 ; pop magic, which is sob_nil
push rax ; calculate arg, rax holds arg, and push it
mov rax, qword [rbp + 8 *(4 + 1)]
push rax ; calculate arg, rax holds arg, and push it
mov rax, qword [rbp + 8 *(4 + 0)]
push rax ; calculate arg, rax holds arg, and push it
push 3 ; push argcount
;next is proc:
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * (0)]
mov rax, qword [rax + 8 * (0)]
mov rax, qword [rax]
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
call qword [rax+9] ; call to code ptr
 add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8*rbx]; pop args
add rsp , 8 ; pop magic, which is sob_nil
push rax ; calculate arg, rax holds arg, and push it
;applic:
         push SOB_NIL_ADDRESS ; push magic
mov rax, qword [rbp + 8 *(4 + 2)]
push rax ; calculate arg, rax holds arg, and push it
push 1 ; push argcount
;next is proc:
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * (1)]
mov rax, qword [rax + 8 * (1)]
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
call qword [rax+9] ; call to code ptr
 add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8*rbx]; pop args
add rsp , 8 ; pop magic, which is sob_nil
push rax ; calculate arg, rax holds arg, and push it
push 2 ; push argcount
;next is proc:
mov rax, qword [rbp + 8 *(4 + 0)]
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
push qword [rbp + 8 * 1] ; old ret addr
mov r11, qword [rbp]
SHIFT_FRAME_9:
mov r15, rbp
sub r15, 8 ; r15= adress in stack of first to move up
mov qword r14, [rbp + 8*3] ; r14=n
add r14, 4
shl r14, 3
add r14, rbp ; r14 = rbp+ 8*(4+n) , which is the adress we should overide first
; we are moving top down:
.loop_of_shifts:
  cmp r15, rsp
  jl .end_loop_of_shifts ; we finished
  mov qword r12, [r15]; r12 = element to move
  mov qword [r14], r12 ; move elemnt to top of stack
  sub r14, 8
  sub r15, 8
  jmp .loop_of_shifts
.end_loop_of_shifts:
  add r14, 8
  mov rsp, r14
  mov rbp, r11
  jmp qword [rax+9] ; jump to code ptr
 Lexit_4:

leave
ret
Lcont_12:
push rax
mov rax, qword [rbp + 8 *(4 + 0)]
pop qword [rax]
mov rax, SOB_VOID_ADDRESS
;we know that env = [rbp + 8*2]
; we know that depth is env.length
; now we SHOULD allocate extenv with size env.length+1= depth+1
MALLOC rax, 8*(1+2) ; rax->extEnv
mov rbx, 0 ;i
mov rcx, 1 ;j
;following loop is to shift the env in extended env
loop_25:
    cmp rbx, 2
    jge end_loop_25
    mov rdx, [rbp + 8*2] ; rdx = env
    shl rbx, 3
    add rdx, rbx ; env[i] =-->[var, var,...var] 
    shr rbx, 3
    mov r8, [rdx] 
    mov [rax + 8*rcx], r8 ; extEnv[j]=env[i]
    inc rcx
    inc rbx
    jmp loop_25
end_loop_25:
 ;  rax holds ->extEnv
;n= [rbp+8*3]
mov rbx, rax ;rbx holds extEnv
; Allocate ExtEnv[0] to point to a vector where to store the parameters
mov r8, [rbp+8*3] ; r8= n
inc r8; +magic
shl r8, 3
MALLOC r9, r8 ; r9 holds the vector for the params with size 8*n +1 for magic
shr r8, 3
dec r8; - magic
mov rcx, 0 ;i=0
;following loop is to Copy the parameters off of the stack to the extended env:
loop_26:
    cmp rcx ,r8 ; i<n
    jge end_loop_26
    mov rdx, [rbp+8*(4+rcx)] ;  rdx= param_i
    mov [r9+8*rcx], rdx ; ExtEnv [0][i]= param_i
    inc rcx
    jmp loop_26
end_loop_26:
mov qword [r9+8*rcx], SOB_NIL_ADDRESS; add magic to the end
mov [rbx], r9 ; updte the extEnv[0]-> vector that we created for the params

MAKE_CLOSURE(rax, rbx, Lcode_13)
 jmp Lcont_13
Lcode_13:
push rbp
mov rbp , rsp
;applic tp:
push SOB_NIL_ADDRESS ; push magic
mov rax, qword [rbp + 8 *(4 + 2)]
push rax ; calculate arg, rax holds arg, and push it
mov rax, qword [rbp + 8 *(4 + 1)]
push rax ; calculate arg, rax holds arg, and push it
mov rax, qword [rbp + 8 *(4 + 0)]
push rax ; calculate arg, rax holds arg, and push it
push 3 ; push argcount
;next is proc:
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * (0)]
mov rax, qword [rax + 8 * (0)]
mov rax, qword [rax]
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
push qword [rbp + 8 * 1] ; old ret addr
mov r11, qword [rbp]
SHIFT_FRAME_10:
mov r15, rbp
sub r15, 8 ; r15= adress in stack of first to move up
mov qword r14, [rbp + 8*3] ; r14=n
add r14, 4
shl r14, 3
add r14, rbp ; r14 = rbp+ 8*(4+n) , which is the adress we should overide first
; we are moving top down:
.loop_of_shifts:
  cmp r15, rsp
  jl .end_loop_of_shifts ; we finished
  mov qword r12, [r15]; r12 = element to move
  mov qword [r14], r12 ; move elemnt to top of stack
  sub r14, 8
  sub r15, 8
  jmp .loop_of_shifts
.end_loop_of_shifts:
  add r14, 8
  mov rsp, r14
  mov rbp, r11
  jmp qword [rax+9] ; jump to code ptr
 
leave
ret
Lcont_13:

leave
ret
Lcont_11:
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
push qword [rbp + 8 * 1] ; old ret addr
mov r11, qword [rbp]
SHIFT_FRAME_8:
mov r15, rbp
sub r15, 8 ; r15= adress in stack of first to move up
mov qword r14, [rbp + 8*3] ; r14=n
add r14, 4
shl r14, 3
add r14, rbp ; r14 = rbp+ 8*(4+n) , which is the adress we should overide first
; we are moving top down:
.loop_of_shifts:
  cmp r15, rsp
  jl .end_loop_of_shifts ; we finished
  mov qword r12, [r15]; r12 = element to move
  mov qword [r14], r12 ; move elemnt to top of stack
  sub r14, 8
  sub r15, 8
  jmp .loop_of_shifts
.end_loop_of_shifts:
  add r14, 8
  mov rsp, r14
  mov rbp, r11
  jmp qword [rax+9] ; jump to code ptr
 
leave
ret
Lcont_10:
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
call qword [rax+9] ; call to code ptr
 add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8*rbx]; pop args
add rsp , 8 ; pop magic, which is sob_nil
mov [fvar_tbl+(8*34)], rax
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void

;applic:
         push SOB_NIL_ADDRESS ; push magic
mov rax, [fvar_tbl+ (8* 30)]
push rax ; calculate arg, rax holds arg, and push it
mov rax, [fvar_tbl+ (8* 28)]
push rax ; calculate arg, rax holds arg, and push it
mov rax, [fvar_tbl+ (8* 29)]
push rax ; calculate arg, rax holds arg, and push it
mov rax, [fvar_tbl+ (8* 27)]
push rax ; calculate arg, rax holds arg, and push it
mov rax, [fvar_tbl+ (8* 4)]
push rax ; calculate arg, rax holds arg, and push it
push 5 ; push argcount
;next is proc:
;we know that env = [rbp + 8*2]
; we know that depth is env.length
; now we SHOULD allocate extenv with size env.length+1= depth+1
MALLOC rax, 8*(1+0) ; rax->extEnv
mov rbx, 0 ;i
mov rcx, 1 ;j
;following loop is to shift the env in extended env
loop_27:
    cmp rbx, 0
    jge end_loop_27
    mov rdx, [rbp + 8*2] ; rdx = env
    shl rbx, 3
    add rdx, rbx ; env[i] =-->[var, var,...var] 
    shr rbx, 3
    mov r8, [rdx] 
    mov [rax + 8*rcx], r8 ; extEnv[j]=env[i]
    inc rcx
    inc rbx
    jmp loop_27
end_loop_27:
 ;  rax holds ->extEnv
;n= [rbp+8*3]
mov rbx, rax ;rbx holds extEnv
; Allocate ExtEnv[0] to point to a vector where to store the parameters
mov r8, [rbp+8*3] ; r8= n
inc r8; +magic
shl r8, 3
MALLOC r9, r8 ; r9 holds the vector for the params with size 8*n +1 for magic
shr r8, 3
dec r8; - magic
mov rcx, 0 ;i=0
;following loop is to Copy the parameters off of the stack to the extended env:
loop_28:
    cmp rcx ,r8 ; i<n
    jge end_loop_28
    mov rdx, [rbp+8*(4+rcx)] ;  rdx= param_i
    mov [r9+8*rcx], rdx ; ExtEnv [0][i]= param_i
    inc rcx
    jmp loop_28
end_loop_28:
mov qword [r9+8*rcx], SOB_NIL_ADDRESS; add magic to the end
mov [rbx], r9 ; updte the extEnv[0]-> vector that we created for the params

MAKE_CLOSURE(rax, rbx, Lcode_14)
 jmp Lcont_14
Lcode_14:
push rbp
mov rbp , rsp
;we know that env = [rbp + 8*2]
; we know that depth is env.length
; now we SHOULD allocate extenv with size env.length+1= depth+1
MALLOC rax, 8*(1+1) ; rax->extEnv
mov rbx, 0 ;i
mov rcx, 1 ;j
;following loop is to shift the env in extended env
loop_29:
    cmp rbx, 1
    jge end_loop_29
    mov rdx, [rbp + 8*2] ; rdx = env
    shl rbx, 3
    add rdx, rbx ; env[i] =-->[var, var,...var] 
    shr rbx, 3
    mov r8, [rdx] 
    mov [rax + 8*rcx], r8 ; extEnv[j]=env[i]
    inc rcx
    inc rbx
    jmp loop_29
end_loop_29:
 ;  rax holds ->extEnv
;n= [rbp+8*3]
mov rbx, rax ;rbx holds extEnv
; Allocate ExtEnv[0] to point to a vector where to store the parameters
mov r8, [rbp+8*3] ; r8= n
inc r8; +magic
shl r8, 3
MALLOC r9, r8 ; r9 holds the vector for the params with size 8*n +1 for magic
shr r8, 3
dec r8; - magic
mov rcx, 0 ;i=0
;following loop is to Copy the parameters off of the stack to the extended env:
loop_30:
    cmp rcx ,r8 ; i<n
    jge end_loop_30
    mov rdx, [rbp+8*(4+rcx)] ;  rdx= param_i
    mov [r9+8*rcx], rdx ; ExtEnv [0][i]= param_i
    inc rcx
    jmp loop_30
end_loop_30:
mov qword [r9+8*rcx], SOB_NIL_ADDRESS; add magic to the end
mov [rbx], r9 ; updte the extEnv[0]-> vector that we created for the params

MAKE_CLOSURE(rax, rbx, Lcode_15)
 jmp Lcont_15
Lcode_15:
mov rdx, rsp ; rdx hold cur stack ptr ==> [rdx]= ret_adr etc... (i chose rdx because cons does'nt overide it)
mov r8, [rdx+8*2] ; r8= arg_count 
cmp r8, 1 ; compare arg_count to the amount we've expected
jl .no_fix_necessery
; else: we need to collect all exses args to a list
mov r9, SOB_NIL_ADDRESS ; r9 holds curr list
mov r10, r8
sub r10, 0 ; r10= lst size= num of opt args
mov r11, r8
dec r11 ; r11 =idx= n-1
.loop_create_lst:
  cmp r11, 0 
  jl .end_loop_create_lst ; end loop if idx<params.lst, which is when we get to the args that arent optional
  mov r13, rsp; r13=sp
  push SOB_NIL_ADDRESS; push magic
  push r9 ; push cdr
  push qword [rdx+8*(3+r11)] ; push arg_idx = car
  push qword 2; argcount= car, cdr
  push qword [rdx+8*1]; env
  call cons
  mov rsp, r13
  mov r9, rax ; r9 hold new lst
  mov r13, [r9+1]; r13=car
  mov r13, [r9+1+8]; r13=cdr
  dec r11 ; idx--
  jmp .loop_create_lst
.end_loop_create_lst:

; now r9 holds list of optional args
mov r13, [rdx+8*(3+r8-1)]; should be last opt arg=3
mov qword [rdx+8*(3+r8-1)], r9 ; set arg_n-1 to be optional
mov qword [rdx+8*2], 1
mov r9, r8  ; r9= n
inc r9  ;r9 = n+1 =3+n-2
shl r9, 3 ;r9= 8*(3+n-2)= idx of last place in stack
mov r11, 0
add r11, 2 
shl r11, 3 ; r11 = 8*(3+ params_len -1) = idx of last mandatory arg = the first element from stack that should be moved up
mov r13, [rdx+r11]; should be 1
; both r11, r9 will be decresed each time by 8
.loop_shift_stack:
  cmp r11, 0
  jl .end_loop_shift_stack
  mov rax, [rdx+r11] ; rax = cur element to move
  mov [rdx+r9], rax ; move to the top of the stack the cur element top down
  sub r9, 8
  sub r11, 8
  jmp .loop_shift_stack
.end_loop_shift_stack:
; now, rdx+r9 holds the last place on stack
add r9, 8
add r9, rdx
mov rsp, r9
.no_fix_necessery:

push rbp
mov rbp , rsp
;applic:
         push SOB_NIL_ADDRESS ; push magic
mov rax, qword [rbp + 8 *(4 + 0)]
push rax ; calculate arg, rax holds arg, and push it
push 1 ; push argcount
;next is proc:
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * (0)]
mov rax, qword [rax + 8 * (0)]
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
call qword [rax+9] ; call to code ptr
 add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8*rbx]; pop args
add rsp , 8 ; pop magic, which is sob_nil
cmp rax, SOB_FALSE_ADDRESS
je Lelse_5
mov rax, qword [rbp + 8 *(4 + 0)]
jmp Lexit_5
Lelse_5:
;applic:
         push SOB_NIL_ADDRESS ; push magic
;applic:
         push SOB_NIL_ADDRESS ; push magic
mov rax, qword [rbp + 8 *(4 + 0)]
push rax ; calculate arg, rax holds arg, and push it
push 1 ; push argcount
;next is proc:
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * (0)]
mov rax, qword [rax + 8 * (2)]
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
call qword [rax+9] ; call to code ptr
 add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8*rbx]; pop args
add rsp , 8 ; pop magic, which is sob_nil
push rax ; calculate arg, rax holds arg, and push it
push 1 ; push argcount
;next is proc:
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * (0)]
mov rax, qword [rax + 8 * (0)]
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
call qword [rax+9] ; call to code ptr
 add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8*rbx]; pop args
add rsp , 8 ; pop magic, which is sob_nil
cmp rax, SOB_FALSE_ADDRESS
je Lelse_6
;applic tp:
push SOB_NIL_ADDRESS ; push magic
mov rax, qword [rbp + 8 *(4 + 0)]
push rax ; calculate arg, rax holds arg, and push it
push 1 ; push argcount
;next is proc:
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * (0)]
mov rax, qword [rax + 8 * (3)]
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
push qword [rbp + 8 * 1] ; old ret addr
mov r11, qword [rbp]
SHIFT_FRAME_12:
mov r15, rbp
sub r15, 8 ; r15= adress in stack of first to move up
mov qword r14, [rbp + 8*3] ; r14=n
add r14, 4
shl r14, 3
add r14, rbp ; r14 = rbp+ 8*(4+n) , which is the adress we should overide first
; we are moving top down:
.loop_of_shifts:
  cmp r15, rsp
  jl .end_loop_of_shifts ; we finished
  mov qword r12, [r15]; r12 = element to move
  mov qword [r14], r12 ; move elemnt to top of stack
  sub r14, 8
  sub r15, 8
  jmp .loop_of_shifts
.end_loop_of_shifts:
  add r14, 8
  mov rsp, r14
  mov rbp, r11
  jmp qword [rax+9] ; jump to code ptr
 jmp Lexit_6
Lelse_6:
;applic tp:
push SOB_NIL_ADDRESS ; push magic
;applic:
         push SOB_NIL_ADDRESS ; push magic
;applic:
         push SOB_NIL_ADDRESS ; push magic
mov rax, qword [rbp + 8 *(4 + 0)]
push rax ; calculate arg, rax holds arg, and push it
push 1 ; push argcount
;next is proc:
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * (0)]
mov rax, qword [rax + 8 * (2)]
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
call qword [rax+9] ; call to code ptr
 add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8*rbx]; pop args
add rsp , 8 ; pop magic, which is sob_nil
push rax ; calculate arg, rax holds arg, and push it
mov rax, [fvar_tbl+ (8* 31)]
push rax ; calculate arg, rax holds arg, and push it
push 2 ; push argcount
;next is proc:
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * (0)]
mov rax, qword [rax + 8 * (1)]
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
call qword [rax+9] ; call to code ptr
 add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8*rbx]; pop args
add rsp , 8 ; pop magic, which is sob_nil
push rax ; calculate arg, rax holds arg, and push it
;applic:
         push SOB_NIL_ADDRESS ; push magic
mov rax, qword [rbp + 8 *(4 + 0)]
push rax ; calculate arg, rax holds arg, and push it
push 1 ; push argcount
;next is proc:
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * (0)]
mov rax, qword [rax + 8 * (3)]
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
call qword [rax+9] ; call to code ptr
 add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8*rbx]; pop args
add rsp , 8 ; pop magic, which is sob_nil
push rax ; calculate arg, rax holds arg, and push it
push 2 ; push argcount
;next is proc:
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * (0)]
mov rax, qword [rax + 8 * (4)]
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
push qword [rbp + 8 * 1] ; old ret addr
mov r11, qword [rbp]
SHIFT_FRAME_11:
mov r15, rbp
sub r15, 8 ; r15= adress in stack of first to move up
mov qword r14, [rbp + 8*3] ; r14=n
add r14, 4
shl r14, 3
add r14, rbp ; r14 = rbp+ 8*(4+n) , which is the adress we should overide first
; we are moving top down:
.loop_of_shifts:
  cmp r15, rsp
  jl .end_loop_of_shifts ; we finished
  mov qword r12, [r15]; r12 = element to move
  mov qword [r14], r12 ; move elemnt to top of stack
  sub r14, 8
  sub r15, 8
  jmp .loop_of_shifts
.end_loop_of_shifts:
  add r14, 8
  mov rsp, r14
  mov rbp, r11
  jmp qword [rax+9] ; jump to code ptr
 Lexit_6:
Lexit_5:

leave
ret
Lcont_15:

leave
ret
Lcont_14:
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
call qword [rax+9] ; call to code ptr
 add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8*rbx]; pop args
add rsp , 8 ; pop magic, which is sob_nil
mov [fvar_tbl+(8*31)], rax
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void

;applic:
         push SOB_NIL_ADDRESS ; push magic
mov rax, [fvar_tbl+ (8* 30)]
push rax ; calculate arg, rax holds arg, and push it
mov rax, [fvar_tbl+ (8* 34)]
push rax ; calculate arg, rax holds arg, and push it
mov rax, [fvar_tbl+ (8* 4)]
push rax ; calculate arg, rax holds arg, and push it
push 3 ; push argcount
;next is proc:
;we know that env = [rbp + 8*2]
; we know that depth is env.length
; now we SHOULD allocate extenv with size env.length+1= depth+1
MALLOC rax, 8*(1+0) ; rax->extEnv
mov rbx, 0 ;i
mov rcx, 1 ;j
;following loop is to shift the env in extended env
loop_31:
    cmp rbx, 0
    jge end_loop_31
    mov rdx, [rbp + 8*2] ; rdx = env
    shl rbx, 3
    add rdx, rbx ; env[i] =-->[var, var,...var] 
    shr rbx, 3
    mov r8, [rdx] 
    mov [rax + 8*rcx], r8 ; extEnv[j]=env[i]
    inc rcx
    inc rbx
    jmp loop_31
end_loop_31:
 ;  rax holds ->extEnv
;n= [rbp+8*3]
mov rbx, rax ;rbx holds extEnv
; Allocate ExtEnv[0] to point to a vector where to store the parameters
mov r8, [rbp+8*3] ; r8= n
inc r8; +magic
shl r8, 3
MALLOC r9, r8 ; r9 holds the vector for the params with size 8*n +1 for magic
shr r8, 3
dec r8; - magic
mov rcx, 0 ;i=0
;following loop is to Copy the parameters off of the stack to the extended env:
loop_32:
    cmp rcx ,r8 ; i<n
    jge end_loop_32
    mov rdx, [rbp+8*(4+rcx)] ;  rdx= param_i
    mov [r9+8*rcx], rdx ; ExtEnv [0][i]= param_i
    inc rcx
    jmp loop_32
end_loop_32:
mov qword [r9+8*rcx], SOB_NIL_ADDRESS; add magic to the end
mov [rbx], r9 ; updte the extEnv[0]-> vector that we created for the params

MAKE_CLOSURE(rax, rbx, Lcode_16)
 jmp Lcont_16
Lcode_16:
push rbp
mov rbp , rsp
;we know that env = [rbp + 8*2]
; we know that depth is env.length
; now we SHOULD allocate extenv with size env.length+1= depth+1
MALLOC rax, 8*(1+1) ; rax->extEnv
mov rbx, 0 ;i
mov rcx, 1 ;j
;following loop is to shift the env in extended env
loop_33:
    cmp rbx, 1
    jge end_loop_33
    mov rdx, [rbp + 8*2] ; rdx = env
    shl rbx, 3
    add rdx, rbx ; env[i] =-->[var, var,...var] 
    shr rbx, 3
    mov r8, [rdx] 
    mov [rax + 8*rcx], r8 ; extEnv[j]=env[i]
    inc rcx
    inc rbx
    jmp loop_33
end_loop_33:
 ;  rax holds ->extEnv
;n= [rbp+8*3]
mov rbx, rax ;rbx holds extEnv
; Allocate ExtEnv[0] to point to a vector where to store the parameters
mov r8, [rbp+8*3] ; r8= n
inc r8; +magic
shl r8, 3
MALLOC r9, r8 ; r9 holds the vector for the params with size 8*n +1 for magic
shr r8, 3
dec r8; - magic
mov rcx, 0 ;i=0
;following loop is to Copy the parameters off of the stack to the extended env:
loop_34:
    cmp rcx ,r8 ; i<n
    jge end_loop_34
    mov rdx, [rbp+8*(4+rcx)] ;  rdx= param_i
    mov [r9+8*rcx], rdx ; ExtEnv [0][i]= param_i
    inc rcx
    jmp loop_34
end_loop_34:
mov qword [r9+8*rcx], SOB_NIL_ADDRESS; add magic to the end
mov [rbx], r9 ; updte the extEnv[0]-> vector that we created for the params

MAKE_CLOSURE(rax, rbx, Lcode_17)
 jmp Lcont_17
Lcode_17:
mov rdx, rsp ; rdx hold cur stack ptr ==> [rdx]= ret_adr etc... (i chose rdx because cons does'nt overide it)
mov r8, [rdx+8*2] ; r8= arg_count 
cmp r8, 1 ; compare arg_count to the amount we've expected
jl .no_fix_necessery
; else: we need to collect all exses args to a list
mov r9, SOB_NIL_ADDRESS ; r9 holds curr list
mov r10, r8
sub r10, 0 ; r10= lst size= num of opt args
mov r11, r8
dec r11 ; r11 =idx= n-1
.loop_create_lst:
  cmp r11, 0 
  jl .end_loop_create_lst ; end loop if idx<params.lst, which is when we get to the args that arent optional
  mov r13, rsp; r13=sp
  push SOB_NIL_ADDRESS; push magic
  push r9 ; push cdr
  push qword [rdx+8*(3+r11)] ; push arg_idx = car
  push qword 2; argcount= car, cdr
  push qword [rdx+8*1]; env
  call cons
  mov rsp, r13
  mov r9, rax ; r9 hold new lst
  mov r13, [r9+1]; r13=car
  mov r13, [r9+1+8]; r13=cdr
  dec r11 ; idx--
  jmp .loop_create_lst
.end_loop_create_lst:

; now r9 holds list of optional args
mov r13, [rdx+8*(3+r8-1)]; should be last opt arg=3
mov qword [rdx+8*(3+r8-1)], r9 ; set arg_n-1 to be optional
mov qword [rdx+8*2], 1
mov r9, r8  ; r9= n
inc r9  ;r9 = n+1 =3+n-2
shl r9, 3 ;r9= 8*(3+n-2)= idx of last place in stack
mov r11, 0
add r11, 2 
shl r11, 3 ; r11 = 8*(3+ params_len -1) = idx of last mandatory arg = the first element from stack that should be moved up
mov r13, [rdx+r11]; should be 1
; both r11, r9 will be decresed each time by 8
.loop_shift_stack:
  cmp r11, 0
  jl .end_loop_shift_stack
  mov rax, [rdx+r11] ; rax = cur element to move
  mov [rdx+r9], rax ; move to the top of the stack the cur element top down
  sub r9, 8
  sub r11, 8
  jmp .loop_shift_stack
.end_loop_shift_stack:
; now, rdx+r9 holds the last place on stack
add r9, 8
add r9, rdx
mov rsp, r9
.no_fix_necessery:

push rbp
mov rbp , rsp
;applic tp:
push SOB_NIL_ADDRESS ; push magic
mov rax, qword [rbp + 8 *(4 + 0)]
push rax ; calculate arg, rax holds arg, and push it
mov rax, const_tbl+1
push rax ; calculate arg, rax holds arg, and push it
;we know that env = [rbp + 8*2]
; we know that depth is env.length
; now we SHOULD allocate extenv with size env.length+1= depth+1
MALLOC rax, 8*(1+2) ; rax->extEnv
mov rbx, 0 ;i
mov rcx, 1 ;j
;following loop is to shift the env in extended env
loop_35:
    cmp rbx, 2
    jge end_loop_35
    mov rdx, [rbp + 8*2] ; rdx = env
    shl rbx, 3
    add rdx, rbx ; env[i] =-->[var, var,...var] 
    shr rbx, 3
    mov r8, [rdx] 
    mov [rax + 8*rcx], r8 ; extEnv[j]=env[i]
    inc rcx
    inc rbx
    jmp loop_35
end_loop_35:
 ;  rax holds ->extEnv
;n= [rbp+8*3]
mov rbx, rax ;rbx holds extEnv
; Allocate ExtEnv[0] to point to a vector where to store the parameters
mov r8, [rbp+8*3] ; r8= n
inc r8; +magic
shl r8, 3
MALLOC r9, r8 ; r9 holds the vector for the params with size 8*n +1 for magic
shr r8, 3
dec r8; - magic
mov rcx, 0 ;i=0
;following loop is to Copy the parameters off of the stack to the extended env:
loop_36:
    cmp rcx ,r8 ; i<n
    jge end_loop_36
    mov rdx, [rbp+8*(4+rcx)] ;  rdx= param_i
    mov [r9+8*rcx], rdx ; ExtEnv [0][i]= param_i
    inc rcx
    jmp loop_36
end_loop_36:
mov qword [r9+8*rcx], SOB_NIL_ADDRESS; add magic to the end
mov [rbx], r9 ; updte the extEnv[0]-> vector that we created for the params

MAKE_CLOSURE(rax, rbx, Lcode_18)
 jmp Lcont_18
Lcode_18:
push rbp
mov rbp , rsp
;applic:
         push SOB_NIL_ADDRESS ; push magic
mov rax, qword [rbp + 8 *(4 + 1)]
push rax ; calculate arg, rax holds arg, and push it
push 1 ; push argcount
;next is proc:
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * (1)]
mov rax, qword [rax + 8 * (0)]
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
call qword [rax+9] ; call to code ptr
 add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8*rbx]; pop args
add rsp , 8 ; pop magic, which is sob_nil
cmp rax, SOB_FALSE_ADDRESS
je Lelse_7
mov rax, qword [rbp + 8 *(4 + 0)]
jmp Lexit_7
Lelse_7:
;applic tp:
push SOB_NIL_ADDRESS ; push magic
mov rax, qword [rbp + 8 *(4 + 0)]
push rax ; calculate arg, rax holds arg, and push it
mov rax, qword [rbp + 8 *(4 + 1)]
push rax ; calculate arg, rax holds arg, and push it
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * (1)]
mov rax, qword [rax + 8 * (2)]
push rax ; calculate arg, rax holds arg, and push it
push 3 ; push argcount
;next is proc:
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * (1)]
mov rax, qword [rax + 8 * (1)]
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
push qword [rbp + 8 * 1] ; old ret addr
mov r11, qword [rbp]
SHIFT_FRAME_14:
mov r15, rbp
sub r15, 8 ; r15= adress in stack of first to move up
mov qword r14, [rbp + 8*3] ; r14=n
add r14, 4
shl r14, 3
add r14, rbp ; r14 = rbp+ 8*(4+n) , which is the adress we should overide first
; we are moving top down:
.loop_of_shifts:
  cmp r15, rsp
  jl .end_loop_of_shifts ; we finished
  mov qword r12, [r15]; r12 = element to move
  mov qword [r14], r12 ; move elemnt to top of stack
  sub r14, 8
  sub r15, 8
  jmp .loop_of_shifts
.end_loop_of_shifts:
  add r14, 8
  mov rsp, r14
  mov rbp, r11
  jmp qword [rax+9] ; jump to code ptr
 Lexit_7:

leave
ret
Lcont_18:
push rax ; calculate arg, rax holds arg, and push it
push 3 ; push argcount
;next is proc:
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * (0)]
mov rax, qword [rax + 8 * (1)]
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
push qword [rbp + 8 * 1] ; old ret addr
mov r11, qword [rbp]
SHIFT_FRAME_13:
mov r15, rbp
sub r15, 8 ; r15= adress in stack of first to move up
mov qword r14, [rbp + 8*3] ; r14=n
add r14, 4
shl r14, 3
add r14, rbp ; r14 = rbp+ 8*(4+n) , which is the adress we should overide first
; we are moving top down:
.loop_of_shifts:
  cmp r15, rsp
  jl .end_loop_of_shifts ; we finished
  mov qword r12, [r15]; r12 = element to move
  mov qword [r14], r12 ; move elemnt to top of stack
  sub r14, 8
  sub r15, 8
  jmp .loop_of_shifts
.end_loop_of_shifts:
  add r14, 8
  mov rsp, r14
  mov rbp, r11
  jmp qword [rax+9] ; jump to code ptr
 
leave
ret
Lcont_17:

leave
ret
Lcont_16:
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
call qword [rax+9] ; call to code ptr
 add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8*rbx]; pop args
add rsp , 8 ; pop magic, which is sob_nil
mov [fvar_tbl+(8*26)], rax
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void

;we know that env = [rbp + 8*2]
; we know that depth is env.length
; now we SHOULD allocate extenv with size env.length+1= depth+1
MALLOC rax, 8*(1+0) ; rax->extEnv
mov rbx, 0 ;i
mov rcx, 1 ;j
;following loop is to shift the env in extended env
loop_37:
    cmp rbx, 0
    jge end_loop_37
    mov rdx, [rbp + 8*2] ; rdx = env
    shl rbx, 3
    add rdx, rbx ; env[i] =-->[var, var,...var] 
    shr rbx, 3
    mov r8, [rdx] 
    mov [rax + 8*rcx], r8 ; extEnv[j]=env[i]
    inc rcx
    inc rbx
    jmp loop_37
end_loop_37:
 ;  rax holds ->extEnv
;n= [rbp+8*3]
mov rbx, rax ;rbx holds extEnv
; Allocate ExtEnv[0] to point to a vector where to store the parameters
mov r8, [rbp+8*3] ; r8= n
inc r8; +magic
shl r8, 3
MALLOC r9, r8 ; r9 holds the vector for the params with size 8*n +1 for magic
shr r8, 3
dec r8; - magic
mov rcx, 0 ;i=0
;following loop is to Copy the parameters off of the stack to the extended env:
loop_38:
    cmp rcx ,r8 ; i<n
    jge end_loop_38
    mov rdx, [rbp+8*(4+rcx)] ;  rdx= param_i
    mov [r9+8*rcx], rdx ; ExtEnv [0][i]= param_i
    inc rcx
    jmp loop_38
end_loop_38:
mov qword [r9+8*rcx], SOB_NIL_ADDRESS; add magic to the end
mov [rbx], r9 ; updte the extEnv[0]-> vector that we created for the params

MAKE_CLOSURE(rax, rbx, Lcode_19)
 jmp Lcont_19
Lcode_19:
mov rdx, rsp ; rdx hold cur stack ptr ==> [rdx]= ret_adr etc... (i chose rdx because cons does'nt overide it)
mov r8, [rdx+8*2] ; r8= arg_count 
cmp r8, 1 ; compare arg_count to the amount we've expected
jl .no_fix_necessery
; else: we need to collect all exses args to a list
mov r9, SOB_NIL_ADDRESS ; r9 holds curr list
mov r10, r8
sub r10, 0 ; r10= lst size= num of opt args
mov r11, r8
dec r11 ; r11 =idx= n-1
.loop_create_lst:
  cmp r11, 0 
  jl .end_loop_create_lst ; end loop if idx<params.lst, which is when we get to the args that arent optional
  mov r13, rsp; r13=sp
  push SOB_NIL_ADDRESS; push magic
  push r9 ; push cdr
  push qword [rdx+8*(3+r11)] ; push arg_idx = car
  push qword 2; argcount= car, cdr
  push qword [rdx+8*1]; env
  call cons
  mov rsp, r13
  mov r9, rax ; r9 hold new lst
  mov r13, [r9+1]; r13=car
  mov r13, [r9+1+8]; r13=cdr
  dec r11 ; idx--
  jmp .loop_create_lst
.end_loop_create_lst:

; now r9 holds list of optional args
mov r13, [rdx+8*(3+r8-1)]; should be last opt arg=3
mov qword [rdx+8*(3+r8-1)], r9 ; set arg_n-1 to be optional
mov qword [rdx+8*2], 1
mov r9, r8  ; r9= n
inc r9  ;r9 = n+1 =3+n-2
shl r9, 3 ;r9= 8*(3+n-2)= idx of last place in stack
mov r11, 0
add r11, 2 
shl r11, 3 ; r11 = 8*(3+ params_len -1) = idx of last mandatory arg = the first element from stack that should be moved up
mov r13, [rdx+r11]; should be 1
; both r11, r9 will be decresed each time by 8
.loop_shift_stack:
  cmp r11, 0
  jl .end_loop_shift_stack
  mov rax, [rdx+r11] ; rax = cur element to move
  mov [rdx+r9], rax ; move to the top of the stack the cur element top down
  sub r9, 8
  sub r11, 8
  jmp .loop_shift_stack
.end_loop_shift_stack:
; now, rdx+r9 holds the last place on stack
add r9, 8
add r9, rdx
mov rsp, r9
.no_fix_necessery:

push rbp
mov rbp , rsp
mov rax, qword [rbp + 8 *(4 + 0)]

leave
ret
Lcont_19:
mov [fvar_tbl+(8*37)], rax
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void

;applic:
         push SOB_NIL_ADDRESS ; push magic
mov rax, [fvar_tbl+ (8* 29)]
push rax ; calculate arg, rax holds arg, and push it
mov rax, [fvar_tbl+ (8* 3)]
push rax ; calculate arg, rax holds arg, and push it
mov rax, [fvar_tbl+ (8* 4)]
push rax ; calculate arg, rax holds arg, and push it
push 3 ; push argcount
;next is proc:
;we know that env = [rbp + 8*2]
; we know that depth is env.length
; now we SHOULD allocate extenv with size env.length+1= depth+1
MALLOC rax, 8*(1+0) ; rax->extEnv
mov rbx, 0 ;i
mov rcx, 1 ;j
;following loop is to shift the env in extended env
loop_39:
    cmp rbx, 0
    jge end_loop_39
    mov rdx, [rbp + 8*2] ; rdx = env
    shl rbx, 3
    add rdx, rbx ; env[i] =-->[var, var,...var] 
    shr rbx, 3
    mov r8, [rdx] 
    mov [rax + 8*rcx], r8 ; extEnv[j]=env[i]
    inc rcx
    inc rbx
    jmp loop_39
end_loop_39:
 ;  rax holds ->extEnv
;n= [rbp+8*3]
mov rbx, rax ;rbx holds extEnv
; Allocate ExtEnv[0] to point to a vector where to store the parameters
mov r8, [rbp+8*3] ; r8= n
inc r8; +magic
shl r8, 3
MALLOC r9, r8 ; r9 holds the vector for the params with size 8*n +1 for magic
shr r8, 3
dec r8; - magic
mov rcx, 0 ;i=0
;following loop is to Copy the parameters off of the stack to the extended env:
loop_40:
    cmp rcx ,r8 ; i<n
    jge end_loop_40
    mov rdx, [rbp+8*(4+rcx)] ;  rdx= param_i
    mov [r9+8*rcx], rdx ; ExtEnv [0][i]= param_i
    inc rcx
    jmp loop_40
end_loop_40:
mov qword [r9+8*rcx], SOB_NIL_ADDRESS; add magic to the end
mov [rbx], r9 ; updte the extEnv[0]-> vector that we created for the params

MAKE_CLOSURE(rax, rbx, Lcode_20)
 jmp Lcont_20
Lcode_20:
push rbp
mov rbp , rsp
;applic tp:
push SOB_NIL_ADDRESS ; push magic
mov rax, const_tbl+23
push rax ; calculate arg, rax holds arg, and push it
push 1 ; push argcount
;next is proc:
;we know that env = [rbp + 8*2]
; we know that depth is env.length
; now we SHOULD allocate extenv with size env.length+1= depth+1
MALLOC rax, 8*(1+1) ; rax->extEnv
mov rbx, 0 ;i
mov rcx, 1 ;j
;following loop is to shift the env in extended env
loop_41:
    cmp rbx, 1
    jge end_loop_41
    mov rdx, [rbp + 8*2] ; rdx = env
    shl rbx, 3
    add rdx, rbx ; env[i] =-->[var, var,...var] 
    shr rbx, 3
    mov r8, [rdx] 
    mov [rax + 8*rcx], r8 ; extEnv[j]=env[i]
    inc rcx
    inc rbx
    jmp loop_41
end_loop_41:
 ;  rax holds ->extEnv
;n= [rbp+8*3]
mov rbx, rax ;rbx holds extEnv
; Allocate ExtEnv[0] to point to a vector where to store the parameters
mov r8, [rbp+8*3] ; r8= n
inc r8; +magic
shl r8, 3
MALLOC r9, r8 ; r9 holds the vector for the params with size 8*n +1 for magic
shr r8, 3
dec r8; - magic
mov rcx, 0 ;i=0
;following loop is to Copy the parameters off of the stack to the extended env:
loop_42:
    cmp rcx ,r8 ; i<n
    jge end_loop_42
    mov rdx, [rbp+8*(4+rcx)] ;  rdx= param_i
    mov [r9+8*rcx], rdx ; ExtEnv [0][i]= param_i
    inc rcx
    jmp loop_42
end_loop_42:
mov qword [r9+8*rcx], SOB_NIL_ADDRESS; add magic to the end
mov [rbx], r9 ; updte the extEnv[0]-> vector that we created for the params

MAKE_CLOSURE(rax, rbx, Lcode_21)
 jmp Lcont_21
Lcode_21:
push rbp
mov rbp , rsp
MALLOC rax, 8
mov rbx, qword[rbp+ 8*(4+0)]
mov [rax], rbx
mov qword [rbp + 8 * (4 + (0))],rax
mov rax, SOB_VOID_ADDRESS
;we know that env = [rbp + 8*2]
; we know that depth is env.length
; now we SHOULD allocate extenv with size env.length+1= depth+1
MALLOC rax, 8*(1+2) ; rax->extEnv
mov rbx, 0 ;i
mov rcx, 1 ;j
;following loop is to shift the env in extended env
loop_43:
    cmp rbx, 2
    jge end_loop_43
    mov rdx, [rbp + 8*2] ; rdx = env
    shl rbx, 3
    add rdx, rbx ; env[i] =-->[var, var,...var] 
    shr rbx, 3
    mov r8, [rdx] 
    mov [rax + 8*rcx], r8 ; extEnv[j]=env[i]
    inc rcx
    inc rbx
    jmp loop_43
end_loop_43:
 ;  rax holds ->extEnv
;n= [rbp+8*3]
mov rbx, rax ;rbx holds extEnv
; Allocate ExtEnv[0] to point to a vector where to store the parameters
mov r8, [rbp+8*3] ; r8= n
inc r8; +magic
shl r8, 3
MALLOC r9, r8 ; r9 holds the vector for the params with size 8*n +1 for magic
shr r8, 3
dec r8; - magic
mov rcx, 0 ;i=0
;following loop is to Copy the parameters off of the stack to the extended env:
loop_44:
    cmp rcx ,r8 ; i<n
    jge end_loop_44
    mov rdx, [rbp+8*(4+rcx)] ;  rdx= param_i
    mov [r9+8*rcx], rdx ; ExtEnv [0][i]= param_i
    inc rcx
    jmp loop_44
end_loop_44:
mov qword [r9+8*rcx], SOB_NIL_ADDRESS; add magic to the end
mov [rbx], r9 ; updte the extEnv[0]-> vector that we created for the params

MAKE_CLOSURE(rax, rbx, Lcode_22)
 jmp Lcont_22
Lcode_22:
push rbp
mov rbp , rsp
;applic:
         push SOB_NIL_ADDRESS ; push magic
mov rax, qword [rbp + 8 *(4 + 0)]
push rax ; calculate arg, rax holds arg, and push it
push 1 ; push argcount
;next is proc:
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * (1)]
mov rax, qword [rax + 8 * (0)]
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
call qword [rax+9] ; call to code ptr
 add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8*rbx]; pop args
add rsp , 8 ; pop magic, which is sob_nil
cmp rax, SOB_FALSE_ADDRESS
jne Lexit_Or_1
;applic:
         push SOB_NIL_ADDRESS ; push magic
mov rax, qword [rbp + 8 *(4 + 0)]
push rax ; calculate arg, rax holds arg, and push it
push 1 ; push argcount
;next is proc:
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * (1)]
mov rax, qword [rax + 8 * (1)]
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
call qword [rax+9] ; call to code ptr
 add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8*rbx]; pop args
add rsp , 8 ; pop magic, which is sob_nil
cmp rax, SOB_FALSE_ADDRESS
je Lelse_8
;applic tp:
push SOB_NIL_ADDRESS ; push magic
;applic:
         push SOB_NIL_ADDRESS ; push magic
mov rax, qword [rbp + 8 *(4 + 0)]
push rax ; calculate arg, rax holds arg, and push it
push 1 ; push argcount
;next is proc:
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * (1)]
mov rax, qword [rax + 8 * (2)]
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
call qword [rax+9] ; call to code ptr
 add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8*rbx]; pop args
add rsp , 8 ; pop magic, which is sob_nil
push rax ; calculate arg, rax holds arg, and push it
push 1 ; push argcount
;next is proc:
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * (0)]
mov rax, qword [rax + 8 * (0)]
mov rax, qword [rax]
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
push qword [rbp + 8 * 1] ; old ret addr
mov r11, qword [rbp]
SHIFT_FRAME_16:
mov r15, rbp
sub r15, 8 ; r15= adress in stack of first to move up
mov qword r14, [rbp + 8*3] ; r14=n
add r14, 4
shl r14, 3
add r14, rbp ; r14 = rbp+ 8*(4+n) , which is the adress we should overide first
; we are moving top down:
.loop_of_shifts:
  cmp r15, rsp
  jl .end_loop_of_shifts ; we finished
  mov qword r12, [r15]; r12 = element to move
  mov qword [r14], r12 ; move elemnt to top of stack
  sub r14, 8
  sub r15, 8
  jmp .loop_of_shifts
.end_loop_of_shifts:
  add r14, 8
  mov rsp, r14
  mov rbp, r11
  jmp qword [rax+9] ; jump to code ptr
 jmp Lexit_8
Lelse_8:
mov rax, const_tbl+2
Lexit_8:
Lexit_Or_1:

leave
ret
Lcont_22:
push rax
mov rax, qword [rbp + 8 *(4 + 0)]
pop qword [rax]
mov rax, SOB_VOID_ADDRESS
mov rax, qword [rbp + 8 *(4 + 0)]
mov rax, qword [rax]

leave
ret
Lcont_21:
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
push qword [rbp + 8 * 1] ; old ret addr
mov r11, qword [rbp]
SHIFT_FRAME_15:
mov r15, rbp
sub r15, 8 ; r15= adress in stack of first to move up
mov qword r14, [rbp + 8*3] ; r14=n
add r14, 4
shl r14, 3
add r14, rbp ; r14 = rbp+ 8*(4+n) , which is the adress we should overide first
; we are moving top down:
.loop_of_shifts:
  cmp r15, rsp
  jl .end_loop_of_shifts ; we finished
  mov qword r12, [r15]; r12 = element to move
  mov qword [r14], r12 ; move elemnt to top of stack
  sub r14, 8
  sub r15, 8
  jmp .loop_of_shifts
.end_loop_of_shifts:
  add r14, 8
  mov rsp, r14
  mov rbp, r11
  jmp qword [rax+9] ; jump to code ptr
 
leave
ret
Lcont_20:
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
call qword [rax+9] ; call to code ptr
 add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8*rbx]; pop args
add rsp , 8 ; pop magic, which is sob_nil
mov [fvar_tbl+(8*38)], rax
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void

;applic:
         push SOB_NIL_ADDRESS ; push magic
mov rax, [fvar_tbl+ (8* 12)]
push rax ; calculate arg, rax holds arg, and push it
mov rax, [fvar_tbl+ (8* 28)]
push rax ; calculate arg, rax holds arg, and push it
mov rax, [fvar_tbl+ (8* 4)]
push rax ; calculate arg, rax holds arg, and push it
push 3 ; push argcount
;next is proc:
;we know that env = [rbp + 8*2]
; we know that depth is env.length
; now we SHOULD allocate extenv with size env.length+1= depth+1
MALLOC rax, 8*(1+0) ; rax->extEnv
mov rbx, 0 ;i
mov rcx, 1 ;j
;following loop is to shift the env in extended env
loop_45:
    cmp rbx, 0
    jge end_loop_45
    mov rdx, [rbp + 8*2] ; rdx = env
    shl rbx, 3
    add rdx, rbx ; env[i] =-->[var, var,...var] 
    shr rbx, 3
    mov r8, [rdx] 
    mov [rax + 8*rcx], r8 ; extEnv[j]=env[i]
    inc rcx
    inc rbx
    jmp loop_45
end_loop_45:
 ;  rax holds ->extEnv
;n= [rbp+8*3]
mov rbx, rax ;rbx holds extEnv
; Allocate ExtEnv[0] to point to a vector where to store the parameters
mov r8, [rbp+8*3] ; r8= n
inc r8; +magic
shl r8, 3
MALLOC r9, r8 ; r9 holds the vector for the params with size 8*n +1 for magic
shr r8, 3
dec r8; - magic
mov rcx, 0 ;i=0
;following loop is to Copy the parameters off of the stack to the extended env:
loop_46:
    cmp rcx ,r8 ; i<n
    jge end_loop_46
    mov rdx, [rbp+8*(4+rcx)] ;  rdx= param_i
    mov [r9+8*rcx], rdx ; ExtEnv [0][i]= param_i
    inc rcx
    jmp loop_46
end_loop_46:
mov qword [r9+8*rcx], SOB_NIL_ADDRESS; add magic to the end
mov [rbx], r9 ; updte the extEnv[0]-> vector that we created for the params

MAKE_CLOSURE(rax, rbx, Lcode_23)
 jmp Lcont_23
Lcode_23:
push rbp
mov rbp , rsp
;we know that env = [rbp + 8*2]
; we know that depth is env.length
; now we SHOULD allocate extenv with size env.length+1= depth+1
MALLOC rax, 8*(1+1) ; rax->extEnv
mov rbx, 0 ;i
mov rcx, 1 ;j
;following loop is to shift the env in extended env
loop_47:
    cmp rbx, 1
    jge end_loop_47
    mov rdx, [rbp + 8*2] ; rdx = env
    shl rbx, 3
    add rdx, rbx ; env[i] =-->[var, var,...var] 
    shr rbx, 3
    mov r8, [rdx] 
    mov [rax + 8*rcx], r8 ; extEnv[j]=env[i]
    inc rcx
    inc rbx
    jmp loop_47
end_loop_47:
 ;  rax holds ->extEnv
;n= [rbp+8*3]
mov rbx, rax ;rbx holds extEnv
; Allocate ExtEnv[0] to point to a vector where to store the parameters
mov r8, [rbp+8*3] ; r8= n
inc r8; +magic
shl r8, 3
MALLOC r9, r8 ; r9 holds the vector for the params with size 8*n +1 for magic
shr r8, 3
dec r8; - magic
mov rcx, 0 ;i=0
;following loop is to Copy the parameters off of the stack to the extended env:
loop_48:
    cmp rcx ,r8 ; i<n
    jge end_loop_48
    mov rdx, [rbp+8*(4+rcx)] ;  rdx= param_i
    mov [r9+8*rcx], rdx ; ExtEnv [0][i]= param_i
    inc rcx
    jmp loop_48
end_loop_48:
mov qword [r9+8*rcx], SOB_NIL_ADDRESS; add magic to the end
mov [rbx], r9 ; updte the extEnv[0]-> vector that we created for the params

MAKE_CLOSURE(rax, rbx, Lcode_24)
 jmp Lcont_24
Lcode_24:
mov rdx, rsp ; rdx hold cur stack ptr ==> [rdx]= ret_adr etc... (i chose rdx because cons does'nt overide it)
mov r8, [rdx+8*2] ; r8= arg_count 
cmp r8, 2 ; compare arg_count to the amount we've expected
jl .no_fix_necessery
; else: we need to collect all exses args to a list
mov r9, SOB_NIL_ADDRESS ; r9 holds curr list
mov r10, r8
sub r10, 1 ; r10= lst size= num of opt args
mov r11, r8
dec r11 ; r11 =idx= n-1
.loop_create_lst:
  cmp r11, 1 
  jl .end_loop_create_lst ; end loop if idx<params.lst, which is when we get to the args that arent optional
  mov r13, rsp; r13=sp
  push SOB_NIL_ADDRESS; push magic
  push r9 ; push cdr
  push qword [rdx+8*(3+r11)] ; push arg_idx = car
  push qword 2; argcount= car, cdr
  push qword [rdx+8*1]; env
  call cons
  mov rsp, r13
  mov r9, rax ; r9 hold new lst
  mov r13, [r9+1]; r13=car
  mov r13, [r9+1+8]; r13=cdr
  dec r11 ; idx--
  jmp .loop_create_lst
.end_loop_create_lst:

; now r9 holds list of optional args
mov r13, [rdx+8*(3+r8-1)]; should be last opt arg=3
mov qword [rdx+8*(3+r8-1)], r9 ; set arg_n-1 to be optional
mov qword [rdx+8*2], 2
mov r9, r8  ; r9= n
inc r9  ;r9 = n+1 =3+n-2
shl r9, 3 ;r9= 8*(3+n-2)= idx of last place in stack
mov r11, 1
add r11, 2 
shl r11, 3 ; r11 = 8*(3+ params_len -1) = idx of last mandatory arg = the first element from stack that should be moved up
mov r13, [rdx+r11]; should be 1
; both r11, r9 will be decresed each time by 8
.loop_shift_stack:
  cmp r11, 0
  jl .end_loop_shift_stack
  mov rax, [rdx+r11] ; rax = cur element to move
  mov [rdx+r9], rax ; move to the top of the stack the cur element top down
  sub r9, 8
  sub r11, 8
  jmp .loop_shift_stack
.end_loop_shift_stack:
; now, rdx+r9 holds the last place on stack
add r9, 8
add r9, rdx
mov rsp, r9
.no_fix_necessery:

push rbp
mov rbp , rsp
;applic:
         push SOB_NIL_ADDRESS ; push magic
mov rax, qword [rbp + 8 *(4 + 1)]
push rax ; calculate arg, rax holds arg, and push it
push 1 ; push argcount
;next is proc:
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * (0)]
mov rax, qword [rax + 8 * (0)]
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
call qword [rax+9] ; call to code ptr
 add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8*rbx]; pop args
add rsp , 8 ; pop magic, which is sob_nil
cmp rax, SOB_FALSE_ADDRESS
je Lelse_9
;applic tp:
push SOB_NIL_ADDRESS ; push magic
mov rax, const_tbl+32
push rax ; calculate arg, rax holds arg, and push it
mov rax, qword [rbp + 8 *(4 + 0)]
push rax ; calculate arg, rax holds arg, and push it
push 2 ; push argcount
;next is proc:
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * (0)]
mov rax, qword [rax + 8 * (2)]
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
push qword [rbp + 8 * 1] ; old ret addr
mov r11, qword [rbp]
SHIFT_FRAME_18:
mov r15, rbp
sub r15, 8 ; r15= adress in stack of first to move up
mov qword r14, [rbp + 8*3] ; r14=n
add r14, 4
shl r14, 3
add r14, rbp ; r14 = rbp+ 8*(4+n) , which is the adress we should overide first
; we are moving top down:
.loop_of_shifts:
  cmp r15, rsp
  jl .end_loop_of_shifts ; we finished
  mov qword r12, [r15]; r12 = element to move
  mov qword [r14], r12 ; move elemnt to top of stack
  sub r14, 8
  sub r15, 8
  jmp .loop_of_shifts
.end_loop_of_shifts:
  add r14, 8
  mov rsp, r14
  mov rbp, r11
  jmp qword [rax+9] ; jump to code ptr
 jmp Lexit_9
Lelse_9:
;applic tp:
push SOB_NIL_ADDRESS ; push magic
;applic:
         push SOB_NIL_ADDRESS ; push magic
mov rax, qword [rbp + 8 *(4 + 1)]
push rax ; calculate arg, rax holds arg, and push it
push 1 ; push argcount
;next is proc:
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * (0)]
mov rax, qword [rax + 8 * (1)]
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
call qword [rax+9] ; call to code ptr
 add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8*rbx]; pop args
add rsp , 8 ; pop magic, which is sob_nil
push rax ; calculate arg, rax holds arg, and push it
mov rax, qword [rbp + 8 *(4 + 0)]
push rax ; calculate arg, rax holds arg, and push it
push 2 ; push argcount
;next is proc:
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * (0)]
mov rax, qword [rax + 8 * (2)]
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
push qword [rbp + 8 * 1] ; old ret addr
mov r11, qword [rbp]
SHIFT_FRAME_17:
mov r15, rbp
sub r15, 8 ; r15= adress in stack of first to move up
mov qword r14, [rbp + 8*3] ; r14=n
add r14, 4
shl r14, 3
add r14, rbp ; r14 = rbp+ 8*(4+n) , which is the adress we should overide first
; we are moving top down:
.loop_of_shifts:
  cmp r15, rsp
  jl .end_loop_of_shifts ; we finished
  mov qword r12, [r15]; r12 = element to move
  mov qword [r14], r12 ; move elemnt to top of stack
  sub r14, 8
  sub r15, 8
  jmp .loop_of_shifts
.end_loop_of_shifts:
  add r14, 8
  mov rsp, r14
  mov rbp, r11
  jmp qword [rax+9] ; jump to code ptr
 Lexit_9:

leave
ret
Lcont_24:

leave
ret
Lcont_23:
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
call qword [rax+9] ; call to code ptr
 add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8*rbx]; pop args
add rsp , 8 ; pop magic, which is sob_nil
mov [fvar_tbl+(8*12)], rax
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void

;we know that env = [rbp + 8*2]
; we know that depth is env.length
; now we SHOULD allocate extenv with size env.length+1= depth+1
MALLOC rax, 8*(1+0) ; rax->extEnv
mov rbx, 0 ;i
mov rcx, 1 ;j
;following loop is to shift the env in extended env
loop_49:
    cmp rbx, 0
    jge end_loop_49
    mov rdx, [rbp + 8*2] ; rdx = env
    shl rbx, 3
    add rdx, rbx ; env[i] =-->[var, var,...var] 
    shr rbx, 3
    mov r8, [rdx] 
    mov [rax + 8*rcx], r8 ; extEnv[j]=env[i]
    inc rcx
    inc rbx
    jmp loop_49
end_loop_49:
 ;  rax holds ->extEnv
;n= [rbp+8*3]
mov rbx, rax ;rbx holds extEnv
; Allocate ExtEnv[0] to point to a vector where to store the parameters
mov r8, [rbp+8*3] ; r8= n
inc r8; +magic
shl r8, 3
MALLOC r9, r8 ; r9 holds the vector for the params with size 8*n +1 for magic
shr r8, 3
dec r8; - magic
mov rcx, 0 ;i=0
;following loop is to Copy the parameters off of the stack to the extended env:
loop_50:
    cmp rcx ,r8 ; i<n
    jge end_loop_50
    mov rdx, [rbp+8*(4+rcx)] ;  rdx= param_i
    mov [r9+8*rcx], rdx ; ExtEnv [0][i]= param_i
    inc rcx
    jmp loop_50
end_loop_50:
mov qword [r9+8*rcx], SOB_NIL_ADDRESS; add magic to the end
mov [rbx], r9 ; updte the extEnv[0]-> vector that we created for the params

MAKE_CLOSURE(rax, rbx, Lcode_25)
 jmp Lcont_25
Lcode_25:
push rbp
mov rbp , rsp
mov rax, qword [rbp + 8 *(4 + 0)]
cmp rax, SOB_FALSE_ADDRESS
je Lelse_10
mov rax, const_tbl+2
jmp Lexit_10
Lelse_10:
mov rax, const_tbl+4
Lexit_10:

leave
ret
Lcont_25:
mov [fvar_tbl+(8*40)], rax
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void

;applic:
         push SOB_NIL_ADDRESS ; push magic
mov rax, [fvar_tbl+ (8* 4)]
push rax ; calculate arg, rax holds arg, and push it
mov rax, [fvar_tbl+ (8* 29)]
push rax ; calculate arg, rax holds arg, and push it
mov rax, [fvar_tbl+ (8* 28)]
push rax ; calculate arg, rax holds arg, and push it
mov rax, [fvar_tbl+ (8* 22)]
push rax ; calculate arg, rax holds arg, and push it
mov rax, [fvar_tbl+ (8* 21)]
push rax ; calculate arg, rax holds arg, and push it
mov rax, [fvar_tbl+ (8* 20)]
push rax ; calculate arg, rax holds arg, and push it
mov rax, [fvar_tbl+ (8* 19)]
push rax ; calculate arg, rax holds arg, and push it
mov rax, [fvar_tbl+ (8* 18)]
push rax ; calculate arg, rax holds arg, and push it
mov rax, [fvar_tbl+ (8* 39)]
push rax ; calculate arg, rax holds arg, and push it
mov rax, [fvar_tbl+ (8* 33)]
push rax ; calculate arg, rax holds arg, and push it
mov rax, [fvar_tbl+ (8* 16)]
push rax ; calculate arg, rax holds arg, and push it
mov rax, [fvar_tbl+ (8* 2)]
push rax ; calculate arg, rax holds arg, and push it
mov rax, [fvar_tbl+ (8* 1)]
push rax ; calculate arg, rax holds arg, and push it
push 13 ; push argcount
;next is proc:
;we know that env = [rbp + 8*2]
; we know that depth is env.length
; now we SHOULD allocate extenv with size env.length+1= depth+1
MALLOC rax, 8*(1+0) ; rax->extEnv
mov rbx, 0 ;i
mov rcx, 1 ;j
;following loop is to shift the env in extended env
loop_51:
    cmp rbx, 0
    jge end_loop_51
    mov rdx, [rbp + 8*2] ; rdx = env
    shl rbx, 3
    add rdx, rbx ; env[i] =-->[var, var,...var] 
    shr rbx, 3
    mov r8, [rdx] 
    mov [rax + 8*rcx], r8 ; extEnv[j]=env[i]
    inc rcx
    inc rbx
    jmp loop_51
end_loop_51:
 ;  rax holds ->extEnv
;n= [rbp+8*3]
mov rbx, rax ;rbx holds extEnv
; Allocate ExtEnv[0] to point to a vector where to store the parameters
mov r8, [rbp+8*3] ; r8= n
inc r8; +magic
shl r8, 3
MALLOC r9, r8 ; r9 holds the vector for the params with size 8*n +1 for magic
shr r8, 3
dec r8; - magic
mov rcx, 0 ;i=0
;following loop is to Copy the parameters off of the stack to the extended env:
loop_52:
    cmp rcx ,r8 ; i<n
    jge end_loop_52
    mov rdx, [rbp+8*(4+rcx)] ;  rdx= param_i
    mov [r9+8*rcx], rdx ; ExtEnv [0][i]= param_i
    inc rcx
    jmp loop_52
end_loop_52:
mov qword [r9+8*rcx], SOB_NIL_ADDRESS; add magic to the end
mov [rbx], r9 ; updte the extEnv[0]-> vector that we created for the params

MAKE_CLOSURE(rax, rbx, Lcode_26)
 jmp Lcont_26
Lcode_26:
push rbp
mov rbp , rsp
;applic tp:
push SOB_NIL_ADDRESS ; push magic
;we know that env = [rbp + 8*2]
; we know that depth is env.length
; now we SHOULD allocate extenv with size env.length+1= depth+1
MALLOC rax, 8*(1+1) ; rax->extEnv
mov rbx, 0 ;i
mov rcx, 1 ;j
;following loop is to shift the env in extended env
loop_53:
    cmp rbx, 1
    jge end_loop_53
    mov rdx, [rbp + 8*2] ; rdx = env
    shl rbx, 3
    add rdx, rbx ; env[i] =-->[var, var,...var] 
    shr rbx, 3
    mov r8, [rdx] 
    mov [rax + 8*rcx], r8 ; extEnv[j]=env[i]
    inc rcx
    inc rbx
    jmp loop_53
end_loop_53:
 ;  rax holds ->extEnv
;n= [rbp+8*3]
mov rbx, rax ;rbx holds extEnv
; Allocate ExtEnv[0] to point to a vector where to store the parameters
mov r8, [rbp+8*3] ; r8= n
inc r8; +magic
shl r8, 3
MALLOC r9, r8 ; r9 holds the vector for the params with size 8*n +1 for magic
shr r8, 3
dec r8; - magic
mov rcx, 0 ;i=0
;following loop is to Copy the parameters off of the stack to the extended env:
loop_54:
    cmp rcx ,r8 ; i<n
    jge end_loop_54
    mov rdx, [rbp+8*(4+rcx)] ;  rdx= param_i
    mov [r9+8*rcx], rdx ; ExtEnv [0][i]= param_i
    inc rcx
    jmp loop_54
end_loop_54:
mov qword [r9+8*rcx], SOB_NIL_ADDRESS; add magic to the end
mov [rbx], r9 ; updte the extEnv[0]-> vector that we created for the params

MAKE_CLOSURE(rax, rbx, Lcode_27)
 jmp Lcont_27
Lcode_27:
push rbp
mov rbp , rsp
;we know that env = [rbp + 8*2]
; we know that depth is env.length
; now we SHOULD allocate extenv with size env.length+1= depth+1
MALLOC rax, 8*(1+2) ; rax->extEnv
mov rbx, 0 ;i
mov rcx, 1 ;j
;following loop is to shift the env in extended env
loop_55:
    cmp rbx, 2
    jge end_loop_55
    mov rdx, [rbp + 8*2] ; rdx = env
    shl rbx, 3
    add rdx, rbx ; env[i] =-->[var, var,...var] 
    shr rbx, 3
    mov r8, [rdx] 
    mov [rax + 8*rcx], r8 ; extEnv[j]=env[i]
    inc rcx
    inc rbx
    jmp loop_55
end_loop_55:
 ;  rax holds ->extEnv
;n= [rbp+8*3]
mov rbx, rax ;rbx holds extEnv
; Allocate ExtEnv[0] to point to a vector where to store the parameters
mov r8, [rbp+8*3] ; r8= n
inc r8; +magic
shl r8, 3
MALLOC r9, r8 ; r9 holds the vector for the params with size 8*n +1 for magic
shr r8, 3
dec r8; - magic
mov rcx, 0 ;i=0
;following loop is to Copy the parameters off of the stack to the extended env:
loop_56:
    cmp rcx ,r8 ; i<n
    jge end_loop_56
    mov rdx, [rbp+8*(4+rcx)] ;  rdx= param_i
    mov [r9+8*rcx], rdx ; ExtEnv [0][i]= param_i
    inc rcx
    jmp loop_56
end_loop_56:
mov qword [r9+8*rcx], SOB_NIL_ADDRESS; add magic to the end
mov [rbx], r9 ; updte the extEnv[0]-> vector that we created for the params

MAKE_CLOSURE(rax, rbx, Lcode_28)
 jmp Lcont_28
Lcode_28:
push rbp
mov rbp , rsp
;applic:
         push SOB_NIL_ADDRESS ; push magic
mov rax, qword [rbp + 8 *(4 + 0)]
push rax ; calculate arg, rax holds arg, and push it
push 1 ; push argcount
;next is proc:
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * (1)]
mov rax, qword [rax + 8 * (0)]
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
call qword [rax+9] ; call to code ptr
 add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8*rbx]; pop args
add rsp , 8 ; pop magic, which is sob_nil
cmp rax, SOB_FALSE_ADDRESS
je Lelse_14
;applic:
         push SOB_NIL_ADDRESS ; push magic
mov rax, qword [rbp + 8 *(4 + 1)]
push rax ; calculate arg, rax holds arg, and push it
push 1 ; push argcount
;next is proc:
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * (1)]
mov rax, qword [rax + 8 * (1)]
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
call qword [rax+9] ; call to code ptr
 add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8*rbx]; pop args
add rsp , 8 ; pop magic, which is sob_nil
jmp Lexit_14
Lelse_14:
mov rax, const_tbl+2
Lexit_14:
cmp rax, SOB_FALSE_ADDRESS
je Lelse_11
;applic tp:
push SOB_NIL_ADDRESS ; push magic
;applic:
         push SOB_NIL_ADDRESS ; push magic
mov rax, qword [rbp + 8 *(4 + 1)]
push rax ; calculate arg, rax holds arg, and push it
push 1 ; push argcount
;next is proc:
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * (1)]
mov rax, qword [rax + 8 * (2)]
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
call qword [rax+9] ; call to code ptr
 add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8*rbx]; pop args
add rsp , 8 ; pop magic, which is sob_nil
push rax ; calculate arg, rax holds arg, and push it
mov rax, qword [rbp + 8 *(4 + 0)]
push rax ; calculate arg, rax holds arg, and push it
push 2 ; push argcount
;next is proc:
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * (0)]
mov rax, qword [rax + 8 * (0)]
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
push qword [rbp + 8 * 1] ; old ret addr
mov r11, qword [rbp]
SHIFT_FRAME_22:
mov r15, rbp
sub r15, 8 ; r15= adress in stack of first to move up
mov qword r14, [rbp + 8*3] ; r14=n
add r14, 4
shl r14, 3
add r14, rbp ; r14 = rbp+ 8*(4+n) , which is the adress we should overide first
; we are moving top down:
.loop_of_shifts:
  cmp r15, rsp
  jl .end_loop_of_shifts ; we finished
  mov qword r12, [r15]; r12 = element to move
  mov qword [r14], r12 ; move elemnt to top of stack
  sub r14, 8
  sub r15, 8
  jmp .loop_of_shifts
.end_loop_of_shifts:
  add r14, 8
  mov rsp, r14
  mov rbp, r11
  jmp qword [rax+9] ; jump to code ptr
 jmp Lexit_11
Lelse_11:
;applic:
         push SOB_NIL_ADDRESS ; push magic
mov rax, qword [rbp + 8 *(4 + 0)]
push rax ; calculate arg, rax holds arg, and push it
push 1 ; push argcount
;next is proc:
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * (1)]
mov rax, qword [rax + 8 * (1)]
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
call qword [rax+9] ; call to code ptr
 add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8*rbx]; pop args
add rsp , 8 ; pop magic, which is sob_nil
cmp rax, SOB_FALSE_ADDRESS
je Lelse_13
;applic:
         push SOB_NIL_ADDRESS ; push magic
mov rax, qword [rbp + 8 *(4 + 1)]
push rax ; calculate arg, rax holds arg, and push it
push 1 ; push argcount
;next is proc:
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * (1)]
mov rax, qword [rax + 8 * (0)]
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
call qword [rax+9] ; call to code ptr
 add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8*rbx]; pop args
add rsp , 8 ; pop magic, which is sob_nil
jmp Lexit_13
Lelse_13:
mov rax, const_tbl+2
Lexit_13:
cmp rax, SOB_FALSE_ADDRESS
je Lelse_12
;applic tp:
push SOB_NIL_ADDRESS ; push magic
mov rax, qword [rbp + 8 *(4 + 1)]
push rax ; calculate arg, rax holds arg, and push it
;applic:
         push SOB_NIL_ADDRESS ; push magic
mov rax, qword [rbp + 8 *(4 + 0)]
push rax ; calculate arg, rax holds arg, and push it
push 1 ; push argcount
;next is proc:
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * (1)]
mov rax, qword [rax + 8 * (2)]
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
call qword [rax+9] ; call to code ptr
 add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8*rbx]; pop args
add rsp , 8 ; pop magic, which is sob_nil
push rax ; calculate arg, rax holds arg, and push it
push 2 ; push argcount
;next is proc:
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * (0)]
mov rax, qword [rax + 8 * (0)]
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
push qword [rbp + 8 * 1] ; old ret addr
mov r11, qword [rbp]
SHIFT_FRAME_21:
mov r15, rbp
sub r15, 8 ; r15= adress in stack of first to move up
mov qword r14, [rbp + 8*3] ; r14=n
add r14, 4
shl r14, 3
add r14, rbp ; r14 = rbp+ 8*(4+n) , which is the adress we should overide first
; we are moving top down:
.loop_of_shifts:
  cmp r15, rsp
  jl .end_loop_of_shifts ; we finished
  mov qword r12, [r15]; r12 = element to move
  mov qword [r14], r12 ; move elemnt to top of stack
  sub r14, 8
  sub r15, 8
  jmp .loop_of_shifts
.end_loop_of_shifts:
  add r14, 8
  mov rsp, r14
  mov rbp, r11
  jmp qword [rax+9] ; jump to code ptr
 jmp Lexit_12
Lelse_12:
;applic tp:
push SOB_NIL_ADDRESS ; push magic
mov rax, qword [rbp + 8 *(4 + 1)]
push rax ; calculate arg, rax holds arg, and push it
mov rax, qword [rbp + 8 *(4 + 0)]
push rax ; calculate arg, rax holds arg, and push it
push 2 ; push argcount
;next is proc:
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * (0)]
mov rax, qword [rax + 8 * (0)]
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
push qword [rbp + 8 * 1] ; old ret addr
mov r11, qword [rbp]
SHIFT_FRAME_20:
mov r15, rbp
sub r15, 8 ; r15= adress in stack of first to move up
mov qword r14, [rbp + 8*3] ; r14=n
add r14, 4
shl r14, 3
add r14, rbp ; r14 = rbp+ 8*(4+n) , which is the adress we should overide first
; we are moving top down:
.loop_of_shifts:
  cmp r15, rsp
  jl .end_loop_of_shifts ; we finished
  mov qword r12, [r15]; r12 = element to move
  mov qword [r14], r12 ; move elemnt to top of stack
  sub r14, 8
  sub r15, 8
  jmp .loop_of_shifts
.end_loop_of_shifts:
  add r14, 8
  mov rsp, r14
  mov rbp, r11
  jmp qword [rax+9] ; jump to code ptr
 Lexit_12:
Lexit_11:

leave
ret
Lcont_28:

leave
ret
Lcont_27:
push rax ; calculate arg, rax holds arg, and push it
push 1 ; push argcount
;next is proc:
;we know that env = [rbp + 8*2]
; we know that depth is env.length
; now we SHOULD allocate extenv with size env.length+1= depth+1
MALLOC rax, 8*(1+1) ; rax->extEnv
mov rbx, 0 ;i
mov rcx, 1 ;j
;following loop is to shift the env in extended env
loop_57:
    cmp rbx, 1
    jge end_loop_57
    mov rdx, [rbp + 8*2] ; rdx = env
    shl rbx, 3
    add rdx, rbx ; env[i] =-->[var, var,...var] 
    shr rbx, 3
    mov r8, [rdx] 
    mov [rax + 8*rcx], r8 ; extEnv[j]=env[i]
    inc rcx
    inc rbx
    jmp loop_57
end_loop_57:
 ;  rax holds ->extEnv
;n= [rbp+8*3]
mov rbx, rax ;rbx holds extEnv
; Allocate ExtEnv[0] to point to a vector where to store the parameters
mov r8, [rbp+8*3] ; r8= n
inc r8; +magic
shl r8, 3
MALLOC r9, r8 ; r9 holds the vector for the params with size 8*n +1 for magic
shr r8, 3
dec r8; - magic
mov rcx, 0 ;i=0
;following loop is to Copy the parameters off of the stack to the extended env:
loop_58:
    cmp rcx ,r8 ; i<n
    jge end_loop_58
    mov rdx, [rbp+8*(4+rcx)] ;  rdx= param_i
    mov [r9+8*rcx], rdx ; ExtEnv [0][i]= param_i
    inc rcx
    jmp loop_58
end_loop_58:
mov qword [r9+8*rcx], SOB_NIL_ADDRESS; add magic to the end
mov [rbx], r9 ; updte the extEnv[0]-> vector that we created for the params

MAKE_CLOSURE(rax, rbx, Lcode_29)
 jmp Lcont_29
Lcode_29:
push rbp
mov rbp , rsp
;we know that env = [rbp + 8*2]
; we know that depth is env.length
; now we SHOULD allocate extenv with size env.length+1= depth+1
MALLOC rax, 8*(1+2) ; rax->extEnv
mov rbx, 0 ;i
mov rcx, 1 ;j
;following loop is to shift the env in extended env
loop_59:
    cmp rbx, 2
    jge end_loop_59
    mov rdx, [rbp + 8*2] ; rdx = env
    shl rbx, 3
    add rdx, rbx ; env[i] =-->[var, var,...var] 
    shr rbx, 3
    mov r8, [rdx] 
    mov [rax + 8*rcx], r8 ; extEnv[j]=env[i]
    inc rcx
    inc rbx
    jmp loop_59
end_loop_59:
 ;  rax holds ->extEnv
;n= [rbp+8*3]
mov rbx, rax ;rbx holds extEnv
; Allocate ExtEnv[0] to point to a vector where to store the parameters
mov r8, [rbp+8*3] ; r8= n
inc r8; +magic
shl r8, 3
MALLOC r9, r8 ; r9 holds the vector for the params with size 8*n +1 for magic
shr r8, 3
dec r8; - magic
mov rcx, 0 ;i=0
;following loop is to Copy the parameters off of the stack to the extended env:
loop_60:
    cmp rcx ,r8 ; i<n
    jge end_loop_60
    mov rdx, [rbp+8*(4+rcx)] ;  rdx= param_i
    mov [r9+8*rcx], rdx ; ExtEnv [0][i]= param_i
    inc rcx
    jmp loop_60
end_loop_60:
mov qword [r9+8*rcx], SOB_NIL_ADDRESS; add magic to the end
mov [rbx], r9 ; updte the extEnv[0]-> vector that we created for the params

MAKE_CLOSURE(rax, rbx, Lcode_30)
 jmp Lcont_30
Lcode_30:
mov rdx, rsp ; rdx hold cur stack ptr ==> [rdx]= ret_adr etc... (i chose rdx because cons does'nt overide it)
mov r8, [rdx+8*2] ; r8= arg_count 
cmp r8, 1 ; compare arg_count to the amount we've expected
jl .no_fix_necessery
; else: we need to collect all exses args to a list
mov r9, SOB_NIL_ADDRESS ; r9 holds curr list
mov r10, r8
sub r10, 0 ; r10= lst size= num of opt args
mov r11, r8
dec r11 ; r11 =idx= n-1
.loop_create_lst:
  cmp r11, 0 
  jl .end_loop_create_lst ; end loop if idx<params.lst, which is when we get to the args that arent optional
  mov r13, rsp; r13=sp
  push SOB_NIL_ADDRESS; push magic
  push r9 ; push cdr
  push qword [rdx+8*(3+r11)] ; push arg_idx = car
  push qword 2; argcount= car, cdr
  push qword [rdx+8*1]; env
  call cons
  mov rsp, r13
  mov r9, rax ; r9 hold new lst
  mov r13, [r9+1]; r13=car
  mov r13, [r9+1+8]; r13=cdr
  dec r11 ; idx--
  jmp .loop_create_lst
.end_loop_create_lst:

; now r9 holds list of optional args
mov r13, [rdx+8*(3+r8-1)]; should be last opt arg=3
mov qword [rdx+8*(3+r8-1)], r9 ; set arg_n-1 to be optional
mov qword [rdx+8*2], 1
mov r9, r8  ; r9= n
inc r9  ;r9 = n+1 =3+n-2
shl r9, 3 ;r9= 8*(3+n-2)= idx of last place in stack
mov r11, 0
add r11, 2 
shl r11, 3 ; r11 = 8*(3+ params_len -1) = idx of last mandatory arg = the first element from stack that should be moved up
mov r13, [rdx+r11]; should be 1
; both r11, r9 will be decresed each time by 8
.loop_shift_stack:
  cmp r11, 0
  jl .end_loop_shift_stack
  mov rax, [rdx+r11] ; rax = cur element to move
  mov [rdx+r9], rax ; move to the top of the stack the cur element top down
  sub r9, 8
  sub r11, 8
  jmp .loop_shift_stack
.end_loop_shift_stack:
; now, rdx+r9 holds the last place on stack
add r9, 8
add r9, rdx
mov rsp, r9
.no_fix_necessery:

push rbp
mov rbp , rsp
;applic tp:
push SOB_NIL_ADDRESS ; push magic
mov rax, qword [rbp + 8 *(4 + 0)]
push rax ; calculate arg, rax holds arg, and push it
mov rax, const_tbl+51
push rax ; calculate arg, rax holds arg, and push it
;applic:
         push SOB_NIL_ADDRESS ; push magic
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * (1)]
mov rax, qword [rax + 8 * (5)]
push rax ; calculate arg, rax holds arg, and push it
push 1 ; push argcount
;next is proc:
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * (0)]
mov rax, qword [rax + 8 * (0)]
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
call qword [rax+9] ; call to code ptr
 add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8*rbx]; pop args
add rsp , 8 ; pop magic, which is sob_nil
push rax ; calculate arg, rax holds arg, and push it
push 3 ; push argcount
;next is proc:
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * (1)]
mov rax, qword [rax + 8 * (3)]
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
push qword [rbp + 8 * 1] ; old ret addr
mov r11, qword [rbp]
SHIFT_FRAME_23:
mov r15, rbp
sub r15, 8 ; r15= adress in stack of first to move up
mov qword r14, [rbp + 8*3] ; r14=n
add r14, 4
shl r14, 3
add r14, rbp ; r14 = rbp+ 8*(4+n) , which is the adress we should overide first
; we are moving top down:
.loop_of_shifts:
  cmp r15, rsp
  jl .end_loop_of_shifts ; we finished
  mov qword r12, [r15]; r12 = element to move
  mov qword [r14], r12 ; move elemnt to top of stack
  sub r14, 8
  sub r15, 8
  jmp .loop_of_shifts
.end_loop_of_shifts:
  add r14, 8
  mov rsp, r14
  mov rbp, r11
  jmp qword [rax+9] ; jump to code ptr
 
leave
ret
Lcont_30:
mov qword [fvar_tbl+ (8* 18)], rax ;mov value 
mov rax, SOB_VOID_ADDRESS
;we know that env = [rbp + 8*2]
; we know that depth is env.length
; now we SHOULD allocate extenv with size env.length+1= depth+1
MALLOC rax, 8*(1+2) ; rax->extEnv
mov rbx, 0 ;i
mov rcx, 1 ;j
;following loop is to shift the env in extended env
loop_61:
    cmp rbx, 2
    jge end_loop_61
    mov rdx, [rbp + 8*2] ; rdx = env
    shl rbx, 3
    add rdx, rbx ; env[i] =-->[var, var,...var] 
    shr rbx, 3
    mov r8, [rdx] 
    mov [rax + 8*rcx], r8 ; extEnv[j]=env[i]
    inc rcx
    inc rbx
    jmp loop_61
end_loop_61:
 ;  rax holds ->extEnv
;n= [rbp+8*3]
mov rbx, rax ;rbx holds extEnv
; Allocate ExtEnv[0] to point to a vector where to store the parameters
mov r8, [rbp+8*3] ; r8= n
inc r8; +magic
shl r8, 3
MALLOC r9, r8 ; r9 holds the vector for the params with size 8*n +1 for magic
shr r8, 3
dec r8; - magic
mov rcx, 0 ;i=0
;following loop is to Copy the parameters off of the stack to the extended env:
loop_62:
    cmp rcx ,r8 ; i<n
    jge end_loop_62
    mov rdx, [rbp+8*(4+rcx)] ;  rdx= param_i
    mov [r9+8*rcx], rdx ; ExtEnv [0][i]= param_i
    inc rcx
    jmp loop_62
end_loop_62:
mov qword [r9+8*rcx], SOB_NIL_ADDRESS; add magic to the end
mov [rbx], r9 ; updte the extEnv[0]-> vector that we created for the params

MAKE_CLOSURE(rax, rbx, Lcode_31)
 jmp Lcont_31
Lcode_31:
mov rdx, rsp ; rdx hold cur stack ptr ==> [rdx]= ret_adr etc... (i chose rdx because cons does'nt overide it)
mov r8, [rdx+8*2] ; r8= arg_count 
cmp r8, 1 ; compare arg_count to the amount we've expected
jl .no_fix_necessery
; else: we need to collect all exses args to a list
mov r9, SOB_NIL_ADDRESS ; r9 holds curr list
mov r10, r8
sub r10, 0 ; r10= lst size= num of opt args
mov r11, r8
dec r11 ; r11 =idx= n-1
.loop_create_lst:
  cmp r11, 0 
  jl .end_loop_create_lst ; end loop if idx<params.lst, which is when we get to the args that arent optional
  mov r13, rsp; r13=sp
  push SOB_NIL_ADDRESS; push magic
  push r9 ; push cdr
  push qword [rdx+8*(3+r11)] ; push arg_idx = car
  push qword 2; argcount= car, cdr
  push qword [rdx+8*1]; env
  call cons
  mov rsp, r13
  mov r9, rax ; r9 hold new lst
  mov r13, [r9+1]; r13=car
  mov r13, [r9+1+8]; r13=cdr
  dec r11 ; idx--
  jmp .loop_create_lst
.end_loop_create_lst:

; now r9 holds list of optional args
mov r13, [rdx+8*(3+r8-1)]; should be last opt arg=3
mov qword [rdx+8*(3+r8-1)], r9 ; set arg_n-1 to be optional
mov qword [rdx+8*2], 1
mov r9, r8  ; r9= n
inc r9  ;r9 = n+1 =3+n-2
shl r9, 3 ;r9= 8*(3+n-2)= idx of last place in stack
mov r11, 0
add r11, 2 
shl r11, 3 ; r11 = 8*(3+ params_len -1) = idx of last mandatory arg = the first element from stack that should be moved up
mov r13, [rdx+r11]; should be 1
; both r11, r9 will be decresed each time by 8
.loop_shift_stack:
  cmp r11, 0
  jl .end_loop_shift_stack
  mov rax, [rdx+r11] ; rax = cur element to move
  mov [rdx+r9], rax ; move to the top of the stack the cur element top down
  sub r9, 8
  sub r11, 8
  jmp .loop_shift_stack
.end_loop_shift_stack:
; now, rdx+r9 holds the last place on stack
add r9, 8
add r9, rdx
mov rsp, r9
.no_fix_necessery:

push rbp
mov rbp , rsp
;applic tp:
push SOB_NIL_ADDRESS ; push magic
mov rax, qword [rbp + 8 *(4 + 0)]
push rax ; calculate arg, rax holds arg, and push it
mov rax, const_tbl+34
push rax ; calculate arg, rax holds arg, and push it
;applic:
         push SOB_NIL_ADDRESS ; push magic
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * (1)]
mov rax, qword [rax + 8 * (6)]
push rax ; calculate arg, rax holds arg, and push it
push 1 ; push argcount
;next is proc:
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * (0)]
mov rax, qword [rax + 8 * (0)]
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
call qword [rax+9] ; call to code ptr
 add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8*rbx]; pop args
add rsp , 8 ; pop magic, which is sob_nil
push rax ; calculate arg, rax holds arg, and push it
push 3 ; push argcount
;next is proc:
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * (1)]
mov rax, qword [rax + 8 * (3)]
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
push qword [rbp + 8 * 1] ; old ret addr
mov r11, qword [rbp]
SHIFT_FRAME_24:
mov r15, rbp
sub r15, 8 ; r15= adress in stack of first to move up
mov qword r14, [rbp + 8*3] ; r14=n
add r14, 4
shl r14, 3
add r14, rbp ; r14 = rbp+ 8*(4+n) , which is the adress we should overide first
; we are moving top down:
.loop_of_shifts:
  cmp r15, rsp
  jl .end_loop_of_shifts ; we finished
  mov qword r12, [r15]; r12 = element to move
  mov qword [r14], r12 ; move elemnt to top of stack
  sub r14, 8
  sub r15, 8
  jmp .loop_of_shifts
.end_loop_of_shifts:
  add r14, 8
  mov rsp, r14
  mov rbp, r11
  jmp qword [rax+9] ; jump to code ptr
 
leave
ret
Lcont_31:
mov qword [fvar_tbl+ (8* 19)], rax ;mov value 
mov rax, SOB_VOID_ADDRESS
;applic:
         push SOB_NIL_ADDRESS ; push magic
;applic:
         push SOB_NIL_ADDRESS ; push magic
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * (0)]
mov rax, qword [rax + 8 * (7)]
push rax ; calculate arg, rax holds arg, and push it
push 1 ; push argcount
;next is proc:
mov rax, qword [rbp + 8 *(4 + 0)]
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
call qword [rax+9] ; call to code ptr
 add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8*rbx]; pop args
add rsp , 8 ; pop magic, which is sob_nil
push rax ; calculate arg, rax holds arg, and push it
push 1 ; push argcount
;next is proc:
;we know that env = [rbp + 8*2]
; we know that depth is env.length
; now we SHOULD allocate extenv with size env.length+1= depth+1
MALLOC rax, 8*(1+2) ; rax->extEnv
mov rbx, 0 ;i
mov rcx, 1 ;j
;following loop is to shift the env in extended env
loop_63:
    cmp rbx, 2
    jge end_loop_63
    mov rdx, [rbp + 8*2] ; rdx = env
    shl rbx, 3
    add rdx, rbx ; env[i] =-->[var, var,...var] 
    shr rbx, 3
    mov r8, [rdx] 
    mov [rax + 8*rcx], r8 ; extEnv[j]=env[i]
    inc rcx
    inc rbx
    jmp loop_63
end_loop_63:
 ;  rax holds ->extEnv
;n= [rbp+8*3]
mov rbx, rax ;rbx holds extEnv
; Allocate ExtEnv[0] to point to a vector where to store the parameters
mov r8, [rbp+8*3] ; r8= n
inc r8; +magic
shl r8, 3
MALLOC r9, r8 ; r9 holds the vector for the params with size 8*n +1 for magic
shr r8, 3
dec r8; - magic
mov rcx, 0 ;i=0
;following loop is to Copy the parameters off of the stack to the extended env:
loop_64:
    cmp rcx ,r8 ; i<n
    jge end_loop_64
    mov rdx, [rbp+8*(4+rcx)] ;  rdx= param_i
    mov [r9+8*rcx], rdx ; ExtEnv [0][i]= param_i
    inc rcx
    jmp loop_64
end_loop_64:
mov qword [r9+8*rcx], SOB_NIL_ADDRESS; add magic to the end
mov [rbx], r9 ; updte the extEnv[0]-> vector that we created for the params

MAKE_CLOSURE(rax, rbx, Lcode_32)
 jmp Lcont_32
Lcode_32:
push rbp
mov rbp , rsp
;we know that env = [rbp + 8*2]
; we know that depth is env.length
; now we SHOULD allocate extenv with size env.length+1= depth+1
MALLOC rax, 8*(1+3) ; rax->extEnv
mov rbx, 0 ;i
mov rcx, 1 ;j
;following loop is to shift the env in extended env
loop_65:
    cmp rbx, 3
    jge end_loop_65
    mov rdx, [rbp + 8*2] ; rdx = env
    shl rbx, 3
    add rdx, rbx ; env[i] =-->[var, var,...var] 
    shr rbx, 3
    mov r8, [rdx] 
    mov [rax + 8*rcx], r8 ; extEnv[j]=env[i]
    inc rcx
    inc rbx
    jmp loop_65
end_loop_65:
 ;  rax holds ->extEnv
;n= [rbp+8*3]
mov rbx, rax ;rbx holds extEnv
; Allocate ExtEnv[0] to point to a vector where to store the parameters
mov r8, [rbp+8*3] ; r8= n
inc r8; +magic
shl r8, 3
MALLOC r9, r8 ; r9 holds the vector for the params with size 8*n +1 for magic
shr r8, 3
dec r8; - magic
mov rcx, 0 ;i=0
;following loop is to Copy the parameters off of the stack to the extended env:
loop_66:
    cmp rcx ,r8 ; i<n
    jge end_loop_66
    mov rdx, [rbp+8*(4+rcx)] ;  rdx= param_i
    mov [r9+8*rcx], rdx ; ExtEnv [0][i]= param_i
    inc rcx
    jmp loop_66
end_loop_66:
mov qword [r9+8*rcx], SOB_NIL_ADDRESS; add magic to the end
mov [rbx], r9 ; updte the extEnv[0]-> vector that we created for the params

MAKE_CLOSURE(rax, rbx, Lcode_33)
 jmp Lcont_33
Lcode_33:
mov rdx, rsp ; rdx hold cur stack ptr ==> [rdx]= ret_adr etc... (i chose rdx because cons does'nt overide it)
mov r8, [rdx+8*2] ; r8= arg_count 
cmp r8, 2 ; compare arg_count to the amount we've expected
jl .no_fix_necessery
; else: we need to collect all exses args to a list
mov r9, SOB_NIL_ADDRESS ; r9 holds curr list
mov r10, r8
sub r10, 1 ; r10= lst size= num of opt args
mov r11, r8
dec r11 ; r11 =idx= n-1
.loop_create_lst:
  cmp r11, 1 
  jl .end_loop_create_lst ; end loop if idx<params.lst, which is when we get to the args that arent optional
  mov r13, rsp; r13=sp
  push SOB_NIL_ADDRESS; push magic
  push r9 ; push cdr
  push qword [rdx+8*(3+r11)] ; push arg_idx = car
  push qword 2; argcount= car, cdr
  push qword [rdx+8*1]; env
  call cons
  mov rsp, r13
  mov r9, rax ; r9 hold new lst
  mov r13, [r9+1]; r13=car
  mov r13, [r9+1+8]; r13=cdr
  dec r11 ; idx--
  jmp .loop_create_lst
.end_loop_create_lst:

; now r9 holds list of optional args
mov r13, [rdx+8*(3+r8-1)]; should be last opt arg=3
mov qword [rdx+8*(3+r8-1)], r9 ; set arg_n-1 to be optional
mov qword [rdx+8*2], 2
mov r9, r8  ; r9= n
inc r9  ;r9 = n+1 =3+n-2
shl r9, 3 ;r9= 8*(3+n-2)= idx of last place in stack
mov r11, 1
add r11, 2 
shl r11, 3 ; r11 = 8*(3+ params_len -1) = idx of last mandatory arg = the first element from stack that should be moved up
mov r13, [rdx+r11]; should be 1
; both r11, r9 will be decresed each time by 8
.loop_shift_stack:
  cmp r11, 0
  jl .end_loop_shift_stack
  mov rax, [rdx+r11] ; rax = cur element to move
  mov [rdx+r9], rax ; move to the top of the stack the cur element top down
  sub r9, 8
  sub r11, 8
  jmp .loop_shift_stack
.end_loop_shift_stack:
; now, rdx+r9 holds the last place on stack
add r9, 8
add r9, rdx
mov rsp, r9
.no_fix_necessery:

push rbp
mov rbp , rsp
;applic:
         push SOB_NIL_ADDRESS ; push magic
mov rax, qword [rbp + 8 *(4 + 1)]
push rax ; calculate arg, rax holds arg, and push it
push 1 ; push argcount
;next is proc:
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * (2)]
mov rax, qword [rax + 8 * (12)]
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
call qword [rax+9] ; call to code ptr
 add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8*rbx]; pop args
add rsp , 8 ; pop magic, which is sob_nil
cmp rax, SOB_FALSE_ADDRESS
je Lelse_15
;applic tp:
push SOB_NIL_ADDRESS ; push magic
mov rax, qword [rbp + 8 *(4 + 0)]
push rax ; calculate arg, rax holds arg, and push it
mov rax, const_tbl+34
push rax ; calculate arg, rax holds arg, and push it
push 2 ; push argcount
;next is proc:
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * (0)]
mov rax, qword [rax + 8 * (0)]
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
push qword [rbp + 8 * 1] ; old ret addr
mov r11, qword [rbp]
SHIFT_FRAME_26:
mov r15, rbp
sub r15, 8 ; r15= adress in stack of first to move up
mov qword r14, [rbp + 8*3] ; r14=n
add r14, 4
shl r14, 3
add r14, rbp ; r14 = rbp+ 8*(4+n) , which is the adress we should overide first
; we are moving top down:
.loop_of_shifts:
  cmp r15, rsp
  jl .end_loop_of_shifts ; we finished
  mov qword r12, [r15]; r12 = element to move
  mov qword [r14], r12 ; move elemnt to top of stack
  sub r14, 8
  sub r15, 8
  jmp .loop_of_shifts
.end_loop_of_shifts:
  add r14, 8
  mov rsp, r14
  mov rbp, r11
  jmp qword [rax+9] ; jump to code ptr
 jmp Lexit_15
Lelse_15:
;applic tp:
push SOB_NIL_ADDRESS ; push magic
mov rax, qword [rbp + 8 *(4 + 1)]
push rax ; calculate arg, rax holds arg, and push it
mov rax, qword [rbp + 8 *(4 + 0)]
push rax ; calculate arg, rax holds arg, and push it
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * (0)]
mov rax, qword [rax + 8 * (0)]
push rax ; calculate arg, rax holds arg, and push it
push 3 ; push argcount
;next is proc:
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * (2)]
mov rax, qword [rax + 8 * (3)]
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
push qword [rbp + 8 * 1] ; old ret addr
mov r11, qword [rbp]
SHIFT_FRAME_25:
mov r15, rbp
sub r15, 8 ; r15= adress in stack of first to move up
mov qword r14, [rbp + 8*3] ; r14=n
add r14, 4
shl r14, 3
add r14, rbp ; r14 = rbp+ 8*(4+n) , which is the adress we should overide first
; we are moving top down:
.loop_of_shifts:
  cmp r15, rsp
  jl .end_loop_of_shifts ; we finished
  mov qword r12, [r15]; r12 = element to move
  mov qword [r14], r12 ; move elemnt to top of stack
  sub r14, 8
  sub r15, 8
  jmp .loop_of_shifts
.end_loop_of_shifts:
  add r14, 8
  mov rsp, r14
  mov rbp, r11
  jmp qword [rax+9] ; jump to code ptr
 Lexit_15:

leave
ret
Lcont_33:

leave
ret
Lcont_32:
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
call qword [rax+9] ; call to code ptr
 add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8*rbx]; pop args
add rsp , 8 ; pop magic, which is sob_nil
mov qword [fvar_tbl+ (8* 20)], rax ;mov value 
mov rax, SOB_VOID_ADDRESS
;applic tp:
push SOB_NIL_ADDRESS ; push magic
;we know that env = [rbp + 8*2]
; we know that depth is env.length
; now we SHOULD allocate extenv with size env.length+1= depth+1
MALLOC rax, 8*(1+2) ; rax->extEnv
mov rbx, 0 ;i
mov rcx, 1 ;j
;following loop is to shift the env in extended env
loop_67:
    cmp rbx, 2
    jge end_loop_67
    mov rdx, [rbp + 8*2] ; rdx = env
    shl rbx, 3
    add rdx, rbx ; env[i] =-->[var, var,...var] 
    shr rbx, 3
    mov r8, [rdx] 
    mov [rax + 8*rcx], r8 ; extEnv[j]=env[i]
    inc rcx
    inc rbx
    jmp loop_67
end_loop_67:
 ;  rax holds ->extEnv
;n= [rbp+8*3]
mov rbx, rax ;rbx holds extEnv
; Allocate ExtEnv[0] to point to a vector where to store the parameters
mov r8, [rbp+8*3] ; r8= n
inc r8; +magic
shl r8, 3
MALLOC r9, r8 ; r9 holds the vector for the params with size 8*n +1 for magic
shr r8, 3
dec r8; - magic
mov rcx, 0 ;i=0
;following loop is to Copy the parameters off of the stack to the extended env:
loop_68:
    cmp rcx ,r8 ; i<n
    jge end_loop_68
    mov rdx, [rbp+8*(4+rcx)] ;  rdx= param_i
    mov [r9+8*rcx], rdx ; ExtEnv [0][i]= param_i
    inc rcx
    jmp loop_68
end_loop_68:
mov qword [r9+8*rcx], SOB_NIL_ADDRESS; add magic to the end
mov [rbx], r9 ; updte the extEnv[0]-> vector that we created for the params

MAKE_CLOSURE(rax, rbx, Lcode_34)
 jmp Lcont_34
Lcode_34:
push rbp
mov rbp , rsp
;applic tp:
push SOB_NIL_ADDRESS ; push magic
mov rax, const_tbl+23
push rax ; calculate arg, rax holds arg, and push it
push 1 ; push argcount
;next is proc:
;we know that env = [rbp + 8*2]
; we know that depth is env.length
; now we SHOULD allocate extenv with size env.length+1= depth+1
MALLOC rax, 8*(1+3) ; rax->extEnv
mov rbx, 0 ;i
mov rcx, 1 ;j
;following loop is to shift the env in extended env
loop_69:
    cmp rbx, 3
    jge end_loop_69
    mov rdx, [rbp + 8*2] ; rdx = env
    shl rbx, 3
    add rdx, rbx ; env[i] =-->[var, var,...var] 
    shr rbx, 3
    mov r8, [rdx] 
    mov [rax + 8*rcx], r8 ; extEnv[j]=env[i]
    inc rcx
    inc rbx
    jmp loop_69
end_loop_69:
 ;  rax holds ->extEnv
;n= [rbp+8*3]
mov rbx, rax ;rbx holds extEnv
; Allocate ExtEnv[0] to point to a vector where to store the parameters
mov r8, [rbp+8*3] ; r8= n
inc r8; +magic
shl r8, 3
MALLOC r9, r8 ; r9 holds the vector for the params with size 8*n +1 for magic
shr r8, 3
dec r8; - magic
mov rcx, 0 ;i=0
;following loop is to Copy the parameters off of the stack to the extended env:
loop_70:
    cmp rcx ,r8 ; i<n
    jge end_loop_70
    mov rdx, [rbp+8*(4+rcx)] ;  rdx= param_i
    mov [r9+8*rcx], rdx ; ExtEnv [0][i]= param_i
    inc rcx
    jmp loop_70
end_loop_70:
mov qword [r9+8*rcx], SOB_NIL_ADDRESS; add magic to the end
mov [rbx], r9 ; updte the extEnv[0]-> vector that we created for the params

MAKE_CLOSURE(rax, rbx, Lcode_35)
 jmp Lcont_35
Lcode_35:
push rbp
mov rbp , rsp
MALLOC rax, 8
mov rbx, qword[rbp+ 8*(4+0)]
mov [rax], rbx
mov qword [rbp + 8 * (4 + (0))],rax
mov rax, SOB_VOID_ADDRESS
;we know that env = [rbp + 8*2]
; we know that depth is env.length
; now we SHOULD allocate extenv with size env.length+1= depth+1
MALLOC rax, 8*(1+4) ; rax->extEnv
mov rbx, 0 ;i
mov rcx, 1 ;j
;following loop is to shift the env in extended env
loop_71:
    cmp rbx, 4
    jge end_loop_71
    mov rdx, [rbp + 8*2] ; rdx = env
    shl rbx, 3
    add rdx, rbx ; env[i] =-->[var, var,...var] 
    shr rbx, 3
    mov r8, [rdx] 
    mov [rax + 8*rcx], r8 ; extEnv[j]=env[i]
    inc rcx
    inc rbx
    jmp loop_71
end_loop_71:
 ;  rax holds ->extEnv
;n= [rbp+8*3]
mov rbx, rax ;rbx holds extEnv
; Allocate ExtEnv[0] to point to a vector where to store the parameters
mov r8, [rbp+8*3] ; r8= n
inc r8; +magic
shl r8, 3
MALLOC r9, r8 ; r9 holds the vector for the params with size 8*n +1 for magic
shr r8, 3
dec r8; - magic
mov rcx, 0 ;i=0
;following loop is to Copy the parameters off of the stack to the extended env:
loop_72:
    cmp rcx ,r8 ; i<n
    jge end_loop_72
    mov rdx, [rbp+8*(4+rcx)] ;  rdx= param_i
    mov [r9+8*rcx], rdx ; ExtEnv [0][i]= param_i
    inc rcx
    jmp loop_72
end_loop_72:
mov qword [r9+8*rcx], SOB_NIL_ADDRESS; add magic to the end
mov [rbx], r9 ; updte the extEnv[0]-> vector that we created for the params

MAKE_CLOSURE(rax, rbx, Lcode_36)
 jmp Lcont_36
Lcode_36:
push rbp
mov rbp , rsp
;applic:
         push SOB_NIL_ADDRESS ; push magic
mov rax, qword [rbp + 8 *(4 + 1)]
push rax ; calculate arg, rax holds arg, and push it
push 1 ; push argcount
;next is proc:
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * (3)]
mov rax, qword [rax + 8 * (12)]
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
call qword [rax+9] ; call to code ptr
 add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8*rbx]; pop args
add rsp , 8 ; pop magic, which is sob_nil
cmp rax, SOB_FALSE_ADDRESS
jne Lexit_Or_2
;applic:
         push SOB_NIL_ADDRESS ; push magic
;applic:
         push SOB_NIL_ADDRESS ; push magic
mov rax, qword [rbp + 8 *(4 + 1)]
push rax ; calculate arg, rax holds arg, and push it
push 1 ; push argcount
;next is proc:
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * (3)]
mov rax, qword [rax + 8 * (10)]
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
call qword [rax+9] ; call to code ptr
 add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8*rbx]; pop args
add rsp , 8 ; pop magic, which is sob_nil
push rax ; calculate arg, rax holds arg, and push it
mov rax, qword [rbp + 8 *(4 + 0)]
push rax ; calculate arg, rax holds arg, and push it
push 2 ; push argcount
;next is proc:
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * (1)]
mov rax, qword [rax + 8 * (0)]
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
call qword [rax+9] ; call to code ptr
 add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8*rbx]; pop args
add rsp , 8 ; pop magic, which is sob_nil
cmp rax, SOB_FALSE_ADDRESS
je Lelse_16
;applic tp:
push SOB_NIL_ADDRESS ; push magic
;applic:
         push SOB_NIL_ADDRESS ; push magic
mov rax, qword [rbp + 8 *(4 + 1)]
push rax ; calculate arg, rax holds arg, and push it
push 1 ; push argcount
;next is proc:
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * (3)]
mov rax, qword [rax + 8 * (11)]
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
call qword [rax+9] ; call to code ptr
 add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8*rbx]; pop args
add rsp , 8 ; pop magic, which is sob_nil
push rax ; calculate arg, rax holds arg, and push it
;applic:
         push SOB_NIL_ADDRESS ; push magic
mov rax, qword [rbp + 8 *(4 + 1)]
push rax ; calculate arg, rax holds arg, and push it
push 1 ; push argcount
;next is proc:
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * (3)]
mov rax, qword [rax + 8 * (10)]
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
call qword [rax+9] ; call to code ptr
 add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8*rbx]; pop args
add rsp , 8 ; pop magic, which is sob_nil
push rax ; calculate arg, rax holds arg, and push it
push 2 ; push argcount
;next is proc:
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * (0)]
mov rax, qword [rax + 8 * (0)]
mov rax, qword [rax]
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
push qword [rbp + 8 * 1] ; old ret addr
mov r11, qword [rbp]
SHIFT_FRAME_29:
mov r15, rbp
sub r15, 8 ; r15= adress in stack of first to move up
mov qword r14, [rbp + 8*3] ; r14=n
add r14, 4
shl r14, 3
add r14, rbp ; r14 = rbp+ 8*(4+n) , which is the adress we should overide first
; we are moving top down:
.loop_of_shifts:
  cmp r15, rsp
  jl .end_loop_of_shifts ; we finished
  mov qword r12, [r15]; r12 = element to move
  mov qword [r14], r12 ; move elemnt to top of stack
  sub r14, 8
  sub r15, 8
  jmp .loop_of_shifts
.end_loop_of_shifts:
  add r14, 8
  mov rsp, r14
  mov rbp, r11
  jmp qword [rax+9] ; jump to code ptr
 jmp Lexit_16
Lelse_16:
mov rax, const_tbl+2
Lexit_16:
Lexit_Or_2:

leave
ret
Lcont_36:
push rax
mov rax, qword [rbp + 8 *(4 + 0)]
pop qword [rax]
mov rax, SOB_VOID_ADDRESS
;we know that env = [rbp + 8*2]
; we know that depth is env.length
; now we SHOULD allocate extenv with size env.length+1= depth+1
MALLOC rax, 8*(1+4) ; rax->extEnv
mov rbx, 0 ;i
mov rcx, 1 ;j
;following loop is to shift the env in extended env
loop_73:
    cmp rbx, 4
    jge end_loop_73
    mov rdx, [rbp + 8*2] ; rdx = env
    shl rbx, 3
    add rdx, rbx ; env[i] =-->[var, var,...var] 
    shr rbx, 3
    mov r8, [rdx] 
    mov [rax + 8*rcx], r8 ; extEnv[j]=env[i]
    inc rcx
    inc rbx
    jmp loop_73
end_loop_73:
 ;  rax holds ->extEnv
;n= [rbp+8*3]
mov rbx, rax ;rbx holds extEnv
; Allocate ExtEnv[0] to point to a vector where to store the parameters
mov r8, [rbp+8*3] ; r8= n
inc r8; +magic
shl r8, 3
MALLOC r9, r8 ; r9 holds the vector for the params with size 8*n +1 for magic
shr r8, 3
dec r8; - magic
mov rcx, 0 ;i=0
;following loop is to Copy the parameters off of the stack to the extended env:
loop_74:
    cmp rcx ,r8 ; i<n
    jge end_loop_74
    mov rdx, [rbp+8*(4+rcx)] ;  rdx= param_i
    mov [r9+8*rcx], rdx ; ExtEnv [0][i]= param_i
    inc rcx
    jmp loop_74
end_loop_74:
mov qword [r9+8*rcx], SOB_NIL_ADDRESS; add magic to the end
mov [rbx], r9 ; updte the extEnv[0]-> vector that we created for the params

MAKE_CLOSURE(rax, rbx, Lcode_37)
 jmp Lcont_37
Lcode_37:
mov rdx, rsp ; rdx hold cur stack ptr ==> [rdx]= ret_adr etc... (i chose rdx because cons does'nt overide it)
mov r8, [rdx+8*2] ; r8= arg_count 
cmp r8, 2 ; compare arg_count to the amount we've expected
jl .no_fix_necessery
; else: we need to collect all exses args to a list
mov r9, SOB_NIL_ADDRESS ; r9 holds curr list
mov r10, r8
sub r10, 1 ; r10= lst size= num of opt args
mov r11, r8
dec r11 ; r11 =idx= n-1
.loop_create_lst:
  cmp r11, 1 
  jl .end_loop_create_lst ; end loop if idx<params.lst, which is when we get to the args that arent optional
  mov r13, rsp; r13=sp
  push SOB_NIL_ADDRESS; push magic
  push r9 ; push cdr
  push qword [rdx+8*(3+r11)] ; push arg_idx = car
  push qword 2; argcount= car, cdr
  push qword [rdx+8*1]; env
  call cons
  mov rsp, r13
  mov r9, rax ; r9 hold new lst
  mov r13, [r9+1]; r13=car
  mov r13, [r9+1+8]; r13=cdr
  dec r11 ; idx--
  jmp .loop_create_lst
.end_loop_create_lst:

; now r9 holds list of optional args
mov r13, [rdx+8*(3+r8-1)]; should be last opt arg=3
mov qword [rdx+8*(3+r8-1)], r9 ; set arg_n-1 to be optional
mov qword [rdx+8*2], 2
mov r9, r8  ; r9= n
inc r9  ;r9 = n+1 =3+n-2
shl r9, 3 ;r9= 8*(3+n-2)= idx of last place in stack
mov r11, 1
add r11, 2 
shl r11, 3 ; r11 = 8*(3+ params_len -1) = idx of last mandatory arg = the first element from stack that should be moved up
mov r13, [rdx+r11]; should be 1
; both r11, r9 will be decresed each time by 8
.loop_shift_stack:
  cmp r11, 0
  jl .end_loop_shift_stack
  mov rax, [rdx+r11] ; rax = cur element to move
  mov [rdx+r9], rax ; move to the top of the stack the cur element top down
  sub r9, 8
  sub r11, 8
  jmp .loop_shift_stack
.end_loop_shift_stack:
; now, rdx+r9 holds the last place on stack
add r9, 8
add r9, rdx
mov rsp, r9
.no_fix_necessery:

push rbp
mov rbp , rsp
;applic tp:
push SOB_NIL_ADDRESS ; push magic
mov rax, qword [rbp + 8 *(4 + 1)]
push rax ; calculate arg, rax holds arg, and push it
mov rax, qword [rbp + 8 *(4 + 0)]
push rax ; calculate arg, rax holds arg, and push it
push 2 ; push argcount
;next is proc:
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * (0)]
mov rax, qword [rax + 8 * (0)]
mov rax, qword [rax]
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
push qword [rbp + 8 * 1] ; old ret addr
mov r11, qword [rbp]
SHIFT_FRAME_30:
mov r15, rbp
sub r15, 8 ; r15= adress in stack of first to move up
mov qword r14, [rbp + 8*3] ; r14=n
add r14, 4
shl r14, 3
add r14, rbp ; r14 = rbp+ 8*(4+n) , which is the adress we should overide first
; we are moving top down:
.loop_of_shifts:
  cmp r15, rsp
  jl .end_loop_of_shifts ; we finished
  mov qword r12, [r15]; r12 = element to move
  mov qword [r14], r12 ; move elemnt to top of stack
  sub r14, 8
  sub r15, 8
  jmp .loop_of_shifts
.end_loop_of_shifts:
  add r14, 8
  mov rsp, r14
  mov rbp, r11
  jmp qword [rax+9] ; jump to code ptr
 
leave
ret
Lcont_37:

leave
ret
Lcont_35:
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
push qword [rbp + 8 * 1] ; old ret addr
mov r11, qword [rbp]
SHIFT_FRAME_28:
mov r15, rbp
sub r15, 8 ; r15= adress in stack of first to move up
mov qword r14, [rbp + 8*3] ; r14=n
add r14, 4
shl r14, 3
add r14, rbp ; r14 = rbp+ 8*(4+n) , which is the adress we should overide first
; we are moving top down:
.loop_of_shifts:
  cmp r15, rsp
  jl .end_loop_of_shifts ; we finished
  mov qword r12, [r15]; r12 = element to move
  mov qword [r14], r12 ; move elemnt to top of stack
  sub r14, 8
  sub r15, 8
  jmp .loop_of_shifts
.end_loop_of_shifts:
  add r14, 8
  mov rsp, r14
  mov rbp, r11
  jmp qword [rax+9] ; jump to code ptr
 
leave
ret
Lcont_34:
push rax ; calculate arg, rax holds arg, and push it
push 1 ; push argcount
;next is proc:
;we know that env = [rbp + 8*2]
; we know that depth is env.length
; now we SHOULD allocate extenv with size env.length+1= depth+1
MALLOC rax, 8*(1+2) ; rax->extEnv
mov rbx, 0 ;i
mov rcx, 1 ;j
;following loop is to shift the env in extended env
loop_75:
    cmp rbx, 2
    jge end_loop_75
    mov rdx, [rbp + 8*2] ; rdx = env
    shl rbx, 3
    add rdx, rbx ; env[i] =-->[var, var,...var] 
    shr rbx, 3
    mov r8, [rdx] 
    mov [rax + 8*rcx], r8 ; extEnv[j]=env[i]
    inc rcx
    inc rbx
    jmp loop_75
end_loop_75:
 ;  rax holds ->extEnv
;n= [rbp+8*3]
mov rbx, rax ;rbx holds extEnv
; Allocate ExtEnv[0] to point to a vector where to store the parameters
mov r8, [rbp+8*3] ; r8= n
inc r8; +magic
shl r8, 3
MALLOC r9, r8 ; r9 holds the vector for the params with size 8*n +1 for magic
shr r8, 3
dec r8; - magic
mov rcx, 0 ;i=0
;following loop is to Copy the parameters off of the stack to the extended env:
loop_76:
    cmp rcx ,r8 ; i<n
    jge end_loop_76
    mov rdx, [rbp+8*(4+rcx)] ;  rdx= param_i
    mov [r9+8*rcx], rdx ; ExtEnv [0][i]= param_i
    inc rcx
    jmp loop_76
end_loop_76:
mov qword [r9+8*rcx], SOB_NIL_ADDRESS; add magic to the end
mov [rbx], r9 ; updte the extEnv[0]-> vector that we created for the params

MAKE_CLOSURE(rax, rbx, Lcode_38)
 jmp Lcont_38
Lcode_38:
push rbp
mov rbp , rsp
;applic:
         push SOB_NIL_ADDRESS ; push magic
;applic:
         push SOB_NIL_ADDRESS ; push magic
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * (1)]
mov rax, qword [rax + 8 * (8)]
push rax ; calculate arg, rax holds arg, and push it
push 1 ; push argcount
;next is proc:
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * (0)]
mov rax, qword [rax + 8 * (0)]
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
call qword [rax+9] ; call to code ptr
 add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8*rbx]; pop args
add rsp , 8 ; pop magic, which is sob_nil
push rax ; calculate arg, rax holds arg, and push it
push 1 ; push argcount
;next is proc:
mov rax, qword [rbp + 8 *(4 + 0)]
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
call qword [rax+9] ; call to code ptr
 add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8*rbx]; pop args
add rsp , 8 ; pop magic, which is sob_nil
mov qword [fvar_tbl+ (8* 21)], rax ;mov value 
mov rax, SOB_VOID_ADDRESS
;applic:
         push SOB_NIL_ADDRESS ; push magic
;applic:
         push SOB_NIL_ADDRESS ; push magic
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * (1)]
mov rax, qword [rax + 8 * (9)]
push rax ; calculate arg, rax holds arg, and push it
push 1 ; push argcount
;next is proc:
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * (0)]
mov rax, qword [rax + 8 * (0)]
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
call qword [rax+9] ; call to code ptr
 add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8*rbx]; pop args
add rsp , 8 ; pop magic, which is sob_nil
push rax ; calculate arg, rax holds arg, and push it
push 1 ; push argcount
;next is proc:
mov rax, qword [rbp + 8 *(4 + 0)]
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
call qword [rax+9] ; call to code ptr
 add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8*rbx]; pop args
add rsp , 8 ; pop magic, which is sob_nil
mov qword [fvar_tbl+ (8* 22)], rax ;mov value 
mov rax, SOB_VOID_ADDRESS

leave
ret
Lcont_38:
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
push qword [rbp + 8 * 1] ; old ret addr
mov r11, qword [rbp]
SHIFT_FRAME_27:
mov r15, rbp
sub r15, 8 ; r15= adress in stack of first to move up
mov qword r14, [rbp + 8*3] ; r14=n
add r14, 4
shl r14, 3
add r14, rbp ; r14 = rbp+ 8*(4+n) , which is the adress we should overide first
; we are moving top down:
.loop_of_shifts:
  cmp r15, rsp
  jl .end_loop_of_shifts ; we finished
  mov qword r12, [r15]; r12 = element to move
  mov qword [r14], r12 ; move elemnt to top of stack
  sub r14, 8
  sub r15, 8
  jmp .loop_of_shifts
.end_loop_of_shifts:
  add r14, 8
  mov rsp, r14
  mov rbp, r11
  jmp qword [rax+9] ; jump to code ptr
 
leave
ret
Lcont_29:
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
push qword [rbp + 8 * 1] ; old ret addr
mov r11, qword [rbp]
SHIFT_FRAME_19:
mov r15, rbp
sub r15, 8 ; r15= adress in stack of first to move up
mov qword r14, [rbp + 8*3] ; r14=n
add r14, 4
shl r14, 3
add r14, rbp ; r14 = rbp+ 8*(4+n) , which is the adress we should overide first
; we are moving top down:
.loop_of_shifts:
  cmp r15, rsp
  jl .end_loop_of_shifts ; we finished
  mov qword r12, [r15]; r12 = element to move
  mov qword [r14], r12 ; move elemnt to top of stack
  sub r14, 8
  sub r15, 8
  jmp .loop_of_shifts
.end_loop_of_shifts:
  add r14, 8
  mov rsp, r14
  mov rbp, r11
  jmp qword [rax+9] ; jump to code ptr
 
leave
ret
Lcont_26:
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
call qword [rax+9] ; call to code ptr
 add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8*rbx]; pop args
add rsp , 8 ; pop magic, which is sob_nil

	call write_sob_if_not_void

;applic:
         push SOB_NIL_ADDRESS ; push magic
mov rax, [fvar_tbl+ (8* 4)]
push rax ; calculate arg, rax holds arg, and push it
mov rax, [fvar_tbl+ (8* 18)]
push rax ; calculate arg, rax holds arg, and push it
mov rax, [fvar_tbl+ (8* 27)]
push rax ; calculate arg, rax holds arg, and push it
push 3 ; push argcount
;next is proc:
;we know that env = [rbp + 8*2]
; we know that depth is env.length
; now we SHOULD allocate extenv with size env.length+1= depth+1
MALLOC rax, 8*(1+0) ; rax->extEnv
mov rbx, 0 ;i
mov rcx, 1 ;j
;following loop is to shift the env in extended env
loop_77:
    cmp rbx, 0
    jge end_loop_77
    mov rdx, [rbp + 8*2] ; rdx = env
    shl rbx, 3
    add rdx, rbx ; env[i] =-->[var, var,...var] 
    shr rbx, 3
    mov r8, [rdx] 
    mov [rax + 8*rcx], r8 ; extEnv[j]=env[i]
    inc rcx
    inc rbx
    jmp loop_77
end_loop_77:
 ;  rax holds ->extEnv
;n= [rbp+8*3]
mov rbx, rax ;rbx holds extEnv
; Allocate ExtEnv[0] to point to a vector where to store the parameters
mov r8, [rbp+8*3] ; r8= n
inc r8; +magic
shl r8, 3
MALLOC r9, r8 ; r9 holds the vector for the params with size 8*n +1 for magic
shr r8, 3
dec r8; - magic
mov rcx, 0 ;i=0
;following loop is to Copy the parameters off of the stack to the extended env:
loop_78:
    cmp rcx ,r8 ; i<n
    jge end_loop_78
    mov rdx, [rbp+8*(4+rcx)] ;  rdx= param_i
    mov [r9+8*rcx], rdx ; ExtEnv [0][i]= param_i
    inc rcx
    jmp loop_78
end_loop_78:
mov qword [r9+8*rcx], SOB_NIL_ADDRESS; add magic to the end
mov [rbx], r9 ; updte the extEnv[0]-> vector that we created for the params

MAKE_CLOSURE(rax, rbx, Lcode_39)
 jmp Lcont_39
Lcode_39:
push rbp
mov rbp , rsp
;we know that env = [rbp + 8*2]
; we know that depth is env.length
; now we SHOULD allocate extenv with size env.length+1= depth+1
MALLOC rax, 8*(1+1) ; rax->extEnv
mov rbx, 0 ;i
mov rcx, 1 ;j
;following loop is to shift the env in extended env
loop_79:
    cmp rbx, 1
    jge end_loop_79
    mov rdx, [rbp + 8*2] ; rdx = env
    shl rbx, 3
    add rdx, rbx ; env[i] =-->[var, var,...var] 
    shr rbx, 3
    mov r8, [rdx] 
    mov [rax + 8*rcx], r8 ; extEnv[j]=env[i]
    inc rcx
    inc rbx
    jmp loop_79
end_loop_79:
 ;  rax holds ->extEnv
;n= [rbp+8*3]
mov rbx, rax ;rbx holds extEnv
; Allocate ExtEnv[0] to point to a vector where to store the parameters
mov r8, [rbp+8*3] ; r8= n
inc r8; +magic
shl r8, 3
MALLOC r9, r8 ; r9 holds the vector for the params with size 8*n +1 for magic
shr r8, 3
dec r8; - magic
mov rcx, 0 ;i=0
;following loop is to Copy the parameters off of the stack to the extended env:
loop_80:
    cmp rcx ,r8 ; i<n
    jge end_loop_80
    mov rdx, [rbp+8*(4+rcx)] ;  rdx= param_i
    mov [r9+8*rcx], rdx ; ExtEnv [0][i]= param_i
    inc rcx
    jmp loop_80
end_loop_80:
mov qword [r9+8*rcx], SOB_NIL_ADDRESS; add magic to the end
mov [rbx], r9 ; updte the extEnv[0]-> vector that we created for the params

MAKE_CLOSURE(rax, rbx, Lcode_40)
 jmp Lcont_40
Lcode_40:
mov rdx, rsp ; rdx hold cur stack ptr ==> [rdx]= ret_adr etc... (i chose rdx because cons does'nt overide it)
mov r8, [rdx+8*2] ; r8= arg_count 
cmp r8, 2 ; compare arg_count to the amount we've expected
jl .no_fix_necessery
; else: we need to collect all exses args to a list
mov r9, SOB_NIL_ADDRESS ; r9 holds curr list
mov r10, r8
sub r10, 1 ; r10= lst size= num of opt args
mov r11, r8
dec r11 ; r11 =idx= n-1
.loop_create_lst:
  cmp r11, 1 
  jl .end_loop_create_lst ; end loop if idx<params.lst, which is when we get to the args that arent optional
  mov r13, rsp; r13=sp
  push SOB_NIL_ADDRESS; push magic
  push r9 ; push cdr
  push qword [rdx+8*(3+r11)] ; push arg_idx = car
  push qword 2; argcount= car, cdr
  push qword [rdx+8*1]; env
  call cons
  mov rsp, r13
  mov r9, rax ; r9 hold new lst
  mov r13, [r9+1]; r13=car
  mov r13, [r9+1+8]; r13=cdr
  dec r11 ; idx--
  jmp .loop_create_lst
.end_loop_create_lst:

; now r9 holds list of optional args
mov r13, [rdx+8*(3+r8-1)]; should be last opt arg=3
mov qword [rdx+8*(3+r8-1)], r9 ; set arg_n-1 to be optional
mov qword [rdx+8*2], 2
mov r9, r8  ; r9= n
inc r9  ;r9 = n+1 =3+n-2
shl r9, 3 ;r9= 8*(3+n-2)= idx of last place in stack
mov r11, 1
add r11, 2 
shl r11, 3 ; r11 = 8*(3+ params_len -1) = idx of last mandatory arg = the first element from stack that should be moved up
mov r13, [rdx+r11]; should be 1
; both r11, r9 will be decresed each time by 8
.loop_shift_stack:
  cmp r11, 0
  jl .end_loop_shift_stack
  mov rax, [rdx+r11] ; rax = cur element to move
  mov [rdx+r9], rax ; move to the top of the stack the cur element top down
  sub r9, 8
  sub r11, 8
  jmp .loop_shift_stack
.end_loop_shift_stack:
; now, rdx+r9 holds the last place on stack
add r9, 8
add r9, rdx
mov rsp, r9
.no_fix_necessery:

push rbp
mov rbp , rsp
;applic:
         push SOB_NIL_ADDRESS ; push magic
mov rax, qword [rbp + 8 *(4 + 1)]
push rax ; calculate arg, rax holds arg, and push it
push 1 ; push argcount
;next is proc:
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * (0)]
mov rax, qword [rax + 8 * (2)]
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
call qword [rax+9] ; call to code ptr
 add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8*rbx]; pop args
add rsp , 8 ; pop magic, which is sob_nil
cmp rax, SOB_FALSE_ADDRESS
je Lelse_17
;applic tp:
push SOB_NIL_ADDRESS ; push magic
;applic:
         push SOB_NIL_ADDRESS ; push magic
mov rax, qword [rbp + 8 *(4 + 0)]
push rax ; calculate arg, rax holds arg, and push it
mov rax, const_tbl+68
push rax ; calculate arg, rax holds arg, and push it
push 2 ; push argcount
;next is proc:
mov rax, [fvar_tbl+ (8* 19)]
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
call qword [rax+9] ; call to code ptr
 add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8*rbx]; pop args
add rsp , 8 ; pop magic, which is sob_nil
push rax ; calculate arg, rax holds arg, and push it
mov rax, const_tbl+51
push rax ; calculate arg, rax holds arg, and push it
push 2 ; push argcount
;next is proc:
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * (0)]
mov rax, qword [rax + 8 * (1)]
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
push qword [rbp + 8 * 1] ; old ret addr
mov r11, qword [rbp]
SHIFT_FRAME_32:
mov r15, rbp
sub r15, 8 ; r15= adress in stack of first to move up
mov qword r14, [rbp + 8*3] ; r14=n
add r14, 4
shl r14, 3
add r14, rbp ; r14 = rbp+ 8*(4+n) , which is the adress we should overide first
; we are moving top down:
.loop_of_shifts:
  cmp r15, rsp
  jl .end_loop_of_shifts ; we finished
  mov qword r12, [r15]; r12 = element to move
  mov qword [r14], r12 ; move elemnt to top of stack
  sub r14, 8
  sub r15, 8
  jmp .loop_of_shifts
.end_loop_of_shifts:
  add r14, 8
  mov rsp, r14
  mov rbp, r11
  jmp qword [rax+9] ; jump to code ptr
 jmp Lexit_17
Lelse_17:
;applic tp:
push SOB_NIL_ADDRESS ; push magic
;applic:
         push SOB_NIL_ADDRESS ; push magic
;applic:
         push SOB_NIL_ADDRESS ; push magic
mov rax, qword [rbp + 8 *(4 + 1)]
push rax ; calculate arg, rax holds arg, and push it
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * (0)]
mov rax, qword [rax + 8 * (1)]
push rax ; calculate arg, rax holds arg, and push it
push 2 ; push argcount
;next is proc:
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * (0)]
mov rax, qword [rax + 8 * (0)]
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
call qword [rax+9] ; call to code ptr
 add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8*rbx]; pop args
add rsp , 8 ; pop magic, which is sob_nil
push rax ; calculate arg, rax holds arg, and push it
mov rax, const_tbl+68
push rax ; calculate arg, rax holds arg, and push it
push 2 ; push argcount
;next is proc:
mov rax, [fvar_tbl+ (8* 19)]
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
call qword [rax+9] ; call to code ptr
 add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8*rbx]; pop args
add rsp , 8 ; pop magic, which is sob_nil
push rax ; calculate arg, rax holds arg, and push it
mov rax, qword [rbp + 8 *(4 + 0)]
push rax ; calculate arg, rax holds arg, and push it
push 2 ; push argcount
;next is proc:
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * (0)]
mov rax, qword [rax + 8 * (1)]
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
push qword [rbp + 8 * 1] ; old ret addr
mov r11, qword [rbp]
SHIFT_FRAME_31:
mov r15, rbp
sub r15, 8 ; r15= adress in stack of first to move up
mov qword r14, [rbp + 8*3] ; r14=n
add r14, 4
shl r14, 3
add r14, rbp ; r14 = rbp+ 8*(4+n) , which is the adress we should overide first
; we are moving top down:
.loop_of_shifts:
  cmp r15, rsp
  jl .end_loop_of_shifts ; we finished
  mov qword r12, [r15]; r12 = element to move
  mov qword [r14], r12 ; move elemnt to top of stack
  sub r14, 8
  sub r15, 8
  jmp .loop_of_shifts
.end_loop_of_shifts:
  add r14, 8
  mov rsp, r14
  mov rbp, r11
  jmp qword [rax+9] ; jump to code ptr
 Lexit_17:

leave
ret
Lcont_40:

leave
ret
Lcont_39:
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
call qword [rax+9] ; call to code ptr
 add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8*rbx]; pop args
add rsp , 8 ; pop magic, which is sob_nil
mov [fvar_tbl+(8*46)], rax
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void

;applic:
         push SOB_NIL_ADDRESS ; push magic
mov rax, [fvar_tbl+ (8* 21)]
push rax ; calculate arg, rax holds arg, and push it
mov rax, [fvar_tbl+ (8* 22)]
push rax ; calculate arg, rax holds arg, and push it
mov rax, [fvar_tbl+ (8* 29)]
push rax ; calculate arg, rax holds arg, and push it
mov rax, [fvar_tbl+ (8* 28)]
push rax ; calculate arg, rax holds arg, and push it
mov rax, [fvar_tbl+ (8* 40)]
push rax ; calculate arg, rax holds arg, and push it
mov rax, [fvar_tbl+ (8* 4)]
push rax ; calculate arg, rax holds arg, and push it
push 6 ; push argcount
;next is proc:
;we know that env = [rbp + 8*2]
; we know that depth is env.length
; now we SHOULD allocate extenv with size env.length+1= depth+1
MALLOC rax, 8*(1+0) ; rax->extEnv
mov rbx, 0 ;i
mov rcx, 1 ;j
;following loop is to shift the env in extended env
loop_81:
    cmp rbx, 0
    jge end_loop_81
    mov rdx, [rbp + 8*2] ; rdx = env
    shl rbx, 3
    add rdx, rbx ; env[i] =-->[var, var,...var] 
    shr rbx, 3
    mov r8, [rdx] 
    mov [rax + 8*rcx], r8 ; extEnv[j]=env[i]
    inc rcx
    inc rbx
    jmp loop_81
end_loop_81:
 ;  rax holds ->extEnv
;n= [rbp+8*3]
mov rbx, rax ;rbx holds extEnv
; Allocate ExtEnv[0] to point to a vector where to store the parameters
mov r8, [rbp+8*3] ; r8= n
inc r8; +magic
shl r8, 3
MALLOC r9, r8 ; r9 holds the vector for the params with size 8*n +1 for magic
shr r8, 3
dec r8; - magic
mov rcx, 0 ;i=0
;following loop is to Copy the parameters off of the stack to the extended env:
loop_82:
    cmp rcx ,r8 ; i<n
    jge end_loop_82
    mov rdx, [rbp+8*(4+rcx)] ;  rdx= param_i
    mov [r9+8*rcx], rdx ; ExtEnv [0][i]= param_i
    inc rcx
    jmp loop_82
end_loop_82:
mov qword [r9+8*rcx], SOB_NIL_ADDRESS; add magic to the end
mov [rbx], r9 ; updte the extEnv[0]-> vector that we created for the params

MAKE_CLOSURE(rax, rbx, Lcode_41)
 jmp Lcont_41
Lcode_41:
push rbp
mov rbp , rsp
;applic tp:
push SOB_NIL_ADDRESS ; push magic
mov rax, const_tbl+23
push rax ; calculate arg, rax holds arg, and push it
push 1 ; push argcount
;next is proc:
;we know that env = [rbp + 8*2]
; we know that depth is env.length
; now we SHOULD allocate extenv with size env.length+1= depth+1
MALLOC rax, 8*(1+1) ; rax->extEnv
mov rbx, 0 ;i
mov rcx, 1 ;j
;following loop is to shift the env in extended env
loop_83:
    cmp rbx, 1
    jge end_loop_83
    mov rdx, [rbp + 8*2] ; rdx = env
    shl rbx, 3
    add rdx, rbx ; env[i] =-->[var, var,...var] 
    shr rbx, 3
    mov r8, [rdx] 
    mov [rax + 8*rcx], r8 ; extEnv[j]=env[i]
    inc rcx
    inc rbx
    jmp loop_83
end_loop_83:
 ;  rax holds ->extEnv
;n= [rbp+8*3]
mov rbx, rax ;rbx holds extEnv
; Allocate ExtEnv[0] to point to a vector where to store the parameters
mov r8, [rbp+8*3] ; r8= n
inc r8; +magic
shl r8, 3
MALLOC r9, r8 ; r9 holds the vector for the params with size 8*n +1 for magic
shr r8, 3
dec r8; - magic
mov rcx, 0 ;i=0
;following loop is to Copy the parameters off of the stack to the extended env:
loop_84:
    cmp rcx ,r8 ; i<n
    jge end_loop_84
    mov rdx, [rbp+8*(4+rcx)] ;  rdx= param_i
    mov [r9+8*rcx], rdx ; ExtEnv [0][i]= param_i
    inc rcx
    jmp loop_84
end_loop_84:
mov qword [r9+8*rcx], SOB_NIL_ADDRESS; add magic to the end
mov [rbx], r9 ; updte the extEnv[0]-> vector that we created for the params

MAKE_CLOSURE(rax, rbx, Lcode_42)
 jmp Lcont_42
Lcode_42:
push rbp
mov rbp , rsp
MALLOC rax, 8
mov rbx, qword[rbp+ 8*(4+0)]
mov [rax], rbx
mov qword [rbp + 8 * (4 + (0))],rax
mov rax, SOB_VOID_ADDRESS
;we know that env = [rbp + 8*2]
; we know that depth is env.length
; now we SHOULD allocate extenv with size env.length+1= depth+1
MALLOC rax, 8*(1+2) ; rax->extEnv
mov rbx, 0 ;i
mov rcx, 1 ;j
;following loop is to shift the env in extended env
loop_85:
    cmp rbx, 2
    jge end_loop_85
    mov rdx, [rbp + 8*2] ; rdx = env
    shl rbx, 3
    add rdx, rbx ; env[i] =-->[var, var,...var] 
    shr rbx, 3
    mov r8, [rdx] 
    mov [rax + 8*rcx], r8 ; extEnv[j]=env[i]
    inc rcx
    inc rbx
    jmp loop_85
end_loop_85:
 ;  rax holds ->extEnv
;n= [rbp+8*3]
mov rbx, rax ;rbx holds extEnv
; Allocate ExtEnv[0] to point to a vector where to store the parameters
mov r8, [rbp+8*3] ; r8= n
inc r8; +magic
shl r8, 3
MALLOC r9, r8 ; r9 holds the vector for the params with size 8*n +1 for magic
shr r8, 3
dec r8; - magic
mov rcx, 0 ;i=0
;following loop is to Copy the parameters off of the stack to the extended env:
loop_86:
    cmp rcx ,r8 ; i<n
    jge end_loop_86
    mov rdx, [rbp+8*(4+rcx)] ;  rdx= param_i
    mov [r9+8*rcx], rdx ; ExtEnv [0][i]= param_i
    inc rcx
    jmp loop_86
end_loop_86:
mov qword [r9+8*rcx], SOB_NIL_ADDRESS; add magic to the end
mov [rbx], r9 ; updte the extEnv[0]-> vector that we created for the params

MAKE_CLOSURE(rax, rbx, Lcode_43)
 jmp Lcont_43
Lcode_43:
push rbp
mov rbp , rsp
;applic:
         push SOB_NIL_ADDRESS ; push magic
mov rax, qword [rbp + 8 *(4 + 1)]
push rax ; calculate arg, rax holds arg, and push it
push 1 ; push argcount
;next is proc:
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * (1)]
mov rax, qword [rax + 8 * (0)]
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
call qword [rax+9] ; call to code ptr
 add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8*rbx]; pop args
add rsp , 8 ; pop magic, which is sob_nil
cmp rax, SOB_FALSE_ADDRESS
jne Lexit_Or_3
;applic:
         push SOB_NIL_ADDRESS ; push magic
;applic:
         push SOB_NIL_ADDRESS ; push magic
;applic:
         push SOB_NIL_ADDRESS ; push magic
mov rax, qword [rbp + 8 *(4 + 1)]
push rax ; calculate arg, rax holds arg, and push it
push 1 ; push argcount
;next is proc:
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * (1)]
mov rax, qword [rax + 8 * (2)]
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
call qword [rax+9] ; call to code ptr
 add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8*rbx]; pop args
add rsp , 8 ; pop magic, which is sob_nil
push rax ; calculate arg, rax holds arg, and push it
mov rax, qword [rbp + 8 *(4 + 0)]
push rax ; calculate arg, rax holds arg, and push it
push 2 ; push argcount
;next is proc:
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * (1)]
mov rax, qword [rax + 8 * (4)]
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
call qword [rax+9] ; call to code ptr
 add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8*rbx]; pop args
add rsp , 8 ; pop magic, which is sob_nil
push rax ; calculate arg, rax holds arg, and push it
push 1 ; push argcount
;next is proc:
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * (1)]
mov rax, qword [rax + 8 * (1)]
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
call qword [rax+9] ; call to code ptr
 add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8*rbx]; pop args
add rsp , 8 ; pop magic, which is sob_nil
cmp rax, SOB_FALSE_ADDRESS
je Lelse_18
;applic:
         push SOB_NIL_ADDRESS ; push magic
;applic:
         push SOB_NIL_ADDRESS ; push magic
;applic:
         push SOB_NIL_ADDRESS ; push magic
mov rax, qword [rbp + 8 *(4 + 1)]
push rax ; calculate arg, rax holds arg, and push it
push 1 ; push argcount
;next is proc:
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * (1)]
mov rax, qword [rax + 8 * (2)]
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
call qword [rax+9] ; call to code ptr
 add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8*rbx]; pop args
add rsp , 8 ; pop magic, which is sob_nil
push rax ; calculate arg, rax holds arg, and push it
mov rax, qword [rbp + 8 *(4 + 0)]
push rax ; calculate arg, rax holds arg, and push it
push 2 ; push argcount
;next is proc:
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * (1)]
mov rax, qword [rax + 8 * (5)]
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
call qword [rax+9] ; call to code ptr
 add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8*rbx]; pop args
add rsp , 8 ; pop magic, which is sob_nil
push rax ; calculate arg, rax holds arg, and push it
push 1 ; push argcount
;next is proc:
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * (1)]
mov rax, qword [rax + 8 * (1)]
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
call qword [rax+9] ; call to code ptr
 add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8*rbx]; pop args
add rsp , 8 ; pop magic, which is sob_nil
cmp rax, SOB_FALSE_ADDRESS
je Lelse_19
;applic tp:
push SOB_NIL_ADDRESS ; push magic
;applic:
         push SOB_NIL_ADDRESS ; push magic
mov rax, qword [rbp + 8 *(4 + 1)]
push rax ; calculate arg, rax holds arg, and push it
push 1 ; push argcount
;next is proc:
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * (1)]
mov rax, qword [rax + 8 * (3)]
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
call qword [rax+9] ; call to code ptr
 add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8*rbx]; pop args
add rsp , 8 ; pop magic, which is sob_nil
push rax ; calculate arg, rax holds arg, and push it
;applic:
         push SOB_NIL_ADDRESS ; push magic
mov rax, qword [rbp + 8 *(4 + 1)]
push rax ; calculate arg, rax holds arg, and push it
push 1 ; push argcount
;next is proc:
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * (1)]
mov rax, qword [rax + 8 * (2)]
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
call qword [rax+9] ; call to code ptr
 add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8*rbx]; pop args
add rsp , 8 ; pop magic, which is sob_nil
push rax ; calculate arg, rax holds arg, and push it
push 2 ; push argcount
;next is proc:
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * (0)]
mov rax, qword [rax + 8 * (0)]
mov rax, qword [rax]
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
push qword [rbp + 8 * 1] ; old ret addr
mov r11, qword [rbp]
SHIFT_FRAME_34:
mov r15, rbp
sub r15, 8 ; r15= adress in stack of first to move up
mov qword r14, [rbp + 8*3] ; r14=n
add r14, 4
shl r14, 3
add r14, rbp ; r14 = rbp+ 8*(4+n) , which is the adress we should overide first
; we are moving top down:
.loop_of_shifts:
  cmp r15, rsp
  jl .end_loop_of_shifts ; we finished
  mov qword r12, [r15]; r12 = element to move
  mov qword [r14], r12 ; move elemnt to top of stack
  sub r14, 8
  sub r15, 8
  jmp .loop_of_shifts
.end_loop_of_shifts:
  add r14, 8
  mov rsp, r14
  mov rbp, r11
  jmp qword [rax+9] ; jump to code ptr
 jmp Lexit_19
Lelse_19:
mov rax, const_tbl+2
Lexit_19:
jmp Lexit_18
Lelse_18:
mov rax, const_tbl+2
Lexit_18:
Lexit_Or_3:

leave
ret
Lcont_43:
push rax
mov rax, qword [rbp + 8 *(4 + 0)]
pop qword [rax]
mov rax, SOB_VOID_ADDRESS
;we know that env = [rbp + 8*2]
; we know that depth is env.length
; now we SHOULD allocate extenv with size env.length+1= depth+1
MALLOC rax, 8*(1+2) ; rax->extEnv
mov rbx, 0 ;i
mov rcx, 1 ;j
;following loop is to shift the env in extended env
loop_87:
    cmp rbx, 2
    jge end_loop_87
    mov rdx, [rbp + 8*2] ; rdx = env
    shl rbx, 3
    add rdx, rbx ; env[i] =-->[var, var,...var] 
    shr rbx, 3
    mov r8, [rdx] 
    mov [rax + 8*rcx], r8 ; extEnv[j]=env[i]
    inc rcx
    inc rbx
    jmp loop_87
end_loop_87:
 ;  rax holds ->extEnv
;n= [rbp+8*3]
mov rbx, rax ;rbx holds extEnv
; Allocate ExtEnv[0] to point to a vector where to store the parameters
mov r8, [rbp+8*3] ; r8= n
inc r8; +magic
shl r8, 3
MALLOC r9, r8 ; r9 holds the vector for the params with size 8*n +1 for magic
shr r8, 3
dec r8; - magic
mov rcx, 0 ;i=0
;following loop is to Copy the parameters off of the stack to the extended env:
loop_88:
    cmp rcx ,r8 ; i<n
    jge end_loop_88
    mov rdx, [rbp+8*(4+rcx)] ;  rdx= param_i
    mov [r9+8*rcx], rdx ; ExtEnv [0][i]= param_i
    inc rcx
    jmp loop_88
end_loop_88:
mov qword [r9+8*rcx], SOB_NIL_ADDRESS; add magic to the end
mov [rbx], r9 ; updte the extEnv[0]-> vector that we created for the params

MAKE_CLOSURE(rax, rbx, Lcode_44)
 jmp Lcont_44
Lcode_44:
mov rdx, rsp ; rdx hold cur stack ptr ==> [rdx]= ret_adr etc... (i chose rdx because cons does'nt overide it)
mov r8, [rdx+8*2] ; r8= arg_count 
cmp r8, 2 ; compare arg_count to the amount we've expected
jl .no_fix_necessery
; else: we need to collect all exses args to a list
mov r9, SOB_NIL_ADDRESS ; r9 holds curr list
mov r10, r8
sub r10, 1 ; r10= lst size= num of opt args
mov r11, r8
dec r11 ; r11 =idx= n-1
.loop_create_lst:
  cmp r11, 1 
  jl .end_loop_create_lst ; end loop if idx<params.lst, which is when we get to the args that arent optional
  mov r13, rsp; r13=sp
  push SOB_NIL_ADDRESS; push magic
  push r9 ; push cdr
  push qword [rdx+8*(3+r11)] ; push arg_idx = car
  push qword 2; argcount= car, cdr
  push qword [rdx+8*1]; env
  call cons
  mov rsp, r13
  mov r9, rax ; r9 hold new lst
  mov r13, [r9+1]; r13=car
  mov r13, [r9+1+8]; r13=cdr
  dec r11 ; idx--
  jmp .loop_create_lst
.end_loop_create_lst:

; now r9 holds list of optional args
mov r13, [rdx+8*(3+r8-1)]; should be last opt arg=3
mov qword [rdx+8*(3+r8-1)], r9 ; set arg_n-1 to be optional
mov qword [rdx+8*2], 2
mov r9, r8  ; r9= n
inc r9  ;r9 = n+1 =3+n-2
shl r9, 3 ;r9= 8*(3+n-2)= idx of last place in stack
mov r11, 1
add r11, 2 
shl r11, 3 ; r11 = 8*(3+ params_len -1) = idx of last mandatory arg = the first element from stack that should be moved up
mov r13, [rdx+r11]; should be 1
; both r11, r9 will be decresed each time by 8
.loop_shift_stack:
  cmp r11, 0
  jl .end_loop_shift_stack
  mov rax, [rdx+r11] ; rax = cur element to move
  mov [rdx+r9], rax ; move to the top of the stack the cur element top down
  sub r9, 8
  sub r11, 8
  jmp .loop_shift_stack
.end_loop_shift_stack:
; now, rdx+r9 holds the last place on stack
add r9, 8
add r9, rdx
mov rsp, r9
.no_fix_necessery:

push rbp
mov rbp , rsp
;applic tp:
push SOB_NIL_ADDRESS ; push magic
mov rax, qword [rbp + 8 *(4 + 1)]
push rax ; calculate arg, rax holds arg, and push it
mov rax, qword [rbp + 8 *(4 + 0)]
push rax ; calculate arg, rax holds arg, and push it
push 2 ; push argcount
;next is proc:
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * (0)]
mov rax, qword [rax + 8 * (0)]
mov rax, qword [rax]
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
push qword [rbp + 8 * 1] ; old ret addr
mov r11, qword [rbp]
SHIFT_FRAME_35:
mov r15, rbp
sub r15, 8 ; r15= adress in stack of first to move up
mov qword r14, [rbp + 8*3] ; r14=n
add r14, 4
shl r14, 3
add r14, rbp ; r14 = rbp+ 8*(4+n) , which is the adress we should overide first
; we are moving top down:
.loop_of_shifts:
  cmp r15, rsp
  jl .end_loop_of_shifts ; we finished
  mov qword r12, [r15]; r12 = element to move
  mov qword [r14], r12 ; move elemnt to top of stack
  sub r14, 8
  sub r15, 8
  jmp .loop_of_shifts
.end_loop_of_shifts:
  add r14, 8
  mov rsp, r14
  mov rbp, r11
  jmp qword [rax+9] ; jump to code ptr
 
leave
ret
Lcont_44:

leave
ret
Lcont_42:
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
push qword [rbp + 8 * 1] ; old ret addr
mov r11, qword [rbp]
SHIFT_FRAME_33:
mov r15, rbp
sub r15, 8 ; r15= adress in stack of first to move up
mov qword r14, [rbp + 8*3] ; r14=n
add r14, 4
shl r14, 3
add r14, rbp ; r14 = rbp+ 8*(4+n) , which is the adress we should overide first
; we are moving top down:
.loop_of_shifts:
  cmp r15, rsp
  jl .end_loop_of_shifts ; we finished
  mov qword r12, [r15]; r12 = element to move
  mov qword [r14], r12 ; move elemnt to top of stack
  sub r14, 8
  sub r15, 8
  jmp .loop_of_shifts
.end_loop_of_shifts:
  add r14, 8
  mov rsp, r14
  mov rbp, r11
  jmp qword [rax+9] ; jump to code ptr
 
leave
ret
Lcont_41:
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
call qword [rax+9] ; call to code ptr
 add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8*rbx]; pop args
add rsp , 8 ; pop magic, which is sob_nil
mov [fvar_tbl+(8*47)], rax
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void

;applic:
         push SOB_NIL_ADDRESS ; push magic
mov rax, [fvar_tbl+ (8* 29)]
push rax ; calculate arg, rax holds arg, and push it
mov rax, [fvar_tbl+ (8* 28)]
push rax ; calculate arg, rax holds arg, and push it
mov rax, [fvar_tbl+ (8* 4)]
push rax ; calculate arg, rax holds arg, and push it
mov rax, [fvar_tbl+ (8* 25)]
push rax ; calculate arg, rax holds arg, and push it
push 4 ; push argcount
;next is proc:
;we know that env = [rbp + 8*2]
; we know that depth is env.length
; now we SHOULD allocate extenv with size env.length+1= depth+1
MALLOC rax, 8*(1+0) ; rax->extEnv
mov rbx, 0 ;i
mov rcx, 1 ;j
;following loop is to shift the env in extended env
loop_89:
    cmp rbx, 0
    jge end_loop_89
    mov rdx, [rbp + 8*2] ; rdx = env
    shl rbx, 3
    add rdx, rbx ; env[i] =-->[var, var,...var] 
    shr rbx, 3
    mov r8, [rdx] 
    mov [rax + 8*rcx], r8 ; extEnv[j]=env[i]
    inc rcx
    inc rbx
    jmp loop_89
end_loop_89:
 ;  rax holds ->extEnv
;n= [rbp+8*3]
mov rbx, rax ;rbx holds extEnv
; Allocate ExtEnv[0] to point to a vector where to store the parameters
mov r8, [rbp+8*3] ; r8= n
inc r8; +magic
shl r8, 3
MALLOC r9, r8 ; r9 holds the vector for the params with size 8*n +1 for magic
shr r8, 3
dec r8; - magic
mov rcx, 0 ;i=0
;following loop is to Copy the parameters off of the stack to the extended env:
loop_90:
    cmp rcx ,r8 ; i<n
    jge end_loop_90
    mov rdx, [rbp+8*(4+rcx)] ;  rdx= param_i
    mov [r9+8*rcx], rdx ; ExtEnv [0][i]= param_i
    inc rcx
    jmp loop_90
end_loop_90:
mov qword [r9+8*rcx], SOB_NIL_ADDRESS; add magic to the end
mov [rbx], r9 ; updte the extEnv[0]-> vector that we created for the params

MAKE_CLOSURE(rax, rbx, Lcode_45)
 jmp Lcont_45
Lcode_45:
push rbp
mov rbp , rsp
;applic tp:
push SOB_NIL_ADDRESS ; push magic
mov rax, const_tbl+23
push rax ; calculate arg, rax holds arg, and push it
push 1 ; push argcount
;next is proc:
;we know that env = [rbp + 8*2]
; we know that depth is env.length
; now we SHOULD allocate extenv with size env.length+1= depth+1
MALLOC rax, 8*(1+1) ; rax->extEnv
mov rbx, 0 ;i
mov rcx, 1 ;j
;following loop is to shift the env in extended env
loop_91:
    cmp rbx, 1
    jge end_loop_91
    mov rdx, [rbp + 8*2] ; rdx = env
    shl rbx, 3
    add rdx, rbx ; env[i] =-->[var, var,...var] 
    shr rbx, 3
    mov r8, [rdx] 
    mov [rax + 8*rcx], r8 ; extEnv[j]=env[i]
    inc rcx
    inc rbx
    jmp loop_91
end_loop_91:
 ;  rax holds ->extEnv
;n= [rbp+8*3]
mov rbx, rax ;rbx holds extEnv
; Allocate ExtEnv[0] to point to a vector where to store the parameters
mov r8, [rbp+8*3] ; r8= n
inc r8; +magic
shl r8, 3
MALLOC r9, r8 ; r9 holds the vector for the params with size 8*n +1 for magic
shr r8, 3
dec r8; - magic
mov rcx, 0 ;i=0
;following loop is to Copy the parameters off of the stack to the extended env:
loop_92:
    cmp rcx ,r8 ; i<n
    jge end_loop_92
    mov rdx, [rbp+8*(4+rcx)] ;  rdx= param_i
    mov [r9+8*rcx], rdx ; ExtEnv [0][i]= param_i
    inc rcx
    jmp loop_92
end_loop_92:
mov qword [r9+8*rcx], SOB_NIL_ADDRESS; add magic to the end
mov [rbx], r9 ; updte the extEnv[0]-> vector that we created for the params

MAKE_CLOSURE(rax, rbx, Lcode_46)
 jmp Lcont_46
Lcode_46:
push rbp
mov rbp , rsp
MALLOC rax, 8
mov rbx, qword[rbp+ 8*(4+0)]
mov [rax], rbx
mov qword [rbp + 8 * (4 + (0))],rax
mov rax, SOB_VOID_ADDRESS
;we know that env = [rbp + 8*2]
; we know that depth is env.length
; now we SHOULD allocate extenv with size env.length+1= depth+1
MALLOC rax, 8*(1+2) ; rax->extEnv
mov rbx, 0 ;i
mov rcx, 1 ;j
;following loop is to shift the env in extended env
loop_93:
    cmp rbx, 2
    jge end_loop_93
    mov rdx, [rbp + 8*2] ; rdx = env
    shl rbx, 3
    add rdx, rbx ; env[i] =-->[var, var,...var] 
    shr rbx, 3
    mov r8, [rdx] 
    mov [rax + 8*rcx], r8 ; extEnv[j]=env[i]
    inc rcx
    inc rbx
    jmp loop_93
end_loop_93:
 ;  rax holds ->extEnv
;n= [rbp+8*3]
mov rbx, rax ;rbx holds extEnv
; Allocate ExtEnv[0] to point to a vector where to store the parameters
mov r8, [rbp+8*3] ; r8= n
inc r8; +magic
shl r8, 3
MALLOC r9, r8 ; r9 holds the vector for the params with size 8*n +1 for magic
shr r8, 3
dec r8; - magic
mov rcx, 0 ;i=0
;following loop is to Copy the parameters off of the stack to the extended env:
loop_94:
    cmp rcx ,r8 ; i<n
    jge end_loop_94
    mov rdx, [rbp+8*(4+rcx)] ;  rdx= param_i
    mov [r9+8*rcx], rdx ; ExtEnv [0][i]= param_i
    inc rcx
    jmp loop_94
end_loop_94:
mov qword [r9+8*rcx], SOB_NIL_ADDRESS; add magic to the end
mov [rbx], r9 ; updte the extEnv[0]-> vector that we created for the params

MAKE_CLOSURE(rax, rbx, Lcode_47)
 jmp Lcont_47
Lcode_47:
push rbp
mov rbp , rsp
;applic:
         push SOB_NIL_ADDRESS ; push magic
mov rax, qword [rbp + 8 *(4 + 1)]
push rax ; calculate arg, rax holds arg, and push it
push 1 ; push argcount
;next is proc:
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * (1)]
mov rax, qword [rax + 8 * (1)]
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
call qword [rax+9] ; call to code ptr
 add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8*rbx]; pop args
add rsp , 8 ; pop magic, which is sob_nil
cmp rax, SOB_FALSE_ADDRESS
je Lelse_20
mov rax, qword [rbp + 8 *(4 + 0)]
jmp Lexit_20
Lelse_20:
;applic tp:
push SOB_NIL_ADDRESS ; push magic
;applic:
         push SOB_NIL_ADDRESS ; push magic
mov rax, qword [rbp + 8 *(4 + 1)]
push rax ; calculate arg, rax holds arg, and push it
push 1 ; push argcount
;next is proc:
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * (1)]
mov rax, qword [rax + 8 * (3)]
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
call qword [rax+9] ; call to code ptr
 add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8*rbx]; pop args
add rsp , 8 ; pop magic, which is sob_nil
push rax ; calculate arg, rax holds arg, and push it
;applic:
         push SOB_NIL_ADDRESS ; push magic
;applic:
         push SOB_NIL_ADDRESS ; push magic
mov rax, qword [rbp + 8 *(4 + 1)]
push rax ; calculate arg, rax holds arg, and push it
push 1 ; push argcount
;next is proc:
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * (1)]
mov rax, qword [rax + 8 * (2)]
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
call qword [rax+9] ; call to code ptr
 add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8*rbx]; pop args
add rsp , 8 ; pop magic, which is sob_nil
push rax ; calculate arg, rax holds arg, and push it
mov rax, qword [rbp + 8 *(4 + 0)]
push rax ; calculate arg, rax holds arg, and push it
push 2 ; push argcount
;next is proc:
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * (1)]
mov rax, qword [rax + 8 * (0)]
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
call qword [rax+9] ; call to code ptr
 add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8*rbx]; pop args
add rsp , 8 ; pop magic, which is sob_nil
push rax ; calculate arg, rax holds arg, and push it
push 2 ; push argcount
;next is proc:
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * (0)]
mov rax, qword [rax + 8 * (0)]
mov rax, qword [rax]
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
push qword [rbp + 8 * 1] ; old ret addr
mov r11, qword [rbp]
SHIFT_FRAME_37:
mov r15, rbp
sub r15, 8 ; r15= adress in stack of first to move up
mov qword r14, [rbp + 8*3] ; r14=n
add r14, 4
shl r14, 3
add r14, rbp ; r14 = rbp+ 8*(4+n) , which is the adress we should overide first
; we are moving top down:
.loop_of_shifts:
  cmp r15, rsp
  jl .end_loop_of_shifts ; we finished
  mov qword r12, [r15]; r12 = element to move
  mov qword [r14], r12 ; move elemnt to top of stack
  sub r14, 8
  sub r15, 8
  jmp .loop_of_shifts
.end_loop_of_shifts:
  add r14, 8
  mov rsp, r14
  mov rbp, r11
  jmp qword [rax+9] ; jump to code ptr
 Lexit_20:

leave
ret
Lcont_47:
push rax
mov rax, qword [rbp + 8 *(4 + 0)]
pop qword [rax]
mov rax, SOB_VOID_ADDRESS
;we know that env = [rbp + 8*2]
; we know that depth is env.length
; now we SHOULD allocate extenv with size env.length+1= depth+1
MALLOC rax, 8*(1+2) ; rax->extEnv
mov rbx, 0 ;i
mov rcx, 1 ;j
;following loop is to shift the env in extended env
loop_95:
    cmp rbx, 2
    jge end_loop_95
    mov rdx, [rbp + 8*2] ; rdx = env
    shl rbx, 3
    add rdx, rbx ; env[i] =-->[var, var,...var] 
    shr rbx, 3
    mov r8, [rdx] 
    mov [rax + 8*rcx], r8 ; extEnv[j]=env[i]
    inc rcx
    inc rbx
    jmp loop_95
end_loop_95:
 ;  rax holds ->extEnv
;n= [rbp+8*3]
mov rbx, rax ;rbx holds extEnv
; Allocate ExtEnv[0] to point to a vector where to store the parameters
mov r8, [rbp+8*3] ; r8= n
inc r8; +magic
shl r8, 3
MALLOC r9, r8 ; r9 holds the vector for the params with size 8*n +1 for magic
shr r8, 3
dec r8; - magic
mov rcx, 0 ;i=0
;following loop is to Copy the parameters off of the stack to the extended env:
loop_96:
    cmp rcx ,r8 ; i<n
    jge end_loop_96
    mov rdx, [rbp+8*(4+rcx)] ;  rdx= param_i
    mov [r9+8*rcx], rdx ; ExtEnv [0][i]= param_i
    inc rcx
    jmp loop_96
end_loop_96:
mov qword [r9+8*rcx], SOB_NIL_ADDRESS; add magic to the end
mov [rbx], r9 ; updte the extEnv[0]-> vector that we created for the params

MAKE_CLOSURE(rax, rbx, Lcode_48)
 jmp Lcont_48
Lcode_48:
mov rdx, rsp ; rdx hold cur stack ptr ==> [rdx]= ret_adr etc... (i chose rdx because cons does'nt overide it)
mov r8, [rdx+8*2] ; r8= arg_count 
cmp r8, 1 ; compare arg_count to the amount we've expected
jl .no_fix_necessery
; else: we need to collect all exses args to a list
mov r9, SOB_NIL_ADDRESS ; r9 holds curr list
mov r10, r8
sub r10, 0 ; r10= lst size= num of opt args
mov r11, r8
dec r11 ; r11 =idx= n-1
.loop_create_lst:
  cmp r11, 0 
  jl .end_loop_create_lst ; end loop if idx<params.lst, which is when we get to the args that arent optional
  mov r13, rsp; r13=sp
  push SOB_NIL_ADDRESS; push magic
  push r9 ; push cdr
  push qword [rdx+8*(3+r11)] ; push arg_idx = car
  push qword 2; argcount= car, cdr
  push qword [rdx+8*1]; env
  call cons
  mov rsp, r13
  mov r9, rax ; r9 hold new lst
  mov r13, [r9+1]; r13=car
  mov r13, [r9+1+8]; r13=cdr
  dec r11 ; idx--
  jmp .loop_create_lst
.end_loop_create_lst:

; now r9 holds list of optional args
mov r13, [rdx+8*(3+r8-1)]; should be last opt arg=3
mov qword [rdx+8*(3+r8-1)], r9 ; set arg_n-1 to be optional
mov qword [rdx+8*2], 1
mov r9, r8  ; r9= n
inc r9  ;r9 = n+1 =3+n-2
shl r9, 3 ;r9= 8*(3+n-2)= idx of last place in stack
mov r11, 0
add r11, 2 
shl r11, 3 ; r11 = 8*(3+ params_len -1) = idx of last mandatory arg = the first element from stack that should be moved up
mov r13, [rdx+r11]; should be 1
; both r11, r9 will be decresed each time by 8
.loop_shift_stack:
  cmp r11, 0
  jl .end_loop_shift_stack
  mov rax, [rdx+r11] ; rax = cur element to move
  mov [rdx+r9], rax ; move to the top of the stack the cur element top down
  sub r9, 8
  sub r11, 8
  jmp .loop_shift_stack
.end_loop_shift_stack:
; now, rdx+r9 holds the last place on stack
add r9, 8
add r9, rdx
mov rsp, r9
.no_fix_necessery:

push rbp
mov rbp , rsp
;applic:
         push SOB_NIL_ADDRESS ; push magic
mov rax, qword [rbp + 8 *(4 + 0)]
push rax ; calculate arg, rax holds arg, and push it
push 1 ; push argcount
;next is proc:
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * (1)]
mov rax, qword [rax + 8 * (1)]
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
call qword [rax+9] ; call to code ptr
 add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8*rbx]; pop args
add rsp , 8 ; pop magic, which is sob_nil
cmp rax, SOB_FALSE_ADDRESS
je Lelse_21
mov rax, const_tbl+51
jmp Lexit_21
Lelse_21:
;applic tp:
push SOB_NIL_ADDRESS ; push magic
;applic:
         push SOB_NIL_ADDRESS ; push magic
mov rax, qword [rbp + 8 *(4 + 0)]
push rax ; calculate arg, rax holds arg, and push it
push 1 ; push argcount
;next is proc:
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * (1)]
mov rax, qword [rax + 8 * (3)]
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
call qword [rax+9] ; call to code ptr
 add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8*rbx]; pop args
add rsp , 8 ; pop magic, which is sob_nil
push rax ; calculate arg, rax holds arg, and push it
;applic:
         push SOB_NIL_ADDRESS ; push magic
mov rax, qword [rbp + 8 *(4 + 0)]
push rax ; calculate arg, rax holds arg, and push it
push 1 ; push argcount
;next is proc:
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * (1)]
mov rax, qword [rax + 8 * (2)]
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
call qword [rax+9] ; call to code ptr
 add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8*rbx]; pop args
add rsp , 8 ; pop magic, which is sob_nil
push rax ; calculate arg, rax holds arg, and push it
push 2 ; push argcount
;next is proc:
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * (0)]
mov rax, qword [rax + 8 * (0)]
mov rax, qword [rax]
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
push qword [rbp + 8 * 1] ; old ret addr
mov r11, qword [rbp]
SHIFT_FRAME_38:
mov r15, rbp
sub r15, 8 ; r15= adress in stack of first to move up
mov qword r14, [rbp + 8*3] ; r14=n
add r14, 4
shl r14, 3
add r14, rbp ; r14 = rbp+ 8*(4+n) , which is the adress we should overide first
; we are moving top down:
.loop_of_shifts:
  cmp r15, rsp
  jl .end_loop_of_shifts ; we finished
  mov qword r12, [r15]; r12 = element to move
  mov qword [r14], r12 ; move elemnt to top of stack
  sub r14, 8
  sub r15, 8
  jmp .loop_of_shifts
.end_loop_of_shifts:
  add r14, 8
  mov rsp, r14
  mov rbp, r11
  jmp qword [rax+9] ; jump to code ptr
 Lexit_21:

leave
ret
Lcont_48:

leave
ret
Lcont_46:
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
push qword [rbp + 8 * 1] ; old ret addr
mov r11, qword [rbp]
SHIFT_FRAME_36:
mov r15, rbp
sub r15, 8 ; r15= adress in stack of first to move up
mov qword r14, [rbp + 8*3] ; r14=n
add r14, 4
shl r14, 3
add r14, rbp ; r14 = rbp+ 8*(4+n) , which is the adress we should overide first
; we are moving top down:
.loop_of_shifts:
  cmp r15, rsp
  jl .end_loop_of_shifts ; we finished
  mov qword r12, [r15]; r12 = element to move
  mov qword [r14], r12 ; move elemnt to top of stack
  sub r14, 8
  sub r15, 8
  jmp .loop_of_shifts
.end_loop_of_shifts:
  add r14, 8
  mov rsp, r14
  mov rbp, r11
  jmp qword [rax+9] ; jump to code ptr
 
leave
ret
Lcont_45:
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
call qword [rax+9] ; call to code ptr
 add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8*rbx]; pop args
add rsp , 8 ; pop magic, which is sob_nil
mov [fvar_tbl+(8*25)], rax
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void

;applic:
         push SOB_NIL_ADDRESS ; push magic
mov rax, [fvar_tbl+ (8* 21)]
push rax ; calculate arg, rax holds arg, and push it
push 1 ; push argcount
;next is proc:
;we know that env = [rbp + 8*2]
; we know that depth is env.length
; now we SHOULD allocate extenv with size env.length+1= depth+1
MALLOC rax, 8*(1+0) ; rax->extEnv
mov rbx, 0 ;i
mov rcx, 1 ;j
;following loop is to shift the env in extended env
loop_97:
    cmp rbx, 0
    jge end_loop_97
    mov rdx, [rbp + 8*2] ; rdx = env
    shl rbx, 3
    add rdx, rbx ; env[i] =-->[var, var,...var] 
    shr rbx, 3
    mov r8, [rdx] 
    mov [rax + 8*rcx], r8 ; extEnv[j]=env[i]
    inc rcx
    inc rbx
    jmp loop_97
end_loop_97:
 ;  rax holds ->extEnv
;n= [rbp+8*3]
mov rbx, rax ;rbx holds extEnv
; Allocate ExtEnv[0] to point to a vector where to store the parameters
mov r8, [rbp+8*3] ; r8= n
inc r8; +magic
shl r8, 3
MALLOC r9, r8 ; r9 holds the vector for the params with size 8*n +1 for magic
shr r8, 3
dec r8; - magic
mov rcx, 0 ;i=0
;following loop is to Copy the parameters off of the stack to the extended env:
loop_98:
    cmp rcx ,r8 ; i<n
    jge end_loop_98
    mov rdx, [rbp+8*(4+rcx)] ;  rdx= param_i
    mov [r9+8*rcx], rdx ; ExtEnv [0][i]= param_i
    inc rcx
    jmp loop_98
end_loop_98:
mov qword [r9+8*rcx], SOB_NIL_ADDRESS; add magic to the end
mov [rbx], r9 ; updte the extEnv[0]-> vector that we created for the params

MAKE_CLOSURE(rax, rbx, Lcode_49)
 jmp Lcont_49
Lcode_49:
push rbp
mov rbp , rsp
;we know that env = [rbp + 8*2]
; we know that depth is env.length
; now we SHOULD allocate extenv with size env.length+1= depth+1
MALLOC rax, 8*(1+1) ; rax->extEnv
mov rbx, 0 ;i
mov rcx, 1 ;j
;following loop is to shift the env in extended env
loop_99:
    cmp rbx, 1
    jge end_loop_99
    mov rdx, [rbp + 8*2] ; rdx = env
    shl rbx, 3
    add rdx, rbx ; env[i] =-->[var, var,...var] 
    shr rbx, 3
    mov r8, [rdx] 
    mov [rax + 8*rcx], r8 ; extEnv[j]=env[i]
    inc rcx
    inc rbx
    jmp loop_99
end_loop_99:
 ;  rax holds ->extEnv
;n= [rbp+8*3]
mov rbx, rax ;rbx holds extEnv
; Allocate ExtEnv[0] to point to a vector where to store the parameters
mov r8, [rbp+8*3] ; r8= n
inc r8; +magic
shl r8, 3
MALLOC r9, r8 ; r9 holds the vector for the params with size 8*n +1 for magic
shr r8, 3
dec r8; - magic
mov rcx, 0 ;i=0
;following loop is to Copy the parameters off of the stack to the extended env:
loop_100:
    cmp rcx ,r8 ; i<n
    jge end_loop_100
    mov rdx, [rbp+8*(4+rcx)] ;  rdx= param_i
    mov [r9+8*rcx], rdx ; ExtEnv [0][i]= param_i
    inc rcx
    jmp loop_100
end_loop_100:
mov qword [r9+8*rcx], SOB_NIL_ADDRESS; add magic to the end
mov [rbx], r9 ; updte the extEnv[0]-> vector that we created for the params

MAKE_CLOSURE(rax, rbx, Lcode_50)
 jmp Lcont_50
Lcode_50:
push rbp
mov rbp , rsp
;applic tp:
push SOB_NIL_ADDRESS ; push magic
mov rax, const_tbl+51
push rax ; calculate arg, rax holds arg, and push it
mov rax, qword [rbp + 8 *(4 + 0)]
push rax ; calculate arg, rax holds arg, and push it
push 2 ; push argcount
;next is proc:
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * (0)]
mov rax, qword [rax + 8 * (0)]
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
push qword [rbp + 8 * 1] ; old ret addr
mov r11, qword [rbp]
SHIFT_FRAME_39:
mov r15, rbp
sub r15, 8 ; r15= adress in stack of first to move up
mov qword r14, [rbp + 8*3] ; r14=n
add r14, 4
shl r14, 3
add r14, rbp ; r14 = rbp+ 8*(4+n) , which is the adress we should overide first
; we are moving top down:
.loop_of_shifts:
  cmp r15, rsp
  jl .end_loop_of_shifts ; we finished
  mov qword r12, [r15]; r12 = element to move
  mov qword [r14], r12 ; move elemnt to top of stack
  sub r14, 8
  sub r15, 8
  jmp .loop_of_shifts
.end_loop_of_shifts:
  add r14, 8
  mov rsp, r14
  mov rbp, r11
  jmp qword [rax+9] ; jump to code ptr
 
leave
ret
Lcont_50:

leave
ret
Lcont_49:
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
call qword [rax+9] ; call to code ptr
 add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8*rbx]; pop args
add rsp , 8 ; pop magic, which is sob_nil
mov [fvar_tbl+(8*45)], rax
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void

;applic:
         push SOB_NIL_ADDRESS ; push magic
mov rax, [fvar_tbl+ (8* 24)]
push rax ; calculate arg, rax holds arg, and push it
mov rax, [fvar_tbl+ (8* 21)]
push rax ; calculate arg, rax holds arg, and push it
mov rax, [fvar_tbl+ (8* 2)]
push rax ; calculate arg, rax holds arg, and push it
push 3 ; push argcount
;next is proc:
;we know that env = [rbp + 8*2]
; we know that depth is env.length
; now we SHOULD allocate extenv with size env.length+1= depth+1
MALLOC rax, 8*(1+0) ; rax->extEnv
mov rbx, 0 ;i
mov rcx, 1 ;j
;following loop is to shift the env in extended env
loop_101:
    cmp rbx, 0
    jge end_loop_101
    mov rdx, [rbp + 8*2] ; rdx = env
    shl rbx, 3
    add rdx, rbx ; env[i] =-->[var, var,...var] 
    shr rbx, 3
    mov r8, [rdx] 
    mov [rax + 8*rcx], r8 ; extEnv[j]=env[i]
    inc rcx
    inc rbx
    jmp loop_101
end_loop_101:
 ;  rax holds ->extEnv
;n= [rbp+8*3]
mov rbx, rax ;rbx holds extEnv
; Allocate ExtEnv[0] to point to a vector where to store the parameters
mov r8, [rbp+8*3] ; r8= n
inc r8; +magic
shl r8, 3
MALLOC r9, r8 ; r9 holds the vector for the params with size 8*n +1 for magic
shr r8, 3
dec r8; - magic
mov rcx, 0 ;i=0
;following loop is to Copy the parameters off of the stack to the extended env:
loop_102:
    cmp rcx ,r8 ; i<n
    jge end_loop_102
    mov rdx, [rbp+8*(4+rcx)] ;  rdx= param_i
    mov [r9+8*rcx], rdx ; ExtEnv [0][i]= param_i
    inc rcx
    jmp loop_102
end_loop_102:
mov qword [r9+8*rcx], SOB_NIL_ADDRESS; add magic to the end
mov [rbx], r9 ; updte the extEnv[0]-> vector that we created for the params

MAKE_CLOSURE(rax, rbx, Lcode_51)
 jmp Lcont_51
Lcode_51:
push rbp
mov rbp , rsp
;we know that env = [rbp + 8*2]
; we know that depth is env.length
; now we SHOULD allocate extenv with size env.length+1= depth+1
MALLOC rax, 8*(1+1) ; rax->extEnv
mov rbx, 0 ;i
mov rcx, 1 ;j
;following loop is to shift the env in extended env
loop_103:
    cmp rbx, 1
    jge end_loop_103
    mov rdx, [rbp + 8*2] ; rdx = env
    shl rbx, 3
    add rdx, rbx ; env[i] =-->[var, var,...var] 
    shr rbx, 3
    mov r8, [rdx] 
    mov [rax + 8*rcx], r8 ; extEnv[j]=env[i]
    inc rcx
    inc rbx
    jmp loop_103
end_loop_103:
 ;  rax holds ->extEnv
;n= [rbp+8*3]
mov rbx, rax ;rbx holds extEnv
; Allocate ExtEnv[0] to point to a vector where to store the parameters
mov r8, [rbp+8*3] ; r8= n
inc r8; +magic
shl r8, 3
MALLOC r9, r8 ; r9 holds the vector for the params with size 8*n +1 for magic
shr r8, 3
dec r8; - magic
mov rcx, 0 ;i=0
;following loop is to Copy the parameters off of the stack to the extended env:
loop_104:
    cmp rcx ,r8 ; i<n
    jge end_loop_104
    mov rdx, [rbp+8*(4+rcx)] ;  rdx= param_i
    mov [r9+8*rcx], rdx ; ExtEnv [0][i]= param_i
    inc rcx
    jmp loop_104
end_loop_104:
mov qword [r9+8*rcx], SOB_NIL_ADDRESS; add magic to the end
mov [rbx], r9 ; updte the extEnv[0]-> vector that we created for the params

MAKE_CLOSURE(rax, rbx, Lcode_52)
 jmp Lcont_52
Lcode_52:
push rbp
mov rbp , rsp
;applic:
         push SOB_NIL_ADDRESS ; push magic
mov rax, qword [rbp + 8 *(4 + 0)]
push rax ; calculate arg, rax holds arg, and push it
push 1 ; push argcount
;next is proc:
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * (0)]
mov rax, qword [rax + 8 * (0)]
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
call qword [rax+9] ; call to code ptr
 add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8*rbx]; pop args
add rsp , 8 ; pop magic, which is sob_nil
cmp rax, SOB_FALSE_ADDRESS
je Lelse_22
;applic tp:
push SOB_NIL_ADDRESS ; push magic
mov rax, const_tbl+34
push rax ; calculate arg, rax holds arg, and push it
;applic:
         push SOB_NIL_ADDRESS ; push magic
mov rax, qword [rbp + 8 *(4 + 0)]
push rax ; calculate arg, rax holds arg, and push it
push 1 ; push argcount
;next is proc:
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * (0)]
mov rax, qword [rax + 8 * (2)]
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
call qword [rax+9] ; call to code ptr
 add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8*rbx]; pop args
add rsp , 8 ; pop magic, which is sob_nil
push rax ; calculate arg, rax holds arg, and push it
push 2 ; push argcount
;next is proc:
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * (0)]
mov rax, qword [rax + 8 * (1)]
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
push qword [rbp + 8 * 1] ; old ret addr
mov r11, qword [rbp]
SHIFT_FRAME_40:
mov r15, rbp
sub r15, 8 ; r15= adress in stack of first to move up
mov qword r14, [rbp + 8*3] ; r14=n
add r14, 4
shl r14, 3
add r14, rbp ; r14 = rbp+ 8*(4+n) , which is the adress we should overide first
; we are moving top down:
.loop_of_shifts:
  cmp r15, rsp
  jl .end_loop_of_shifts ; we finished
  mov qword r12, [r15]; r12 = element to move
  mov qword [r14], r12 ; move elemnt to top of stack
  sub r14, 8
  sub r15, 8
  jmp .loop_of_shifts
.end_loop_of_shifts:
  add r14, 8
  mov rsp, r14
  mov rbp, r11
  jmp qword [rax+9] ; jump to code ptr
 jmp Lexit_22
Lelse_22:
mov rax, const_tbl+2
Lexit_22:

leave
ret
Lcont_52:

leave
ret
Lcont_51:
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
call qword [rax+9] ; call to code ptr
 add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8*rbx]; pop args
add rsp , 8 ; pop magic, which is sob_nil
mov [fvar_tbl+(8*35)], rax
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void

;applic:
         push SOB_NIL_ADDRESS ; push magic
mov rax, [fvar_tbl+ (8* 2)]
push rax ; calculate arg, rax holds arg, and push it
mov rax, [fvar_tbl+ (8* 1)]
push rax ; calculate arg, rax holds arg, and push it
push 2 ; push argcount
;next is proc:
;we know that env = [rbp + 8*2]
; we know that depth is env.length
; now we SHOULD allocate extenv with size env.length+1= depth+1
MALLOC rax, 8*(1+0) ; rax->extEnv
mov rbx, 0 ;i
mov rcx, 1 ;j
;following loop is to shift the env in extended env
loop_105:
    cmp rbx, 0
    jge end_loop_105
    mov rdx, [rbp + 8*2] ; rdx = env
    shl rbx, 3
    add rdx, rbx ; env[i] =-->[var, var,...var] 
    shr rbx, 3
    mov r8, [rdx] 
    mov [rax + 8*rcx], r8 ; extEnv[j]=env[i]
    inc rcx
    inc rbx
    jmp loop_105
end_loop_105:
 ;  rax holds ->extEnv
;n= [rbp+8*3]
mov rbx, rax ;rbx holds extEnv
; Allocate ExtEnv[0] to point to a vector where to store the parameters
mov r8, [rbp+8*3] ; r8= n
inc r8; +magic
shl r8, 3
MALLOC r9, r8 ; r9 holds the vector for the params with size 8*n +1 for magic
shr r8, 3
dec r8; - magic
mov rcx, 0 ;i=0
;following loop is to Copy the parameters off of the stack to the extended env:
loop_106:
    cmp rcx ,r8 ; i<n
    jge end_loop_106
    mov rdx, [rbp+8*(4+rcx)] ;  rdx= param_i
    mov [r9+8*rcx], rdx ; ExtEnv [0][i]= param_i
    inc rcx
    jmp loop_106
end_loop_106:
mov qword [r9+8*rcx], SOB_NIL_ADDRESS; add magic to the end
mov [rbx], r9 ; updte the extEnv[0]-> vector that we created for the params

MAKE_CLOSURE(rax, rbx, Lcode_53)
 jmp Lcont_53
Lcode_53:
push rbp
mov rbp , rsp
;we know that env = [rbp + 8*2]
; we know that depth is env.length
; now we SHOULD allocate extenv with size env.length+1= depth+1
MALLOC rax, 8*(1+1) ; rax->extEnv
mov rbx, 0 ;i
mov rcx, 1 ;j
;following loop is to shift the env in extended env
loop_107:
    cmp rbx, 1
    jge end_loop_107
    mov rdx, [rbp + 8*2] ; rdx = env
    shl rbx, 3
    add rdx, rbx ; env[i] =-->[var, var,...var] 
    shr rbx, 3
    mov r8, [rdx] 
    mov [rax + 8*rcx], r8 ; extEnv[j]=env[i]
    inc rcx
    inc rbx
    jmp loop_107
end_loop_107:
 ;  rax holds ->extEnv
;n= [rbp+8*3]
mov rbx, rax ;rbx holds extEnv
; Allocate ExtEnv[0] to point to a vector where to store the parameters
mov r8, [rbp+8*3] ; r8= n
inc r8; +magic
shl r8, 3
MALLOC r9, r8 ; r9 holds the vector for the params with size 8*n +1 for magic
shr r8, 3
dec r8; - magic
mov rcx, 0 ;i=0
;following loop is to Copy the parameters off of the stack to the extended env:
loop_108:
    cmp rcx ,r8 ; i<n
    jge end_loop_108
    mov rdx, [rbp+8*(4+rcx)] ;  rdx= param_i
    mov [r9+8*rcx], rdx ; ExtEnv [0][i]= param_i
    inc rcx
    jmp loop_108
end_loop_108:
mov qword [r9+8*rcx], SOB_NIL_ADDRESS; add magic to the end
mov [rbx], r9 ; updte the extEnv[0]-> vector that we created for the params

MAKE_CLOSURE(rax, rbx, Lcode_54)
 jmp Lcont_54
Lcode_54:
push rbp
mov rbp , rsp
;applic:
         push SOB_NIL_ADDRESS ; push magic
mov rax, qword [rbp + 8 *(4 + 0)]
push rax ; calculate arg, rax holds arg, and push it
push 1 ; push argcount
;next is proc:
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * (0)]
mov rax, qword [rax + 8 * (0)]
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
call qword [rax+9] ; call to code ptr
 add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8*rbx]; pop args
add rsp , 8 ; pop magic, which is sob_nil
cmp rax, SOB_FALSE_ADDRESS
jne Lexit_Or_4
;applic tp:
push SOB_NIL_ADDRESS ; push magic
mov rax, qword [rbp + 8 *(4 + 0)]
push rax ; calculate arg, rax holds arg, and push it
push 1 ; push argcount
;next is proc:
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * (0)]
mov rax, qword [rax + 8 * (1)]
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
push qword [rbp + 8 * 1] ; old ret addr
mov r11, qword [rbp]
SHIFT_FRAME_41:
mov r15, rbp
sub r15, 8 ; r15= adress in stack of first to move up
mov qword r14, [rbp + 8*3] ; r14=n
add r14, 4
shl r14, 3
add r14, rbp ; r14 = rbp+ 8*(4+n) , which is the adress we should overide first
; we are moving top down:
.loop_of_shifts:
  cmp r15, rsp
  jl .end_loop_of_shifts ; we finished
  mov qword r12, [r15]; r12 = element to move
  mov qword [r14], r12 ; move elemnt to top of stack
  sub r14, 8
  sub r15, 8
  jmp .loop_of_shifts
.end_loop_of_shifts:
  add r14, 8
  mov rsp, r14
  mov rbp, r11
  jmp qword [rax+9] ; jump to code ptr
 Lexit_Or_4:

leave
ret
Lcont_54:

leave
ret
Lcont_53:
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
call qword [rax+9] ; call to code ptr
 add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8*rbx]; pop args
add rsp , 8 ; pop magic, which is sob_nil
mov [fvar_tbl+(8*41)], rax
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void

;applic:
         push SOB_NIL_ADDRESS ; push magic
mov rax, [fvar_tbl+ (8* 18)]
push rax ; calculate arg, rax holds arg, and push it
mov rax, [fvar_tbl+ (8* 33)]
push rax ; calculate arg, rax holds arg, and push it
push 2 ; push argcount
;next is proc:
;we know that env = [rbp + 8*2]
; we know that depth is env.length
; now we SHOULD allocate extenv with size env.length+1= depth+1
MALLOC rax, 8*(1+0) ; rax->extEnv
mov rbx, 0 ;i
mov rcx, 1 ;j
;following loop is to shift the env in extended env
loop_109:
    cmp rbx, 0
    jge end_loop_109
    mov rdx, [rbp + 8*2] ; rdx = env
    shl rbx, 3
    add rdx, rbx ; env[i] =-->[var, var,...var] 
    shr rbx, 3
    mov r8, [rdx] 
    mov [rax + 8*rcx], r8 ; extEnv[j]=env[i]
    inc rcx
    inc rbx
    jmp loop_109
end_loop_109:
 ;  rax holds ->extEnv
;n= [rbp+8*3]
mov rbx, rax ;rbx holds extEnv
; Allocate ExtEnv[0] to point to a vector where to store the parameters
mov r8, [rbp+8*3] ; r8= n
inc r8; +magic
shl r8, 3
MALLOC r9, r8 ; r9 holds the vector for the params with size 8*n +1 for magic
shr r8, 3
dec r8; - magic
mov rcx, 0 ;i=0
;following loop is to Copy the parameters off of the stack to the extended env:
loop_110:
    cmp rcx ,r8 ; i<n
    jge end_loop_110
    mov rdx, [rbp+8*(4+rcx)] ;  rdx= param_i
    mov [r9+8*rcx], rdx ; ExtEnv [0][i]= param_i
    inc rcx
    jmp loop_110
end_loop_110:
mov qword [r9+8*rcx], SOB_NIL_ADDRESS; add magic to the end
mov [rbx], r9 ; updte the extEnv[0]-> vector that we created for the params

MAKE_CLOSURE(rax, rbx, Lcode_55)
 jmp Lcont_55
Lcode_55:
push rbp
mov rbp , rsp
;we know that env = [rbp + 8*2]
; we know that depth is env.length
; now we SHOULD allocate extenv with size env.length+1= depth+1
MALLOC rax, 8*(1+1) ; rax->extEnv
mov rbx, 0 ;i
mov rcx, 1 ;j
;following loop is to shift the env in extended env
loop_111:
    cmp rbx, 1
    jge end_loop_111
    mov rdx, [rbp + 8*2] ; rdx = env
    shl rbx, 3
    add rdx, rbx ; env[i] =-->[var, var,...var] 
    shr rbx, 3
    mov r8, [rdx] 
    mov [rax + 8*rcx], r8 ; extEnv[j]=env[i]
    inc rcx
    inc rbx
    jmp loop_111
end_loop_111:
 ;  rax holds ->extEnv
;n= [rbp+8*3]
mov rbx, rax ;rbx holds extEnv
; Allocate ExtEnv[0] to point to a vector where to store the parameters
mov r8, [rbp+8*3] ; r8= n
inc r8; +magic
shl r8, 3
MALLOC r9, r8 ; r9 holds the vector for the params with size 8*n +1 for magic
shr r8, 3
dec r8; - magic
mov rcx, 0 ;i=0
;following loop is to Copy the parameters off of the stack to the extended env:
loop_112:
    cmp rcx ,r8 ; i<n
    jge end_loop_112
    mov rdx, [rbp+8*(4+rcx)] ;  rdx= param_i
    mov [r9+8*rcx], rdx ; ExtEnv [0][i]= param_i
    inc rcx
    jmp loop_112
end_loop_112:
mov qword [r9+8*rcx], SOB_NIL_ADDRESS; add magic to the end
mov [rbx], r9 ; updte the extEnv[0]-> vector that we created for the params

MAKE_CLOSURE(rax, rbx, Lcode_56)
 jmp Lcont_56
Lcode_56:
push rbp
mov rbp , rsp
;applic tp:
push SOB_NIL_ADDRESS ; push magic
mov rax, qword [rbp + 8 *(4 + 0)]
push rax ; calculate arg, rax holds arg, and push it
mov rax, const_tbl+51
push rax ; calculate arg, rax holds arg, and push it
;we know that env = [rbp + 8*2]
; we know that depth is env.length
; now we SHOULD allocate extenv with size env.length+1= depth+1
MALLOC rax, 8*(1+2) ; rax->extEnv
mov rbx, 0 ;i
mov rcx, 1 ;j
;following loop is to shift the env in extended env
loop_113:
    cmp rbx, 2
    jge end_loop_113
    mov rdx, [rbp + 8*2] ; rdx = env
    shl rbx, 3
    add rdx, rbx ; env[i] =-->[var, var,...var] 
    shr rbx, 3
    mov r8, [rdx] 
    mov [rax + 8*rcx], r8 ; extEnv[j]=env[i]
    inc rcx
    inc rbx
    jmp loop_113
end_loop_113:
 ;  rax holds ->extEnv
;n= [rbp+8*3]
mov rbx, rax ;rbx holds extEnv
; Allocate ExtEnv[0] to point to a vector where to store the parameters
mov r8, [rbp+8*3] ; r8= n
inc r8; +magic
shl r8, 3
MALLOC r9, r8 ; r9 holds the vector for the params with size 8*n +1 for magic
shr r8, 3
dec r8; - magic
mov rcx, 0 ;i=0
;following loop is to Copy the parameters off of the stack to the extended env:
loop_114:
    cmp rcx ,r8 ; i<n
    jge end_loop_114
    mov rdx, [rbp+8*(4+rcx)] ;  rdx= param_i
    mov [r9+8*rcx], rdx ; ExtEnv [0][i]= param_i
    inc rcx
    jmp loop_114
end_loop_114:
mov qword [r9+8*rcx], SOB_NIL_ADDRESS; add magic to the end
mov [rbx], r9 ; updte the extEnv[0]-> vector that we created for the params

MAKE_CLOSURE(rax, rbx, Lcode_57)
 jmp Lcont_57
Lcode_57:
push rbp
mov rbp , rsp
;applic tp:
push SOB_NIL_ADDRESS ; push magic
mov rax, const_tbl+34
push rax ; calculate arg, rax holds arg, and push it
mov rax, qword [rbp + 8 *(4 + 0)]
push rax ; calculate arg, rax holds arg, and push it
push 2 ; push argcount
;next is proc:
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * (1)]
mov rax, qword [rax + 8 * (1)]
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
push qword [rbp + 8 * 1] ; old ret addr
mov r11, qword [rbp]
SHIFT_FRAME_43:
mov r15, rbp
sub r15, 8 ; r15= adress in stack of first to move up
mov qword r14, [rbp + 8*3] ; r14=n
add r14, 4
shl r14, 3
add r14, rbp ; r14 = rbp+ 8*(4+n) , which is the adress we should overide first
; we are moving top down:
.loop_of_shifts:
  cmp r15, rsp
  jl .end_loop_of_shifts ; we finished
  mov qword r12, [r15]; r12 = element to move
  mov qword [r14], r12 ; move elemnt to top of stack
  sub r14, 8
  sub r15, 8
  jmp .loop_of_shifts
.end_loop_of_shifts:
  add r14, 8
  mov rsp, r14
  mov rbp, r11
  jmp qword [rax+9] ; jump to code ptr
 
leave
ret
Lcont_57:
push rax ; calculate arg, rax holds arg, and push it
push 3 ; push argcount
;next is proc:
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * (0)]
mov rax, qword [rax + 8 * (0)]
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
push qword [rbp + 8 * 1] ; old ret addr
mov r11, qword [rbp]
SHIFT_FRAME_42:
mov r15, rbp
sub r15, 8 ; r15= adress in stack of first to move up
mov qword r14, [rbp + 8*3] ; r14=n
add r14, 4
shl r14, 3
add r14, rbp ; r14 = rbp+ 8*(4+n) , which is the adress we should overide first
; we are moving top down:
.loop_of_shifts:
  cmp r15, rsp
  jl .end_loop_of_shifts ; we finished
  mov qword r12, [r15]; r12 = element to move
  mov qword [r14], r12 ; move elemnt to top of stack
  sub r14, 8
  sub r15, 8
  jmp .loop_of_shifts
.end_loop_of_shifts:
  add r14, 8
  mov rsp, r14
  mov rbp, r11
  jmp qword [rax+9] ; jump to code ptr
 
leave
ret
Lcont_56:

leave
ret
Lcont_55:
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
call qword [rax+9] ; call to code ptr
 add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8*rbx]; pop args
add rsp , 8 ; pop magic, which is sob_nil
mov [fvar_tbl+(8*36)], rax
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void

;applic:
         push SOB_NIL_ADDRESS ; push magic
mov rax, [fvar_tbl+ (8* 30)]
push rax ; calculate arg, rax holds arg, and push it
mov rax, [fvar_tbl+ (8* 46)]
push rax ; calculate arg, rax holds arg, and push it
mov rax, [fvar_tbl+ (8* 22)]
push rax ; calculate arg, rax holds arg, and push it
mov rax, [fvar_tbl+ (8* 9)]
push rax ; calculate arg, rax holds arg, and push it
mov rax, [fvar_tbl+ (8* 10)]
push rax ; calculate arg, rax holds arg, and push it
push 5 ; push argcount
;next is proc:
;we know that env = [rbp + 8*2]
; we know that depth is env.length
; now we SHOULD allocate extenv with size env.length+1= depth+1
MALLOC rax, 8*(1+0) ; rax->extEnv
mov rbx, 0 ;i
mov rcx, 1 ;j
;following loop is to shift the env in extended env
loop_115:
    cmp rbx, 0
    jge end_loop_115
    mov rdx, [rbp + 8*2] ; rdx = env
    shl rbx, 3
    add rdx, rbx ; env[i] =-->[var, var,...var] 
    shr rbx, 3
    mov r8, [rdx] 
    mov [rax + 8*rcx], r8 ; extEnv[j]=env[i]
    inc rcx
    inc rbx
    jmp loop_115
end_loop_115:
 ;  rax holds ->extEnv
;n= [rbp+8*3]
mov rbx, rax ;rbx holds extEnv
; Allocate ExtEnv[0] to point to a vector where to store the parameters
mov r8, [rbp+8*3] ; r8= n
inc r8; +magic
shl r8, 3
MALLOC r9, r8 ; r9 holds the vector for the params with size 8*n +1 for magic
shr r8, 3
dec r8; - magic
mov rcx, 0 ;i=0
;following loop is to Copy the parameters off of the stack to the extended env:
loop_116:
    cmp rcx ,r8 ; i<n
    jge end_loop_116
    mov rdx, [rbp+8*(4+rcx)] ;  rdx= param_i
    mov [r9+8*rcx], rdx ; ExtEnv [0][i]= param_i
    inc rcx
    jmp loop_116
end_loop_116:
mov qword [r9+8*rcx], SOB_NIL_ADDRESS; add magic to the end
mov [rbx], r9 ; updte the extEnv[0]-> vector that we created for the params

MAKE_CLOSURE(rax, rbx, Lcode_58)
 jmp Lcont_58
Lcode_58:
push rbp
mov rbp , rsp
;we know that env = [rbp + 8*2]
; we know that depth is env.length
; now we SHOULD allocate extenv with size env.length+1= depth+1
MALLOC rax, 8*(1+1) ; rax->extEnv
mov rbx, 0 ;i
mov rcx, 1 ;j
;following loop is to shift the env in extended env
loop_117:
    cmp rbx, 1
    jge end_loop_117
    mov rdx, [rbp + 8*2] ; rdx = env
    shl rbx, 3
    add rdx, rbx ; env[i] =-->[var, var,...var] 
    shr rbx, 3
    mov r8, [rdx] 
    mov [rax + 8*rcx], r8 ; extEnv[j]=env[i]
    inc rcx
    inc rbx
    jmp loop_117
end_loop_117:
 ;  rax holds ->extEnv
;n= [rbp+8*3]
mov rbx, rax ;rbx holds extEnv
; Allocate ExtEnv[0] to point to a vector where to store the parameters
mov r8, [rbp+8*3] ; r8= n
inc r8; +magic
shl r8, 3
MALLOC r9, r8 ; r9 holds the vector for the params with size 8*n +1 for magic
shr r8, 3
dec r8; - magic
mov rcx, 0 ;i=0
;following loop is to Copy the parameters off of the stack to the extended env:
loop_118:
    cmp rcx ,r8 ; i<n
    jge end_loop_118
    mov rdx, [rbp+8*(4+rcx)] ;  rdx= param_i
    mov [r9+8*rcx], rdx ; ExtEnv [0][i]= param_i
    inc rcx
    jmp loop_118
end_loop_118:
mov qword [r9+8*rcx], SOB_NIL_ADDRESS; add magic to the end
mov [rbx], r9 ; updte the extEnv[0]-> vector that we created for the params

MAKE_CLOSURE(rax, rbx, Lcode_59)
 jmp Lcont_59
Lcode_59:
push rbp
mov rbp , rsp
;applic tp:
push SOB_NIL_ADDRESS ; push magic
mov rax, const_tbl+23
push rax ; calculate arg, rax holds arg, and push it
push 1 ; push argcount
;next is proc:
;we know that env = [rbp + 8*2]
; we know that depth is env.length
; now we SHOULD allocate extenv with size env.length+1= depth+1
MALLOC rax, 8*(1+2) ; rax->extEnv
mov rbx, 0 ;i
mov rcx, 1 ;j
;following loop is to shift the env in extended env
loop_119:
    cmp rbx, 2
    jge end_loop_119
    mov rdx, [rbp + 8*2] ; rdx = env
    shl rbx, 3
    add rdx, rbx ; env[i] =-->[var, var,...var] 
    shr rbx, 3
    mov r8, [rdx] 
    mov [rax + 8*rcx], r8 ; extEnv[j]=env[i]
    inc rcx
    inc rbx
    jmp loop_119
end_loop_119:
 ;  rax holds ->extEnv
;n= [rbp+8*3]
mov rbx, rax ;rbx holds extEnv
; Allocate ExtEnv[0] to point to a vector where to store the parameters
mov r8, [rbp+8*3] ; r8= n
inc r8; +magic
shl r8, 3
MALLOC r9, r8 ; r9 holds the vector for the params with size 8*n +1 for magic
shr r8, 3
dec r8; - magic
mov rcx, 0 ;i=0
;following loop is to Copy the parameters off of the stack to the extended env:
loop_120:
    cmp rcx ,r8 ; i<n
    jge end_loop_120
    mov rdx, [rbp+8*(4+rcx)] ;  rdx= param_i
    mov [r9+8*rcx], rdx ; ExtEnv [0][i]= param_i
    inc rcx
    jmp loop_120
end_loop_120:
mov qword [r9+8*rcx], SOB_NIL_ADDRESS; add magic to the end
mov [rbx], r9 ; updte the extEnv[0]-> vector that we created for the params

MAKE_CLOSURE(rax, rbx, Lcode_60)
 jmp Lcont_60
Lcode_60:
push rbp
mov rbp , rsp
MALLOC rax, 8
mov rbx, qword[rbp+ 8*(4+0)]
mov [rax], rbx
mov qword [rbp + 8 * (4 + (0))],rax
mov rax, SOB_VOID_ADDRESS
;we know that env = [rbp + 8*2]
; we know that depth is env.length
; now we SHOULD allocate extenv with size env.length+1= depth+1
MALLOC rax, 8*(1+3) ; rax->extEnv
mov rbx, 0 ;i
mov rcx, 1 ;j
;following loop is to shift the env in extended env
loop_121:
    cmp rbx, 3
    jge end_loop_121
    mov rdx, [rbp + 8*2] ; rdx = env
    shl rbx, 3
    add rdx, rbx ; env[i] =-->[var, var,...var] 
    shr rbx, 3
    mov r8, [rdx] 
    mov [rax + 8*rcx], r8 ; extEnv[j]=env[i]
    inc rcx
    inc rbx
    jmp loop_121
end_loop_121:
 ;  rax holds ->extEnv
;n= [rbp+8*3]
mov rbx, rax ;rbx holds extEnv
; Allocate ExtEnv[0] to point to a vector where to store the parameters
mov r8, [rbp+8*3] ; r8= n
inc r8; +magic
shl r8, 3
MALLOC r9, r8 ; r9 holds the vector for the params with size 8*n +1 for magic
shr r8, 3
dec r8; - magic
mov rcx, 0 ;i=0
;following loop is to Copy the parameters off of the stack to the extended env:
loop_122:
    cmp rcx ,r8 ; i<n
    jge end_loop_122
    mov rdx, [rbp+8*(4+rcx)] ;  rdx= param_i
    mov [r9+8*rcx], rdx ; ExtEnv [0][i]= param_i
    inc rcx
    jmp loop_122
end_loop_122:
mov qword [r9+8*rcx], SOB_NIL_ADDRESS; add magic to the end
mov [rbx], r9 ; updte the extEnv[0]-> vector that we created for the params

MAKE_CLOSURE(rax, rbx, Lcode_61)
 jmp Lcont_61
Lcode_61:
push rbp
mov rbp , rsp
;applic:
         push SOB_NIL_ADDRESS ; push magic
mov rax, const_tbl+51
push rax ; calculate arg, rax holds arg, and push it
mov rax, qword [rbp + 8 *(4 + 0)]
push rax ; calculate arg, rax holds arg, and push it
push 2 ; push argcount
;next is proc:
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * (2)]
mov rax, qword [rax + 8 * (2)]
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
call qword [rax+9] ; call to code ptr
 add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8*rbx]; pop args
add rsp , 8 ; pop magic, which is sob_nil
cmp rax, SOB_FALSE_ADDRESS
je Lelse_23
mov rax, qword [rbp + 8 *(4 + 1)]
jmp Lexit_23
Lelse_23:
;applic tp:
push SOB_NIL_ADDRESS ; push magic
;applic:
         push SOB_NIL_ADDRESS ; push magic
mov rax, qword [rbp + 8 *(4 + 1)]
push rax ; calculate arg, rax holds arg, and push it
;applic:
         push SOB_NIL_ADDRESS ; push magic
mov rax, qword [rbp + 8 *(4 + 0)]
push rax ; calculate arg, rax holds arg, and push it
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * (1)]
mov rax, qword [rax + 8 * (0)]
push rax ; calculate arg, rax holds arg, and push it
push 2 ; push argcount
;next is proc:
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * (2)]
mov rax, qword [rax + 8 * (0)]
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
call qword [rax+9] ; call to code ptr
 add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8*rbx]; pop args
add rsp , 8 ; pop magic, which is sob_nil
push rax ; calculate arg, rax holds arg, and push it
push 2 ; push argcount
;next is proc:
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * (2)]
mov rax, qword [rax + 8 * (4)]
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
call qword [rax+9] ; call to code ptr
 add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8*rbx]; pop args
add rsp , 8 ; pop magic, which is sob_nil
push rax ; calculate arg, rax holds arg, and push it
;applic:
         push SOB_NIL_ADDRESS ; push magic
mov rax, const_tbl+34
push rax ; calculate arg, rax holds arg, and push it
mov rax, qword [rbp + 8 *(4 + 0)]
push rax ; calculate arg, rax holds arg, and push it
push 2 ; push argcount
;next is proc:
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * (2)]
mov rax, qword [rax + 8 * (3)]
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
call qword [rax+9] ; call to code ptr
 add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8*rbx]; pop args
add rsp , 8 ; pop magic, which is sob_nil
push rax ; calculate arg, rax holds arg, and push it
push 2 ; push argcount
;next is proc:
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * (0)]
mov rax, qword [rax + 8 * (0)]
mov rax, qword [rax]
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
push qword [rbp + 8 * 1] ; old ret addr
mov r11, qword [rbp]
SHIFT_FRAME_45:
mov r15, rbp
sub r15, 8 ; r15= adress in stack of first to move up
mov qword r14, [rbp + 8*3] ; r14=n
add r14, 4
shl r14, 3
add r14, rbp ; r14 = rbp+ 8*(4+n) , which is the adress we should overide first
; we are moving top down:
.loop_of_shifts:
  cmp r15, rsp
  jl .end_loop_of_shifts ; we finished
  mov qword r12, [r15]; r12 = element to move
  mov qword [r14], r12 ; move elemnt to top of stack
  sub r14, 8
  sub r15, 8
  jmp .loop_of_shifts
.end_loop_of_shifts:
  add r14, 8
  mov rsp, r14
  mov rbp, r11
  jmp qword [rax+9] ; jump to code ptr
 Lexit_23:

leave
ret
Lcont_61:
push rax
mov rax, qword [rbp + 8 *(4 + 0)]
pop qword [rax]
mov rax, SOB_VOID_ADDRESS
;applic tp:
push SOB_NIL_ADDRESS ; push magic
mov rax, const_tbl+1
push rax ; calculate arg, rax holds arg, and push it
;applic:
         push SOB_NIL_ADDRESS ; push magic
mov rax, const_tbl+34
push rax ; calculate arg, rax holds arg, and push it
;applic:
         push SOB_NIL_ADDRESS ; push magic
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * (0)]
mov rax, qword [rax + 8 * (0)]
push rax ; calculate arg, rax holds arg, and push it
push 1 ; push argcount
;next is proc:
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * (1)]
mov rax, qword [rax + 8 * (1)]
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
call qword [rax+9] ; call to code ptr
 add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8*rbx]; pop args
add rsp , 8 ; pop magic, which is sob_nil
push rax ; calculate arg, rax holds arg, and push it
push 2 ; push argcount
;next is proc:
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * (1)]
mov rax, qword [rax + 8 * (3)]
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
call qword [rax+9] ; call to code ptr
 add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8*rbx]; pop args
add rsp , 8 ; pop magic, which is sob_nil
push rax ; calculate arg, rax holds arg, and push it
push 2 ; push argcount
;next is proc:
mov rax, qword [rbp + 8 *(4 + 0)]
mov rax, qword [rax]
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
push qword [rbp + 8 * 1] ; old ret addr
mov r11, qword [rbp]
SHIFT_FRAME_46:
mov r15, rbp
sub r15, 8 ; r15= adress in stack of first to move up
mov qword r14, [rbp + 8*3] ; r14=n
add r14, 4
shl r14, 3
add r14, rbp ; r14 = rbp+ 8*(4+n) , which is the adress we should overide first
; we are moving top down:
.loop_of_shifts:
  cmp r15, rsp
  jl .end_loop_of_shifts ; we finished
  mov qword r12, [r15]; r12 = element to move
  mov qword [r14], r12 ; move elemnt to top of stack
  sub r14, 8
  sub r15, 8
  jmp .loop_of_shifts
.end_loop_of_shifts:
  add r14, 8
  mov rsp, r14
  mov rbp, r11
  jmp qword [rax+9] ; jump to code ptr
 
leave
ret
Lcont_60:
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
push qword [rbp + 8 * 1] ; old ret addr
mov r11, qword [rbp]
SHIFT_FRAME_44:
mov r15, rbp
sub r15, 8 ; r15= adress in stack of first to move up
mov qword r14, [rbp + 8*3] ; r14=n
add r14, 4
shl r14, 3
add r14, rbp ; r14 = rbp+ 8*(4+n) , which is the adress we should overide first
; we are moving top down:
.loop_of_shifts:
  cmp r15, rsp
  jl .end_loop_of_shifts ; we finished
  mov qword r12, [r15]; r12 = element to move
  mov qword [r14], r12 ; move elemnt to top of stack
  sub r14, 8
  sub r15, 8
  jmp .loop_of_shifts
.end_loop_of_shifts:
  add r14, 8
  mov rsp, r14
  mov rbp, r11
  jmp qword [rax+9] ; jump to code ptr
 
leave
ret
Lcont_59:

leave
ret
Lcont_58:
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
call qword [rax+9] ; call to code ptr
 add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8*rbx]; pop args
add rsp , 8 ; pop magic, which is sob_nil
mov [fvar_tbl+(8*44)], rax
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void

;applic:
         push SOB_NIL_ADDRESS ; push magic
mov rax, [fvar_tbl+ (8* 14)]
push rax ; calculate arg, rax holds arg, and push it
mov rax, [fvar_tbl+ (8* 29)]
push rax ; calculate arg, rax holds arg, and push it
mov rax, [fvar_tbl+ (8* 28)]
push rax ; calculate arg, rax holds arg, and push it
mov rax, [fvar_tbl+ (8* 17)]
push rax ; calculate arg, rax holds arg, and push it
mov rax, [fvar_tbl+ (8* 6)]
push rax ; calculate arg, rax holds arg, and push it
mov rax, [fvar_tbl+ (8* 5)]
push rax ; calculate arg, rax holds arg, and push it
mov rax, [fvar_tbl+ (8* 3)]
push rax ; calculate arg, rax holds arg, and push it
mov rax, [fvar_tbl+ (8* 1)]
push rax ; calculate arg, rax holds arg, and push it
mov rax, [fvar_tbl+ (8* 2)]
push rax ; calculate arg, rax holds arg, and push it
mov rax, [fvar_tbl+ (8* 44)]
push rax ; calculate arg, rax holds arg, and push it
mov rax, [fvar_tbl+ (8* 21)]
push rax ; calculate arg, rax holds arg, and push it
push 11 ; push argcount
;next is proc:
;we know that env = [rbp + 8*2]
; we know that depth is env.length
; now we SHOULD allocate extenv with size env.length+1= depth+1
MALLOC rax, 8*(1+0) ; rax->extEnv
mov rbx, 0 ;i
mov rcx, 1 ;j
;following loop is to shift the env in extended env
loop_123:
    cmp rbx, 0
    jge end_loop_123
    mov rdx, [rbp + 8*2] ; rdx = env
    shl rbx, 3
    add rdx, rbx ; env[i] =-->[var, var,...var] 
    shr rbx, 3
    mov r8, [rdx] 
    mov [rax + 8*rcx], r8 ; extEnv[j]=env[i]
    inc rcx
    inc rbx
    jmp loop_123
end_loop_123:
 ;  rax holds ->extEnv
;n= [rbp+8*3]
mov rbx, rax ;rbx holds extEnv
; Allocate ExtEnv[0] to point to a vector where to store the parameters
mov r8, [rbp+8*3] ; r8= n
inc r8; +magic
shl r8, 3
MALLOC r9, r8 ; r9 holds the vector for the params with size 8*n +1 for magic
shr r8, 3
dec r8; - magic
mov rcx, 0 ;i=0
;following loop is to Copy the parameters off of the stack to the extended env:
loop_124:
    cmp rcx ,r8 ; i<n
    jge end_loop_124
    mov rdx, [rbp+8*(4+rcx)] ;  rdx= param_i
    mov [r9+8*rcx], rdx ; ExtEnv [0][i]= param_i
    inc rcx
    jmp loop_124
end_loop_124:
mov qword [r9+8*rcx], SOB_NIL_ADDRESS; add magic to the end
mov [rbx], r9 ; updte the extEnv[0]-> vector that we created for the params

MAKE_CLOSURE(rax, rbx, Lcode_62)
 jmp Lcont_62
Lcode_62:
push rbp
mov rbp , rsp
;applic tp:
push SOB_NIL_ADDRESS ; push magic
mov rax, const_tbl+23
push rax ; calculate arg, rax holds arg, and push it
push 1 ; push argcount
;next is proc:
;we know that env = [rbp + 8*2]
; we know that depth is env.length
; now we SHOULD allocate extenv with size env.length+1= depth+1
MALLOC rax, 8*(1+1) ; rax->extEnv
mov rbx, 0 ;i
mov rcx, 1 ;j
;following loop is to shift the env in extended env
loop_125:
    cmp rbx, 1
    jge end_loop_125
    mov rdx, [rbp + 8*2] ; rdx = env
    shl rbx, 3
    add rdx, rbx ; env[i] =-->[var, var,...var] 
    shr rbx, 3
    mov r8, [rdx] 
    mov [rax + 8*rcx], r8 ; extEnv[j]=env[i]
    inc rcx
    inc rbx
    jmp loop_125
end_loop_125:
 ;  rax holds ->extEnv
;n= [rbp+8*3]
mov rbx, rax ;rbx holds extEnv
; Allocate ExtEnv[0] to point to a vector where to store the parameters
mov r8, [rbp+8*3] ; r8= n
inc r8; +magic
shl r8, 3
MALLOC r9, r8 ; r9 holds the vector for the params with size 8*n +1 for magic
shr r8, 3
dec r8; - magic
mov rcx, 0 ;i=0
;following loop is to Copy the parameters off of the stack to the extended env:
loop_126:
    cmp rcx ,r8 ; i<n
    jge end_loop_126
    mov rdx, [rbp+8*(4+rcx)] ;  rdx= param_i
    mov [r9+8*rcx], rdx ; ExtEnv [0][i]= param_i
    inc rcx
    jmp loop_126
end_loop_126:
mov qword [r9+8*rcx], SOB_NIL_ADDRESS; add magic to the end
mov [rbx], r9 ; updte the extEnv[0]-> vector that we created for the params

MAKE_CLOSURE(rax, rbx, Lcode_63)
 jmp Lcont_63
Lcode_63:
push rbp
mov rbp , rsp
MALLOC rax, 8
mov rbx, qword[rbp+ 8*(4+0)]
mov [rax], rbx
mov qword [rbp + 8 * (4 + (0))],rax
mov rax, SOB_VOID_ADDRESS
;we know that env = [rbp + 8*2]
; we know that depth is env.length
; now we SHOULD allocate extenv with size env.length+1= depth+1
MALLOC rax, 8*(1+2) ; rax->extEnv
mov rbx, 0 ;i
mov rcx, 1 ;j
;following loop is to shift the env in extended env
loop_127:
    cmp rbx, 2
    jge end_loop_127
    mov rdx, [rbp + 8*2] ; rdx = env
    shl rbx, 3
    add rdx, rbx ; env[i] =-->[var, var,...var] 
    shr rbx, 3
    mov r8, [rdx] 
    mov [rax + 8*rcx], r8 ; extEnv[j]=env[i]
    inc rcx
    inc rbx
    jmp loop_127
end_loop_127:
 ;  rax holds ->extEnv
;n= [rbp+8*3]
mov rbx, rax ;rbx holds extEnv
; Allocate ExtEnv[0] to point to a vector where to store the parameters
mov r8, [rbp+8*3] ; r8= n
inc r8; +magic
shl r8, 3
MALLOC r9, r8 ; r9 holds the vector for the params with size 8*n +1 for magic
shr r8, 3
dec r8; - magic
mov rcx, 0 ;i=0
;following loop is to Copy the parameters off of the stack to the extended env:
loop_128:
    cmp rcx ,r8 ; i<n
    jge end_loop_128
    mov rdx, [rbp+8*(4+rcx)] ;  rdx= param_i
    mov [r9+8*rcx], rdx ; ExtEnv [0][i]= param_i
    inc rcx
    jmp loop_128
end_loop_128:
mov qword [r9+8*rcx], SOB_NIL_ADDRESS; add magic to the end
mov [rbx], r9 ; updte the extEnv[0]-> vector that we created for the params

MAKE_CLOSURE(rax, rbx, Lcode_64)
 jmp Lcont_64
Lcode_64:
push rbp
mov rbp , rsp
;applic:
         push SOB_NIL_ADDRESS ; push magic
mov rax, qword [rbp + 8 *(4 + 0)]
push rax ; calculate arg, rax holds arg, and push it
push 1 ; push argcount
;next is proc:
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * (1)]
mov rax, qword [rax + 8 * (2)]
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
call qword [rax+9] ; call to code ptr
 add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8*rbx]; pop args
add rsp , 8 ; pop magic, which is sob_nil
cmp rax, SOB_FALSE_ADDRESS
je Lelse_34
;applic:
         push SOB_NIL_ADDRESS ; push magic
mov rax, qword [rbp + 8 *(4 + 1)]
push rax ; calculate arg, rax holds arg, and push it
push 1 ; push argcount
;next is proc:
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * (1)]
mov rax, qword [rax + 8 * (2)]
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
call qword [rax+9] ; call to code ptr
 add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8*rbx]; pop args
add rsp , 8 ; pop magic, which is sob_nil
jmp Lexit_34
Lelse_34:
mov rax, const_tbl+2
Lexit_34:
cmp rax, SOB_FALSE_ADDRESS
je Lelse_24
;applic tp:
push SOB_NIL_ADDRESS ; push magic
mov rax, qword [rbp + 8 *(4 + 1)]
push rax ; calculate arg, rax holds arg, and push it
mov rax, qword [rbp + 8 *(4 + 0)]
push rax ; calculate arg, rax holds arg, and push it
push 2 ; push argcount
;next is proc:
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * (1)]
mov rax, qword [rax + 8 * (0)]
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
push qword [rbp + 8 * 1] ; old ret addr
mov r11, qword [rbp]
SHIFT_FRAME_53:
mov r15, rbp
sub r15, 8 ; r15= adress in stack of first to move up
mov qword r14, [rbp + 8*3] ; r14=n
add r14, 4
shl r14, 3
add r14, rbp ; r14 = rbp+ 8*(4+n) , which is the adress we should overide first
; we are moving top down:
.loop_of_shifts:
  cmp r15, rsp
  jl .end_loop_of_shifts ; we finished
  mov qword r12, [r15]; r12 = element to move
  mov qword [r14], r12 ; move elemnt to top of stack
  sub r14, 8
  sub r15, 8
  jmp .loop_of_shifts
.end_loop_of_shifts:
  add r14, 8
  mov rsp, r14
  mov rbp, r11
  jmp qword [rax+9] ; jump to code ptr
 jmp Lexit_24
Lelse_24:
;applic:
         push SOB_NIL_ADDRESS ; push magic
mov rax, qword [rbp + 8 *(4 + 0)]
push rax ; calculate arg, rax holds arg, and push it
push 1 ; push argcount
;next is proc:
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * (1)]
mov rax, qword [rax + 8 * (3)]
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
call qword [rax+9] ; call to code ptr
 add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8*rbx]; pop args
add rsp , 8 ; pop magic, which is sob_nil
cmp rax, SOB_FALSE_ADDRESS
je Lelse_33
;applic:
         push SOB_NIL_ADDRESS ; push magic
mov rax, qword [rbp + 8 *(4 + 1)]
push rax ; calculate arg, rax holds arg, and push it
push 1 ; push argcount
;next is proc:
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * (1)]
mov rax, qword [rax + 8 * (3)]
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
call qword [rax+9] ; call to code ptr
 add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8*rbx]; pop args
add rsp , 8 ; pop magic, which is sob_nil
jmp Lexit_33
Lelse_33:
mov rax, const_tbl+2
Lexit_33:
cmp rax, SOB_FALSE_ADDRESS
je Lelse_25
;applic tp:
push SOB_NIL_ADDRESS ; push magic
mov rax, qword [rbp + 8 *(4 + 1)]
push rax ; calculate arg, rax holds arg, and push it
mov rax, qword [rbp + 8 *(4 + 0)]
push rax ; calculate arg, rax holds arg, and push it
push 2 ; push argcount
;next is proc:
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * (1)]
mov rax, qword [rax + 8 * (0)]
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
push qword [rbp + 8 * 1] ; old ret addr
mov r11, qword [rbp]
SHIFT_FRAME_52:
mov r15, rbp
sub r15, 8 ; r15= adress in stack of first to move up
mov qword r14, [rbp + 8*3] ; r14=n
add r14, 4
shl r14, 3
add r14, rbp ; r14 = rbp+ 8*(4+n) , which is the adress we should overide first
; we are moving top down:
.loop_of_shifts:
  cmp r15, rsp
  jl .end_loop_of_shifts ; we finished
  mov qword r12, [r15]; r12 = element to move
  mov qword [r14], r12 ; move elemnt to top of stack
  sub r14, 8
  sub r15, 8
  jmp .loop_of_shifts
.end_loop_of_shifts:
  add r14, 8
  mov rsp, r14
  mov rbp, r11
  jmp qword [rax+9] ; jump to code ptr
 jmp Lexit_25
Lelse_25:
;applic:
         push SOB_NIL_ADDRESS ; push magic
mov rax, qword [rbp + 8 *(4 + 0)]
push rax ; calculate arg, rax holds arg, and push it
push 1 ; push argcount
;next is proc:
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * (1)]
mov rax, qword [rax + 8 * (5)]
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
call qword [rax+9] ; call to code ptr
 add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8*rbx]; pop args
add rsp , 8 ; pop magic, which is sob_nil
cmp rax, SOB_FALSE_ADDRESS
je Lelse_32
;applic:
         push SOB_NIL_ADDRESS ; push magic
mov rax, qword [rbp + 8 *(4 + 1)]
push rax ; calculate arg, rax holds arg, and push it
push 1 ; push argcount
;next is proc:
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * (1)]
mov rax, qword [rax + 8 * (5)]
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
call qword [rax+9] ; call to code ptr
 add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8*rbx]; pop args
add rsp , 8 ; pop magic, which is sob_nil
jmp Lexit_32
Lelse_32:
mov rax, const_tbl+2
Lexit_32:
cmp rax, SOB_FALSE_ADDRESS
je Lelse_26
;applic tp:
push SOB_NIL_ADDRESS ; push magic
;applic:
         push SOB_NIL_ADDRESS ; push magic
mov rax, qword [rbp + 8 *(4 + 1)]
push rax ; calculate arg, rax holds arg, and push it
push 1 ; push argcount
;next is proc:
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * (1)]
mov rax, qword [rax + 8 * (10)]
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
call qword [rax+9] ; call to code ptr
 add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8*rbx]; pop args
add rsp , 8 ; pop magic, which is sob_nil
push rax ; calculate arg, rax holds arg, and push it
;applic:
         push SOB_NIL_ADDRESS ; push magic
mov rax, qword [rbp + 8 *(4 + 0)]
push rax ; calculate arg, rax holds arg, and push it
push 1 ; push argcount
;next is proc:
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * (1)]
mov rax, qword [rax + 8 * (10)]
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
call qword [rax+9] ; call to code ptr
 add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8*rbx]; pop args
add rsp , 8 ; pop magic, which is sob_nil
push rax ; calculate arg, rax holds arg, and push it
push 2 ; push argcount
;next is proc:
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * (1)]
mov rax, qword [rax + 8 * (0)]
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
push qword [rbp + 8 * 1] ; old ret addr
mov r11, qword [rbp]
SHIFT_FRAME_51:
mov r15, rbp
sub r15, 8 ; r15= adress in stack of first to move up
mov qword r14, [rbp + 8*3] ; r14=n
add r14, 4
shl r14, 3
add r14, rbp ; r14 = rbp+ 8*(4+n) , which is the adress we should overide first
; we are moving top down:
.loop_of_shifts:
  cmp r15, rsp
  jl .end_loop_of_shifts ; we finished
  mov qword r12, [r15]; r12 = element to move
  mov qword [r14], r12 ; move elemnt to top of stack
  sub r14, 8
  sub r15, 8
  jmp .loop_of_shifts
.end_loop_of_shifts:
  add r14, 8
  mov rsp, r14
  mov rbp, r11
  jmp qword [rax+9] ; jump to code ptr
 jmp Lexit_26
Lelse_26:
;applic:
         push SOB_NIL_ADDRESS ; push magic
mov rax, qword [rbp + 8 *(4 + 0)]
push rax ; calculate arg, rax holds arg, and push it
push 1 ; push argcount
;next is proc:
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * (1)]
mov rax, qword [rax + 8 * (4)]
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
call qword [rax+9] ; call to code ptr
 add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8*rbx]; pop args
add rsp , 8 ; pop magic, which is sob_nil
cmp rax, SOB_FALSE_ADDRESS
je Lelse_31
;applic:
         push SOB_NIL_ADDRESS ; push magic
mov rax, qword [rbp + 8 *(4 + 1)]
push rax ; calculate arg, rax holds arg, and push it
push 1 ; push argcount
;next is proc:
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * (1)]
mov rax, qword [rax + 8 * (4)]
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
call qword [rax+9] ; call to code ptr
 add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8*rbx]; pop args
add rsp , 8 ; pop magic, which is sob_nil
jmp Lexit_31
Lelse_31:
mov rax, const_tbl+2
Lexit_31:
cmp rax, SOB_FALSE_ADDRESS
je Lelse_27
;applic:
         push SOB_NIL_ADDRESS ; push magic
;applic:
         push SOB_NIL_ADDRESS ; push magic
mov rax, qword [rbp + 8 *(4 + 1)]
push rax ; calculate arg, rax holds arg, and push it
push 1 ; push argcount
;next is proc:
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * (1)]
mov rax, qword [rax + 8 * (8)]
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
call qword [rax+9] ; call to code ptr
 add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8*rbx]; pop args
add rsp , 8 ; pop magic, which is sob_nil
push rax ; calculate arg, rax holds arg, and push it
;applic:
         push SOB_NIL_ADDRESS ; push magic
mov rax, qword [rbp + 8 *(4 + 0)]
push rax ; calculate arg, rax holds arg, and push it
push 1 ; push argcount
;next is proc:
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * (1)]
mov rax, qword [rax + 8 * (8)]
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
call qword [rax+9] ; call to code ptr
 add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8*rbx]; pop args
add rsp , 8 ; pop magic, which is sob_nil
push rax ; calculate arg, rax holds arg, and push it
push 2 ; push argcount
;next is proc:
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * (0)]
mov rax, qword [rax + 8 * (0)]
mov rax, qword [rax]
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
call qword [rax+9] ; call to code ptr
 add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8*rbx]; pop args
add rsp , 8 ; pop magic, which is sob_nil
cmp rax, SOB_FALSE_ADDRESS
je Lelse_30
;applic tp:
push SOB_NIL_ADDRESS ; push magic
;applic:
         push SOB_NIL_ADDRESS ; push magic
mov rax, qword [rbp + 8 *(4 + 1)]
push rax ; calculate arg, rax holds arg, and push it
push 1 ; push argcount
;next is proc:
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * (1)]
mov rax, qword [rax + 8 * (9)]
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
call qword [rax+9] ; call to code ptr
 add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8*rbx]; pop args
add rsp , 8 ; pop magic, which is sob_nil
push rax ; calculate arg, rax holds arg, and push it
;applic:
         push SOB_NIL_ADDRESS ; push magic
mov rax, qword [rbp + 8 *(4 + 0)]
push rax ; calculate arg, rax holds arg, and push it
push 1 ; push argcount
;next is proc:
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * (1)]
mov rax, qword [rax + 8 * (9)]
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
call qword [rax+9] ; call to code ptr
 add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8*rbx]; pop args
add rsp , 8 ; pop magic, which is sob_nil
push rax ; calculate arg, rax holds arg, and push it
push 2 ; push argcount
;next is proc:
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * (0)]
mov rax, qword [rax + 8 * (0)]
mov rax, qword [rax]
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
push qword [rbp + 8 * 1] ; old ret addr
mov r11, qword [rbp]
SHIFT_FRAME_50:
mov r15, rbp
sub r15, 8 ; r15= adress in stack of first to move up
mov qword r14, [rbp + 8*3] ; r14=n
add r14, 4
shl r14, 3
add r14, rbp ; r14 = rbp+ 8*(4+n) , which is the adress we should overide first
; we are moving top down:
.loop_of_shifts:
  cmp r15, rsp
  jl .end_loop_of_shifts ; we finished
  mov qword r12, [r15]; r12 = element to move
  mov qword [r14], r12 ; move elemnt to top of stack
  sub r14, 8
  sub r15, 8
  jmp .loop_of_shifts
.end_loop_of_shifts:
  add r14, 8
  mov rsp, r14
  mov rbp, r11
  jmp qword [rax+9] ; jump to code ptr
 jmp Lexit_30
Lelse_30:
mov rax, const_tbl+2
Lexit_30:
jmp Lexit_27
Lelse_27:
;applic:
         push SOB_NIL_ADDRESS ; push magic
mov rax, qword [rbp + 8 *(4 + 0)]
push rax ; calculate arg, rax holds arg, and push it
push 1 ; push argcount
;next is proc:
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * (1)]
mov rax, qword [rax + 8 * (6)]
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
call qword [rax+9] ; call to code ptr
 add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8*rbx]; pop args
add rsp , 8 ; pop magic, which is sob_nil
cmp rax, SOB_FALSE_ADDRESS
je Lelse_29
;applic:
         push SOB_NIL_ADDRESS ; push magic
mov rax, qword [rbp + 8 *(4 + 1)]
push rax ; calculate arg, rax holds arg, and push it
push 1 ; push argcount
;next is proc:
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * (1)]
mov rax, qword [rax + 8 * (6)]
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
call qword [rax+9] ; call to code ptr
 add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8*rbx]; pop args
add rsp , 8 ; pop magic, which is sob_nil
jmp Lexit_29
Lelse_29:
mov rax, const_tbl+2
Lexit_29:
cmp rax, SOB_FALSE_ADDRESS
je Lelse_28
;applic tp:
push SOB_NIL_ADDRESS ; push magic
;applic:
         push SOB_NIL_ADDRESS ; push magic
mov rax, qword [rbp + 8 *(4 + 1)]
push rax ; calculate arg, rax holds arg, and push it
push 1 ; push argcount
;next is proc:
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * (1)]
mov rax, qword [rax + 8 * (1)]
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
call qword [rax+9] ; call to code ptr
 add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8*rbx]; pop args
add rsp , 8 ; pop magic, which is sob_nil
push rax ; calculate arg, rax holds arg, and push it
;applic:
         push SOB_NIL_ADDRESS ; push magic
mov rax, qword [rbp + 8 *(4 + 0)]
push rax ; calculate arg, rax holds arg, and push it
push 1 ; push argcount
;next is proc:
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * (1)]
mov rax, qword [rax + 8 * (1)]
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
call qword [rax+9] ; call to code ptr
 add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8*rbx]; pop args
add rsp , 8 ; pop magic, which is sob_nil
push rax ; calculate arg, rax holds arg, and push it
push 2 ; push argcount
;next is proc:
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * (0)]
mov rax, qword [rax + 8 * (0)]
mov rax, qword [rax]
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
push qword [rbp + 8 * 1] ; old ret addr
mov r11, qword [rbp]
SHIFT_FRAME_49:
mov r15, rbp
sub r15, 8 ; r15= adress in stack of first to move up
mov qword r14, [rbp + 8*3] ; r14=n
add r14, 4
shl r14, 3
add r14, rbp ; r14 = rbp+ 8*(4+n) , which is the adress we should overide first
; we are moving top down:
.loop_of_shifts:
  cmp r15, rsp
  jl .end_loop_of_shifts ; we finished
  mov qword r12, [r15]; r12 = element to move
  mov qword [r14], r12 ; move elemnt to top of stack
  sub r14, 8
  sub r15, 8
  jmp .loop_of_shifts
.end_loop_of_shifts:
  add r14, 8
  mov rsp, r14
  mov rbp, r11
  jmp qword [rax+9] ; jump to code ptr
 jmp Lexit_28
Lelse_28:
;applic tp:
push SOB_NIL_ADDRESS ; push magic
mov rax, qword [rbp + 8 *(4 + 1)]
push rax ; calculate arg, rax holds arg, and push it
mov rax, qword [rbp + 8 *(4 + 0)]
push rax ; calculate arg, rax holds arg, and push it
push 2 ; push argcount
;next is proc:
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * (1)]
mov rax, qword [rax + 8 * (7)]
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
push qword [rbp + 8 * 1] ; old ret addr
mov r11, qword [rbp]
SHIFT_FRAME_48:
mov r15, rbp
sub r15, 8 ; r15= adress in stack of first to move up
mov qword r14, [rbp + 8*3] ; r14=n
add r14, 4
shl r14, 3
add r14, rbp ; r14 = rbp+ 8*(4+n) , which is the adress we should overide first
; we are moving top down:
.loop_of_shifts:
  cmp r15, rsp
  jl .end_loop_of_shifts ; we finished
  mov qword r12, [r15]; r12 = element to move
  mov qword [r14], r12 ; move elemnt to top of stack
  sub r14, 8
  sub r15, 8
  jmp .loop_of_shifts
.end_loop_of_shifts:
  add r14, 8
  mov rsp, r14
  mov rbp, r11
  jmp qword [rax+9] ; jump to code ptr
 Lexit_28:
Lexit_27:
Lexit_26:
Lexit_25:
Lexit_24:

leave
ret
Lcont_64:
push rax
mov rax, qword [rbp + 8 *(4 + 0)]
pop qword [rax]
mov rax, SOB_VOID_ADDRESS
mov rax, qword [rbp + 8 *(4 + 0)]
mov rax, qword [rax]

leave
ret
Lcont_63:
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
push qword [rbp + 8 * 1] ; old ret addr
mov r11, qword [rbp]
SHIFT_FRAME_47:
mov r15, rbp
sub r15, 8 ; r15= adress in stack of first to move up
mov qword r14, [rbp + 8*3] ; r14=n
add r14, 4
shl r14, 3
add r14, rbp ; r14 = rbp+ 8*(4+n) , which is the adress we should overide first
; we are moving top down:
.loop_of_shifts:
  cmp r15, rsp
  jl .end_loop_of_shifts ; we finished
  mov qword r12, [r15]; r12 = element to move
  mov qword [r14], r12 ; move elemnt to top of stack
  sub r14, 8
  sub r15, 8
  jmp .loop_of_shifts
.end_loop_of_shifts:
  add r14, 8
  mov rsp, r14
  mov rbp, r11
  jmp qword [rax+9] ; jump to code ptr
 
leave
ret
Lcont_62:
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
call qword [rax+9] ; call to code ptr
 add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8*rbx]; pop args
add rsp , 8 ; pop magic, which is sob_nil
mov [fvar_tbl+(8*32)], rax
mov rax, SOB_VOID_ADDRESS

	call write_sob_if_not_void

;applic:
         push SOB_NIL_ADDRESS ; push magic
mov rax, const_tbl+23
push rax ; calculate arg, rax holds arg, and push it
mov rax, const_tbl+23
push rax ; calculate arg, rax holds arg, and push it
push 2 ; push argcount
;next is proc:
;we know that env = [rbp + 8*2]
; we know that depth is env.length
; now we SHOULD allocate extenv with size env.length+1= depth+1
MALLOC rax, 8*(1+0) ; rax->extEnv
mov rbx, 0 ;i
mov rcx, 1 ;j
;following loop is to shift the env in extended env
loop_129:
    cmp rbx, 0
    jge end_loop_129
    mov rdx, [rbp + 8*2] ; rdx = env
    shl rbx, 3
    add rdx, rbx ; env[i] =-->[var, var,...var] 
    shr rbx, 3
    mov r8, [rdx] 
    mov [rax + 8*rcx], r8 ; extEnv[j]=env[i]
    inc rcx
    inc rbx
    jmp loop_129
end_loop_129:
 ;  rax holds ->extEnv
;n= [rbp+8*3]
mov rbx, rax ;rbx holds extEnv
; Allocate ExtEnv[0] to point to a vector where to store the parameters
mov r8, [rbp+8*3] ; r8= n
inc r8; +magic
shl r8, 3
MALLOC r9, r8 ; r9 holds the vector for the params with size 8*n +1 for magic
shr r8, 3
dec r8; - magic
mov rcx, 0 ;i=0
;following loop is to Copy the parameters off of the stack to the extended env:
loop_130:
    cmp rcx ,r8 ; i<n
    jge end_loop_130
    mov rdx, [rbp+8*(4+rcx)] ;  rdx= param_i
    mov [r9+8*rcx], rdx ; ExtEnv [0][i]= param_i
    inc rcx
    jmp loop_130
end_loop_130:
mov qword [r9+8*rcx], SOB_NIL_ADDRESS; add magic to the end
mov [rbx], r9 ; updte the extEnv[0]-> vector that we created for the params

MAKE_CLOSURE(rax, rbx, Lcode_65)
 jmp Lcont_65
Lcode_65:
push rbp
mov rbp , rsp
MALLOC rax, 8
mov rbx, qword[rbp+ 8*(4+0)]
mov [rax], rbx
mov qword [rbp + 8 * (4 + (0))],rax
mov rax, SOB_VOID_ADDRESS
MALLOC rax, 8
mov rbx, qword[rbp+ 8*(4+1)]
mov [rax], rbx
mov qword [rbp + 8 * (4 + (1))],rax
mov rax, SOB_VOID_ADDRESS
;we know that env = [rbp + 8*2]
; we know that depth is env.length
; now we SHOULD allocate extenv with size env.length+1= depth+1
MALLOC rax, 8*(1+1) ; rax->extEnv
mov rbx, 0 ;i
mov rcx, 1 ;j
;following loop is to shift the env in extended env
loop_131:
    cmp rbx, 1
    jge end_loop_131
    mov rdx, [rbp + 8*2] ; rdx = env
    shl rbx, 3
    add rdx, rbx ; env[i] =-->[var, var,...var] 
    shr rbx, 3
    mov r8, [rdx] 
    mov [rax + 8*rcx], r8 ; extEnv[j]=env[i]
    inc rcx
    inc rbx
    jmp loop_131
end_loop_131:
 ;  rax holds ->extEnv
;n= [rbp+8*3]
mov rbx, rax ;rbx holds extEnv
; Allocate ExtEnv[0] to point to a vector where to store the parameters
mov r8, [rbp+8*3] ; r8= n
inc r8; +magic
shl r8, 3
MALLOC r9, r8 ; r9 holds the vector for the params with size 8*n +1 for magic
shr r8, 3
dec r8; - magic
mov rcx, 0 ;i=0
;following loop is to Copy the parameters off of the stack to the extended env:
loop_132:
    cmp rcx ,r8 ; i<n
    jge end_loop_132
    mov rdx, [rbp+8*(4+rcx)] ;  rdx= param_i
    mov [r9+8*rcx], rdx ; ExtEnv [0][i]= param_i
    inc rcx
    jmp loop_132
end_loop_132:
mov qword [r9+8*rcx], SOB_NIL_ADDRESS; add magic to the end
mov [rbx], r9 ; updte the extEnv[0]-> vector that we created for the params

MAKE_CLOSURE(rax, rbx, Lcode_66)
 jmp Lcont_66
Lcode_66:
push rbp
mov rbp , rsp
;applic:
         push SOB_NIL_ADDRESS ; push magic
mov rax, qword [rbp + 8 *(4 + 0)]
push rax ; calculate arg, rax holds arg, and push it
push 1 ; push argcount
;next is proc:
mov rax, [fvar_tbl+ (8* 45)]
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
call qword [rax+9] ; call to code ptr
 add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8*rbx]; pop args
add rsp , 8 ; pop magic, which is sob_nil
cmp rax, SOB_FALSE_ADDRESS
je Lelse_35
mov rax, const_tbl+4
jmp Lexit_35
Lelse_35:
;applic tp:
push SOB_NIL_ADDRESS ; push magic
;applic:
         push SOB_NIL_ADDRESS ; push magic
mov rax, const_tbl+34
push rax ; calculate arg, rax holds arg, and push it
mov rax, qword [rbp + 8 *(4 + 0)]
push rax ; calculate arg, rax holds arg, and push it
push 2 ; push argcount
;next is proc:
mov rax, [fvar_tbl+ (8* 46)]
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
call qword [rax+9] ; call to code ptr
 add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8*rbx]; pop args
add rsp , 8 ; pop magic, which is sob_nil
push rax ; calculate arg, rax holds arg, and push it
push 1 ; push argcount
;next is proc:
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * (0)]
mov rax, qword [rax + 8 * (1)]
mov rax, qword [rax]
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
push qword [rbp + 8 * 1] ; old ret addr
mov r11, qword [rbp]
SHIFT_FRAME_54:
mov r15, rbp
sub r15, 8 ; r15= adress in stack of first to move up
mov qword r14, [rbp + 8*3] ; r14=n
add r14, 4
shl r14, 3
add r14, rbp ; r14 = rbp+ 8*(4+n) , which is the adress we should overide first
; we are moving top down:
.loop_of_shifts:
  cmp r15, rsp
  jl .end_loop_of_shifts ; we finished
  mov qword r12, [r15]; r12 = element to move
  mov qword [r14], r12 ; move elemnt to top of stack
  sub r14, 8
  sub r15, 8
  jmp .loop_of_shifts
.end_loop_of_shifts:
  add r14, 8
  mov rsp, r14
  mov rbp, r11
  jmp qword [rax+9] ; jump to code ptr
 Lexit_35:

leave
ret
Lcont_66:
push rax
mov rax, qword [rbp + 8 *(4 + 0)]
pop qword [rax]
mov rax, SOB_VOID_ADDRESS
;we know that env = [rbp + 8*2]
; we know that depth is env.length
; now we SHOULD allocate extenv with size env.length+1= depth+1
MALLOC rax, 8*(1+1) ; rax->extEnv
mov rbx, 0 ;i
mov rcx, 1 ;j
;following loop is to shift the env in extended env
loop_133:
    cmp rbx, 1
    jge end_loop_133
    mov rdx, [rbp + 8*2] ; rdx = env
    shl rbx, 3
    add rdx, rbx ; env[i] =-->[var, var,...var] 
    shr rbx, 3
    mov r8, [rdx] 
    mov [rax + 8*rcx], r8 ; extEnv[j]=env[i]
    inc rcx
    inc rbx
    jmp loop_133
end_loop_133:
 ;  rax holds ->extEnv
;n= [rbp+8*3]
mov rbx, rax ;rbx holds extEnv
; Allocate ExtEnv[0] to point to a vector where to store the parameters
mov r8, [rbp+8*3] ; r8= n
inc r8; +magic
shl r8, 3
MALLOC r9, r8 ; r9 holds the vector for the params with size 8*n +1 for magic
shr r8, 3
dec r8; - magic
mov rcx, 0 ;i=0
;following loop is to Copy the parameters off of the stack to the extended env:
loop_134:
    cmp rcx ,r8 ; i<n
    jge end_loop_134
    mov rdx, [rbp+8*(4+rcx)] ;  rdx= param_i
    mov [r9+8*rcx], rdx ; ExtEnv [0][i]= param_i
    inc rcx
    jmp loop_134
end_loop_134:
mov qword [r9+8*rcx], SOB_NIL_ADDRESS; add magic to the end
mov [rbx], r9 ; updte the extEnv[0]-> vector that we created for the params

MAKE_CLOSURE(rax, rbx, Lcode_67)
 jmp Lcont_67
Lcode_67:
push rbp
mov rbp , rsp
;applic:
         push SOB_NIL_ADDRESS ; push magic
mov rax, qword [rbp + 8 *(4 + 0)]
push rax ; calculate arg, rax holds arg, and push it
push 1 ; push argcount
;next is proc:
mov rax, [fvar_tbl+ (8* 45)]
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
call qword [rax+9] ; call to code ptr
 add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8*rbx]; pop args
add rsp , 8 ; pop magic, which is sob_nil
cmp rax, SOB_FALSE_ADDRESS
je Lelse_36
mov rax, const_tbl+2
jmp Lexit_36
Lelse_36:
;applic tp:
push SOB_NIL_ADDRESS ; push magic
;applic:
         push SOB_NIL_ADDRESS ; push magic
mov rax, const_tbl+34
push rax ; calculate arg, rax holds arg, and push it
mov rax, qword [rbp + 8 *(4 + 0)]
push rax ; calculate arg, rax holds arg, and push it
push 2 ; push argcount
;next is proc:
mov rax, [fvar_tbl+ (8* 46)]
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
call qword [rax+9] ; call to code ptr
 add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8*rbx]; pop args
add rsp , 8 ; pop magic, which is sob_nil
push rax ; calculate arg, rax holds arg, and push it
push 1 ; push argcount
;next is proc:
mov rax, qword [rbp + 8 * 2]
mov rax, qword [rax + 8 * (0)]
mov rax, qword [rax + 8 * (0)]
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
push qword [rbp + 8 * 1] ; old ret addr
mov r11, qword [rbp]
SHIFT_FRAME_55:
mov r15, rbp
sub r15, 8 ; r15= adress in stack of first to move up
mov qword r14, [rbp + 8*3] ; r14=n
add r14, 4
shl r14, 3
add r14, rbp ; r14 = rbp+ 8*(4+n) , which is the adress we should overide first
; we are moving top down:
.loop_of_shifts:
  cmp r15, rsp
  jl .end_loop_of_shifts ; we finished
  mov qword r12, [r15]; r12 = element to move
  mov qword [r14], r12 ; move elemnt to top of stack
  sub r14, 8
  sub r15, 8
  jmp .loop_of_shifts
.end_loop_of_shifts:
  add r14, 8
  mov rsp, r14
  mov rbp, r11
  jmp qword [rax+9] ; jump to code ptr
 Lexit_36:

leave
ret
Lcont_67:
push rax
mov rax, qword [rbp + 8 *(4 + 1)]
pop qword [rax]
mov rax, SOB_VOID_ADDRESS
;applic tp:
push SOB_NIL_ADDRESS ; push magic
mov rax, const_tbl+85
push rax ; calculate arg, rax holds arg, and push it
push 1 ; push argcount
;next is proc:
mov rax, qword [rbp + 8 *(4 + 0)]
mov rax, qword [rax]
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
push qword [rbp + 8 * 1] ; old ret addr
mov r11, qword [rbp]
SHIFT_FRAME_56:
mov r15, rbp
sub r15, 8 ; r15= adress in stack of first to move up
mov qword r14, [rbp + 8*3] ; r14=n
add r14, 4
shl r14, 3
add r14, rbp ; r14 = rbp+ 8*(4+n) , which is the adress we should overide first
; we are moving top down:
.loop_of_shifts:
  cmp r15, rsp
  jl .end_loop_of_shifts ; we finished
  mov qword r12, [r15]; r12 = element to move
  mov qword [r14], r12 ; move elemnt to top of stack
  sub r14, 8
  sub r15, 8
  jmp .loop_of_shifts
.end_loop_of_shifts:
  add r14, 8
  mov rsp, r14
  mov rbp, r11
  jmp qword [rax+9] ; jump to code ptr
 
leave
ret
Lcont_65:
; we back from calculating proc
cmp byte [rax], T_CLOSURE
jne appError ;verify clousre
push qword [rax+1] ; push env
call qword [rax+9] ; call to code ptr
 add rsp , 8*1 ; pop env
pop rbx ; pop arg count
lea rsp , [rsp + 8*rbx]; pop args
add rsp , 8 ; pop magic, which is sob_nil

	call write_sob_if_not_void;;; Clean up the dummy frame, set the exit status to 0 ("success"), 
   ;;; and return from main
  pop rbp
  add rsp, 3*8
  mov rax, 0
  ret
  appError:
    pop rbp
    add rsp, 3*8
    mov rax, 1
  ret
boolean?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_BOOL
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

flonum?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_FLOAT
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

rational?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_RATIONAL
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

pair?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_PAIR
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

null?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_NIL
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

char?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_CHAR
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

string?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_STRING
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

symbol?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_SYMBOL
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

procedure?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov sil, byte [rsi]
	cmp sil, T_CLOSURE
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

div:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	mov dl, byte [rsi]
             cmp dl, T_FLOAT
	     jne .div_rat
             FLOAT_VAL rsi, rsi 
          movq xmm0, rsi
          FLOAT_VAL rdi, rdi 
          movq xmm1, rdi
	  divsd xmm0, xmm1
          movq rsi, xmm0
          MAKE_FLOAT(rax, rsi)
             jmp .op_return
          .div_rat:
             DENOMINATOR rcx, rsi
	  DENOMINATOR rdx, rdi
	  NUMERATOR rsi, rsi
	  NUMERATOR rdi, rdi
          MAKE_RATIONAL(rax, rdx, rdi)
         mov PVAR(1), rax
         pop rbp
         jmp mul
	  mov rax, rcx
	  mov rdi, rsi
          .gcd_loop:
     and rdi, rdi
     jz .end_gcd_loop
     cqo
     idiv rdi
     mov rax, rdi
     mov rdi, rdx
     jmp .gcd_loop	
     .end_gcd_loop:
	  mov rdi, rax
	  mov rax, rsi
	  cqo
	  idiv rdi
	  mov rsi, rax
	  mov rax, rcx
	  cqo
	  idiv rdi
	  mov rcx, rax
          cmp rcx, 0
          jge .make_rat
          imul rsi, -1
          imul rcx, -1
          .make_rat:
          MAKE_RATIONAL(rax, rsi, rcx)
          .op_return:
         pop rbp
         ret

mul:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	mov dl, byte [rsi]
             cmp dl, T_FLOAT
	     jne .mul_rat
             FLOAT_VAL rsi, rsi 
          movq xmm0, rsi
          FLOAT_VAL rdi, rdi 
          movq xmm1, rdi
	  mulsd xmm0, xmm1
          movq rsi, xmm0
          MAKE_FLOAT(rax, rsi)
             jmp .op_return
          .mul_rat:
             DENOMINATOR rcx, rsi
	  DENOMINATOR rdx, rdi
	  NUMERATOR rsi, rsi
	  NUMERATOR rdi, rdi
          imul rsi, rdi
	 imul rcx, rdx
	  mov rax, rcx
	  mov rdi, rsi
          .gcd_loop:
     and rdi, rdi
     jz .end_gcd_loop
     cqo
     idiv rdi
     mov rax, rdi
     mov rdi, rdx
     jmp .gcd_loop	
     .end_gcd_loop:
	  mov rdi, rax
	  mov rax, rsi
	  cqo
	  idiv rdi
	  mov rsi, rax
	  mov rax, rcx
	  cqo
	  idiv rdi
	  mov rcx, rax
          cmp rcx, 0
          jge .make_rat
          imul rsi, -1
          imul rcx, -1
          .make_rat:
          MAKE_RATIONAL(rax, rsi, rcx)
          .op_return:
         pop rbp
         ret

add:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	mov dl, byte [rsi]
             cmp dl, T_FLOAT
	     jne .add_rat
             FLOAT_VAL rsi, rsi 
          movq xmm0, rsi
          FLOAT_VAL rdi, rdi 
          movq xmm1, rdi
	  addsd xmm0, xmm1
          movq rsi, xmm0
          MAKE_FLOAT(rax, rsi)
             jmp .op_return
          .add_rat:
             DENOMINATOR rcx, rsi
	  DENOMINATOR rdx, rdi
	  NUMERATOR rsi, rsi
	  NUMERATOR rdi, rdi
          imul rsi, rdx
	 imul rdi, rcx
	 add rsi, rdi
	 imul rcx, rdx
	  mov rax, rcx
	  mov rdi, rsi
          .gcd_loop:
     and rdi, rdi
     jz .end_gcd_loop
     cqo
     idiv rdi
     mov rax, rdi
     mov rdi, rdx
     jmp .gcd_loop	
     .end_gcd_loop:
	  mov rdi, rax
	  mov rax, rsi
	  cqo
	  idiv rdi
	  mov rsi, rax
	  mov rax, rcx
	  cqo
	  idiv rdi
	  mov rcx, rax
          cmp rcx, 0
          jge .make_rat
          imul rsi, -1
          imul rcx, -1
          .make_rat:
          MAKE_RATIONAL(rax, rsi, rcx)
          .op_return:
         pop rbp
         ret

eq:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	mov dl, byte [rsi]
             cmp dl, T_FLOAT
	     jne .eq_rat
             FLOAT_VAL rsi, rsi
	 FLOAT_VAL rdi, rdi
	 cmp rsi, rdi
             jmp .op_return
          .eq_rat:
             NUMERATOR rcx, rsi
	 NUMERATOR rdx, rdi
	 cmp rcx, rdx
	 jne .false
	 DENOMINATOR rcx, rsi
	 DENOMINATOR rdx, rdi
	 cmp rcx, rdx
         .false:
          .op_return:
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

lt:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	mov dl, byte [rsi]
             cmp dl, T_FLOAT
	     jne .lt_rat
             FLOAT_VAL rsi, rsi
	 movq xmm0, rsi
	 FLOAT_VAL rdi, rdi
	 movq xmm1, rdi
	 cmpltpd xmm0, xmm1
         movq rsi, xmm0
         cmp rsi, 0
             jmp .op_return
          .lt_rat:
             DENOMINATOR rcx, rsi
	 DENOMINATOR rdx, rdi
	 NUMERATOR rsi, rsi
	 NUMERATOR rdi, rdi
	 imul rsi, rdx
	 imul rdi, rcx
	 cmp rsi, rdi
          .op_return:
      jl .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

string_length:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	STRING_LENGTH rsi, rsi
         MAKE_RATIONAL(rax, rsi, 1)
         pop rbp
         ret

string_ref:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	STRING_ELEMENTS rsi, rsi
         NUMERATOR rdi, rdi
         add rsi, rdi
         mov sil, byte [rsi]
         MAKE_CHAR(rax, sil)
         pop rbp
         ret

string_set:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	mov rdx, PVAR(2)
	STRING_ELEMENTS rsi, rsi
         NUMERATOR rdi, rdi
         add rsi, rdi
         CHAR_VAL rax, rdx
         mov byte [rsi], al
         mov rax, SOB_VOID_ADDRESS
         pop rbp
         ret

make_string:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	NUMERATOR rsi, rsi
         CHAR_VAL rdi, rdi
         and rdi, 255
         MAKE_STRING rax, rsi, dil
         pop rbp
         ret

symbol_to_string:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	SYMBOL_VAL rsi, rsi
	 STRING_LENGTH rcx, rsi
	 STRING_ELEMENTS rdi, rsi
	 push rcx
	 push rdi
	 mov dil, byte [rdi]
	 MAKE_CHAR(rax, dil)
	 push rax
	 MAKE_RATIONAL(rax, rcx, 1)
	 push rax
	 push 2
	 push SOB_NIL_ADDRESS
	 call make_string
	 add rsp, 4*8
	 STRING_ELEMENTS rsi, rax   
	 pop rdi
	 pop rcx
	 cmp rcx, 0
	 je .end
         .loop:
	 lea r8, [rdi+rcx]
	 lea r9, [rsi+rcx]
	 mov bl, byte [r8]
	 mov byte [r9], bl
	 loop .loop
         .end:
         pop rbp
         ret

eq?:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	cmp rsi, rdi
      je .true
       mov rax, SOB_FALSE_ADDRESS
       jmp .return
       .true:
       mov rax, SOB_TRUE_ADDRESS
       .return:
         pop rbp
         ret

char_to_integer:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	CHAR_VAL rsi, rsi
	 and rsi, 255
	 MAKE_RATIONAL(rax, rsi, 1)
         pop rbp
         ret

integer_to_char:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	NUMERATOR rsi, rsi
	 and rsi, 255
	 MAKE_CHAR(rax, sil)
         pop rbp
         ret

exact_to_inexact:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	DENOMINATOR rdi, rsi
	 NUMERATOR rsi, rsi 
	 cvtsi2sd xmm0, rsi
	 cvtsi2sd xmm1, rdi
	 divsd xmm0, xmm1
	 movq rsi, xmm0
	 MAKE_FLOAT(rax, rsi)
         pop rbp
         ret

numerator:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	NUMERATOR rsi, rsi
	 mov rdi, 1
	 MAKE_RATIONAL(rax, rsi, rdi)
         pop rbp
         ret

denominator:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	DENOMINATOR rsi, rsi
	 mov rdi, 1
	 MAKE_RATIONAL(rax, rsi, rdi)
         pop rbp
         ret

gcd:
       push rbp
       mov rbp, rsp 
       mov rsi, PVAR(0)
	mov rdi, PVAR(1)
	xor rdx, rdx
	 NUMERATOR rax, rsi
         NUMERATOR rdi, rdi
         .gcd_loop:
     and rdi, rdi
     jz .end_gcd_loop
     cqo
     idiv rdi
     mov rax, rdi
     mov rdi, rdx
     jmp .gcd_loop	
     .end_gcd_loop:
	 mov rdx, rax
         cmp rdx, 0
         jge .make_result
         neg rdx
         .make_result:
         MAKE_RATIONAL(rax, rdx, 1)
         pop rbp
         ret

cons:
  push rbp
  mov rbp , rsp
  mov qword rbx, [rbp+8*4]  ;rax->arg_0 = obj1
  mov qword rcx, [rbp+8*5]  ;rbx->arg_1 = obj2
  MALLOC rax, 17  ;rax->empty list= [1byte type_tag , 8bytes car ptr , 8bytes cdr ptr]
  mov byte [rax], T_PAIR  ; set TypeTag = T_PAIR
  mov qword [rax+1], rbx  ; set car-> obj1
  mov qword [rax+9], rcx  ; set cdr-> obj2
  leave
  ret

apply:
  push rbp
  mov rbp , rsp
  
  ;anyway-> push magic
  push SOB_NIL_ADDRESS ; push magic

  mov rbx, [rbp+8*4] ; rbx holds the func we wanna apply
  mov rcx,  [rbp+8*3] ;rcx holds argCount(n)
  cmp rcx, 1 ; 
  je .no_arg
  
  ;else-> we have at least the list at the end
  ;push list args
  mov r10, [rbp+8*(4+rcx-1)] ; r10->lst
  mov qword r11, 0; r11= size of list
  cmp r10, SOB_NIL_ADDRESS; if list is empty
  je .end_loop_of_pushes
  ; else-> lst !=nill -> so we need to reverse it and than push each var in it
  ;reverse:
  ;first push by order each var in lst to stack:
  mov qword r12, [r10+1] ;r12->car
  mov qword r13, [r10+1+8] ;r13->cdr
  .loop_of_pushes:
    inc r11
    push qword r12
    cmp r13, SOB_NIL_ADDRESS; if cdr is empty
    je .end_loop_of_pushes
    mov qword r12, [r13+1] ;r12->car
    mov qword r13, [r13+1+8] ;r13->cdr
    jmp .loop_of_pushes
  .end_loop_of_pushes:
  ;now: r11= lst size , stack contains all vars.

  shl r11, 3 ; r11 = 8* lst_size
  MALLOC rax, r11 ; allocate size for lst in heap
  shr r11, 3 ; reset r11 =lst_size
  mov r12, 0 ; idx
  .loop_copy_lst_in_reverse:
    cmp r12, r11 
    jge .end_loop_copy_lst_in_reverse ;jump to end if idx >= lst size
    pop qword [rax +8*r12] ; pop arg from stack and put it in lst[i]
    inc r12
    jmp .loop_copy_lst_in_reverse
  .end_loop_copy_lst_in_reverse:
  ; now rax->reversed lst

  ; now push vars of reversed lst:
  mov r12, 0 ; idx
  .loop_push_reveres_lst:
    cmp r12, r11 
    jge .end_loop_push_reveres_lst ;jump to end if idx >= lst size
    push qword [rax +8*r12] ; pop arg from stack and put it in lst[i]
    inc r12
    jmp .loop_push_reveres_lst
  .end_loop_push_reveres_lst:


  cmp rcx, 2
  je .list_only
  ;else-> we have opt args
  .opt_args:
    mov r12, 1 ; idx
    mov r13, rcx
    sub r13, 2    ; r13= idx of arg_n-2
    .loop_push_opts:
      cmp r12, r13 
      jg .end_loop_push_opts ;jump to end if idx > num of opt args
      push qword [rbp+8*(4+r13)] ; push arg from the end
      dec r13
      jmp .loop_push_opts
    .end_loop_push_opts:

    ;all arg on heap:

    sub rcx, 2
    add rcx, r11  ;rcx = argCount(n) -2 + lstSize
    push rcx  ;push n
    jmp .end_apply

  .list_only:
    push r11 ;push n
    jmp .end_apply
  .no_arg:
    push 0

  .end_apply:
    mov r12, qword [rbx+1]
    push qword r12 ; push env of closure that we are gonna call
    call qword [rbx+9]
    add rsp , 8*1 ; pop env
    pop rbx ; pop arg count
    lea rsp , [rsp + 8*rbx]; pop args
    add rsp , 8 ; pop magic, which is sob_nil

  leave
  ret


car:
  push rbp
  mov rbp , rsp
  ;arg_0= ptr to a list
  ;list is : 1byte type_tag , 8bytes car ptr , 8bytes cdr ptr
  mov qword rax, [rbp+8*4]; rax->lst
  mov qword rax, [rax+1]
  leave
  ret

cdr:
  push rbp
  mov rbp , rsp
  ;arg_0= ptr to a list
  ;list is : 1byte type_tag , 8bytes car ptr , 8bytes cdr ptr
  mov qword rax, [rbp+8*4]; rax->lst
  mov qword rax, [rax+1+8]; rax->cdr
  leave
  ret

set_car:
  push rbp
  mov rbp , rsp
  mov qword rax, [rbp+8*4]  ;rax->arg_0 = ->list= [1byte type_tag , 8bytes car ptr , 8bytes cdr ptr]
  mov qword rbx, [rbp+8*5]  ;rbx->arg_1 = obj
  mov qword [rax+1], rbx; car->obj
  mov qword rax, SOB_VOID_ADDRESS ; set is void
  leave
  ret

set_cdr:
  push rbp
  mov rbp , rsp
  mov qword rax, [rbp+8*4]  ;rax->arg_0 = ->list= [1byte type_tag , 8bytes car ptr , 8bytes cdr ptr]
  mov qword rbx, [rbp+8*5]  ;rbx->arg_1 = obj
  mov qword [rax+1+8], rbx; car->obj
  mov qword rax, SOB_VOID_ADDRESS ; set is void
  leave
  ret